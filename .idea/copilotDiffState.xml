<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/android/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/android/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot;/&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.SCHEDULE_EXACT_ALARM&quot;/&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;/&gt;&#10;&#10;    &lt;application&#10;        android:label=&quot;poketask&quot;&#10;        android:name=&quot;${applicationName}&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:launchMode=&quot;singleTop&quot;&#10;            android:taskAffinity=&quot;&quot;&#10;            android:theme=&quot;@style/LaunchTheme&quot;&#10;            android:configChanges=&quot;orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode&quot;&#10;            android:hardwareAccelerated=&quot;true&quot;&#10;            android:windowSoftInputMode=&quot;adjustResize&quot;&gt;&#10;            &lt;!-- Specifies an Android theme to apply to this Activity as soon as&#10;                 the Android process has started. This theme is visible to the user&#10;                 while the Flutter UI initializes. After that, this theme continues&#10;                 to determine the Window background behind the Flutter UI. --&gt;&#10;            &lt;meta-data&#10;              android:name=&quot;io.flutter.embedding.android.NormalTheme&quot;&#10;              android:resource=&quot;@style/NormalTheme&quot;&#10;              /&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;        &lt;!-- Don't delete the meta-data below.&#10;             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java --&gt;&#10;        &lt;meta-data&#10;            android:name=&quot;flutterEmbedding&quot;&#10;            android:value=&quot;2&quot; /&gt;&#10;        &lt;receiver android:name=&quot;com.dexterous.flutterlocalnotifications.ScheduledNotificationBootReceiver&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot;/&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MY_PACKAGE_REPLACED&quot;/&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/receiver&gt;&#10;        &lt;receiver android:name=&quot;com.dexterous.flutterlocalnotifications.ScheduledNotificationReceiver&quot; /&gt;&#10;    &lt;/application&gt;&#10;    &lt;!-- Required to query activities that can process text, see:&#10;         https://developer.android.com/training/package-visibility and&#10;         https://developer.android.com/reference/android/content/Intent#ACTION_PROCESS_TEXT.&#10;&#10;         In particular, this is used by the Flutter engine in io.flutter.plugin.text.ProcessTextPlugin. --&gt;&#10;    &lt;queries&gt;&#10;        &lt;intent&gt;&#10;            &lt;action android:name=&quot;android.intent.action.PROCESS_TEXT&quot;/&gt;&#10;            &lt;data android:mimeType=&quot;text/plain&quot;/&gt;&#10;        &lt;/intent&gt;&#10;    &lt;/queries&gt;&#10;&lt;/manifest&gt;&#10;" />
              <option name="updatedContent" value="&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot;/&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.SCHEDULE_EXACT_ALARM&quot;/&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;/&gt;&#10;&#10;    &lt;application&#10;        android:label=&quot;poketask&quot;&#10;        android:name=&quot;${applicationName}&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:launchMode=&quot;singleTop&quot;&#10;            android:taskAffinity=&quot;&quot;&#10;            android:theme=&quot;@style/LaunchTheme&quot;&#10;            android:configChanges=&quot;orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode&quot;&#10;            android:hardwareAccelerated=&quot;true&quot;&#10;            android:windowSoftInputMode=&quot;adjustResize&quot;&gt;&#10;            &lt;!-- Specifies an Android theme to apply to this Activity as soon as&#10;                 the Android process has started. This theme is visible to the user&#10;                 while the Flutter UI initializes. After that, this theme continues&#10;                 to determine the Window background behind the Flutter UI. --&gt;&#10;            &lt;meta-data&#10;              android:name=&quot;io.flutter.embedding.android.NormalTheme&quot;&#10;              android:resource=&quot;@style/NormalTheme&quot;&#10;              /&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;        &lt;!-- Don't delete the meta-data below.&#10;             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java --&gt;&#10;        &lt;meta-data&#10;            android:name=&quot;flutterEmbedding&quot;&#10;            android:value=&quot;2&quot; /&gt;&#10;        &lt;receiver android:name=&quot;com.dexterous.flutterlocalnotifications.ScheduledNotificationBootReceiver&quot;&#10;                  android:exported=&quot;false&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot;/&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MY_PACKAGE_REPLACED&quot;/&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/receiver&gt;&#10;        &lt;receiver android:name=&quot;com.dexterous.flutterlocalnotifications.ScheduledNotificationReceiver&quot; /&gt;&#10;    &lt;/application&gt;&#10;    &lt;!-- Required to query activities that can process text, see:&#10;         https://developer.android.com/training/package-visibility and&#10;         https://developer.android.com/reference/android/content/Intent#ACTION_PROCESS_TEXT.&#10;&#10;         In particular, this is used by the Flutter engine in io.flutter.plugin.text.ProcessTextPlugin. --&gt;&#10;    &lt;queries&gt;&#10;        &lt;intent&gt;&#10;            &lt;action android:name=&quot;android.intent.action.PROCESS_TEXT&quot;/&gt;&#10;            &lt;data android:mimeType=&quot;text/plain&quot;/&gt;&#10;        &lt;/intent&gt;&#10;    &lt;/queries&gt;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lib/models/battle_game_state.dart">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lib/models/battle_game_state.dart" />
              <option name="originalContent" value="import 'dart:math';&#10;import 'pokemon_mcts.dart';&#10;&#10;class BattleGameState {&#10;  final List&lt;Pokemon_mcts&gt; playerTeam;&#10;  final List&lt;Pokemon_mcts&gt; opponentTeam;&#10;  int playerActive;&#10;  int opponentActive;&#10;  bool isPlayerTurn;&#10;&#10;  BattleGameState({&#10;    required this.playerTeam,&#10;    required this.opponentTeam,&#10;    this.playerActive = 0,&#10;    this.opponentActive = 0,&#10;    this.isPlayerTurn = true,&#10;  });&#10;&#10;  BattleGameState clone() {&#10;    return BattleGameState(&#10;      playerTeam: playerTeam.map((p) =&gt; p.clone()).toList(),&#10;      opponentTeam: opponentTeam.map((p) =&gt; p.clone()).toList(),&#10;      playerActive: playerActive,&#10;      opponentActive: opponentActive,&#10;      isPlayerTurn: isPlayerTurn,&#10;    );&#10;  }&#10;&#10;  Pokemon_mcts getActive(bool forPlayer) {&#10;    return forPlayer ? playerTeam[playerActive] : opponentTeam[opponentActive];&#10;  }&#10;&#10;  List&lt;String&gt; getValidActions() {&#10;    final actions = &lt;String&gt;[];&#10;    final active = getActive(isPlayerTurn);&#10;    final team = isPlayerTurn ? playerTeam : opponentTeam;&#10;    final activeIndex = isPlayerTurn ? playerActive : opponentActive;&#10;&#10;    // If active PokÃ©mon is fainted, only allow switches&#10;    if (active.isFainted) {&#10;      for (int i = 0; i &lt; team.length; i++) {&#10;        if (i != activeIndex &amp;&amp; !team[i].isFainted) {&#10;          actions.add(&quot;switch_$i&quot;);&#10;        }&#10;      }&#10;      return actions;&#10;    }&#10;&#10;    // Otherwise, allow moves and switches&#10;    for (int i = 0; i &lt; active.abilities.length; i++) {&#10;      if (active.abilities[i].remainingUses &gt; 0) {&#10;        actions.add(&quot;move_$i&quot;);&#10;      }&#10;    }&#10;    for (int i = 0; i &lt; team.length; i++) {&#10;      if (i != activeIndex &amp;&amp; !team[i].isFainted) {&#10;        actions.add(&quot;switch_$i&quot;);&#10;      }&#10;    }&#10;    return actions;&#10;  }&#10;&#10;  void applyAction(String action) {&#10;    final active = getActive(isPlayerTurn);&#10;    // Prevent moves if active PokÃ©mon is fainted&#10;    if (active.isFainted &amp;&amp; action.startsWith(&quot;move_&quot;)) {&#10;      return;&#10;    }&#10;    if (action.startsWith(&quot;move_&quot;)) {&#10;      final index = int.parse(action.split(&quot;_&quot;)[1]);&#10;      _applyMove(index);&#10;    } else if (action.startsWith(&quot;switch_&quot;)) {&#10;      final index = int.parse(action.split(&quot;_&quot;)[1]);&#10;      if (isPlayerTurn) {&#10;        playerActive = index;&#10;      } else {&#10;        opponentActive = index;&#10;      }&#10;      isPlayerTurn = !isPlayerTurn;&#10;    }&#10;  }&#10;&#10;  void _applyMove(int index) {&#10;    final attacker = getActive(isPlayerTurn);&#10;    final defender = getActive(!isPlayerTurn);&#10;    final move = attacker.abilities[index];&#10;&#10;    if (move.remainingUses == 0) return;&#10;&#10;    move.remainingUses -= 1;&#10;&#10;    if (Random().nextInt(100) &gt;= move.hitRate) {&#10;      isPlayerTurn = !isPlayerTurn;&#10;      return; // Missed&#10;    }&#10;&#10;    final multiplier = _getTypeEffectiveness(move.type, defender.type);&#10;    // New damage formula: (ability value + (pokemon attack * 0.1)) * type multiplier, rounded down&#10;    final rawDamage = (move.value + (attacker.attack * 0.1)) * multiplier;&#10;    final damage = rawDamage.floor();&#10;    defender.currentHealth -= damage;&#10;    isPlayerTurn = !isPlayerTurn;&#10;  }&#10;&#10;  double _getTypeEffectiveness(String atk, String def) {&#10;    final chart = {&#10;      'Fire': {'Grass': 1.5, 'Water': 0.7, 'Rock': 0.7, 'Ice': 1.5, 'Bug': 1.2},&#10;      'Water': {'Fire': 1.5, 'Electric': 0.7, 'Rock': 1.2, 'Ground': 1.2, 'Grass': 0.7},&#10;      'Electric': {'Water': 1.5, 'Grass': 0.7, 'Flying': 1.2, 'Ground': 0.7},&#10;      'Grass': {'Water': 1.5, 'Fire': 0.7, 'Ground': 1.2, 'Rock': 1.2, 'Bug': 0.7},&#10;      'Rock': {'Fire': 1.2, 'Flying': 1.2, 'Bug': 1.2, 'Fighting': 0.7, 'Ground': 0.7},&#10;      'Ground': {'Fire': 1.2, 'Electric': 1.5, 'Rock': 1.2, 'Grass': 0.7, 'Bug': 0.7},&#10;      'Flying': {'Grass': 1.2, 'Electric': 0.7, 'Bug': 1.2, 'Rock': 0.7},&#10;      'Bug': {'Grass': 1.2, 'Fire': 0.7, 'Flying': 0.7, 'Rock': 0.7},&#10;      'Ice': {'Grass': 1.2, 'Ground': 1.2, 'Flying': 1.2, 'Water': 0.7, 'Fire': 0.7},&#10;      'Fighting': {'Rock': 1.2, 'Ice': 1.2, 'Flying': 0.7, 'Psychic': 0.7},&#10;      'Psychic': {'Fighting': 1.2, 'Poison': 1.2, 'Psychic': 0.7},&#10;      'Poison': {'Grass': 1.2, 'Poison': 0.7, 'Ground': 0.7, 'Rock': 0.7},&#10;      // Add more types as needed&#10;    };&#10;    return chart[atk]?[def] ?? 1.0;&#10;  }&#10;&#10;  bool get isTerminal {&#10;    final playerAlive = playerTeam.any((p) =&gt; !p.isFainted);&#10;    final opponentAlive = opponentTeam.any((p) =&gt; !p.isFainted);&#10;    return !playerAlive || !opponentAlive;&#10;  }&#10;&#10;  int evaluate() {&#10;    int score = 0;&#10;&#10;    for (final p in playerTeam) {&#10;      if (!p.isFainted) {&#10;        score += 5; // reward each conscious PokÃ©mon&#10;        score += (p.currentHealth ~/ 5); // reward remaining HP&#10;      }&#10;    }&#10;&#10;    for (final o in opponentTeam) {&#10;      if (!o.isFainted) {&#10;        score -= 5;&#10;        score -= (o.currentHealth ~/ 5);&#10;      }&#10;    }&#10;&#10;    return score.sign; // Returns -1, 0, or 1 (same as before)&#10;  }&#10;&#10;  double previewEffectiveness(String moveAction) {&#10;    if (!moveAction.startsWith(&quot;move_&quot;)) return 1.0;&#10;    final moveIndex = int.parse(moveAction.split('_')[1]);&#10;    final attacker = getActive(isPlayerTurn);&#10;    final defender = getActive(!isPlayerTurn);&#10;    final move = attacker.abilities[moveIndex];&#10;    return _getTypeEffectiveness(move.type, defender.type);&#10;  }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="import 'dart:math';&#13;&#10;import 'pokemon_mcts.dart';&#13;&#10;&#13;&#10;class BattleGameState {&#13;&#10;  final List&lt;Pokemon_mcts&gt; playerTeam;&#13;&#10;  final List&lt;Pokemon_mcts&gt; opponentTeam;&#13;&#10;  int playerActive;&#13;&#10;  int opponentActive;&#13;&#10;  bool isPlayerTurn;&#13;&#10;&#13;&#10;  BattleGameState({&#13;&#10;    required this.playerTeam,&#13;&#10;    required this.opponentTeam,&#13;&#10;    this.playerActive = 0,&#13;&#10;    this.opponentActive = 0,&#13;&#10;    this.isPlayerTurn = true,&#13;&#10;  });&#13;&#10;&#13;&#10;  BattleGameState clone() {&#13;&#10;    return BattleGameState(&#13;&#10;      playerTeam: playerTeam.map((p) =&gt; p.clone()).toList(),&#13;&#10;      opponentTeam: opponentTeam.map((p) =&gt; p.clone()).toList(),&#13;&#10;      playerActive: playerActive,&#13;&#10;      opponentActive: opponentActive,&#13;&#10;      isPlayerTurn: isPlayerTurn,&#13;&#10;    );&#13;&#10;  }&#13;&#10;&#13;&#10;  Pokemon_mcts getActive(bool forPlayer) {&#13;&#10;    return forPlayer ? playerTeam[playerActive] : opponentTeam[opponentActive];&#13;&#10;  }&#13;&#10;&#13;&#10;  List&lt;String&gt; getValidActions() {&#13;&#10;    final actions = &lt;String&gt;[];&#13;&#10;    final active = getActive(isPlayerTurn);&#13;&#10;    final team = isPlayerTurn ? playerTeam : opponentTeam;&#13;&#10;    final activeIndex = isPlayerTurn ? playerActive : opponentActive;&#13;&#10;&#13;&#10;    // If active PokÃ©mon is fainted, only allow switches&#13;&#10;    if (active.isFainted) {&#13;&#10;      for (int i = 0; i &lt; team.length; i++) {&#13;&#10;        if (i != activeIndex &amp;&amp; !team[i].isFainted) {&#13;&#10;          actions.add(&quot;switch_$i&quot;);&#13;&#10;        }&#13;&#10;      }&#13;&#10;      return actions;&#13;&#10;    }&#13;&#10;&#13;&#10;    // Otherwise, allow moves and switches&#13;&#10;    for (int i = 0; i &lt; active.abilities.length; i++) {&#13;&#10;      if (active.abilities[i].remainingUses &gt; 0) {&#13;&#10;        actions.add(&quot;move_$i&quot;);&#13;&#10;      }&#13;&#10;    }&#13;&#10;    for (int i = 0; i &lt; team.length; i++) {&#13;&#10;      if (i != activeIndex &amp;&amp; !team[i].isFainted) {&#13;&#10;        actions.add(&quot;switch_$i&quot;);&#13;&#10;      }&#13;&#10;    }&#13;&#10;    return actions;&#13;&#10;  }&#13;&#10;&#13;&#10;  void applyAction(String action) {&#13;&#10;    final active = getActive(isPlayerTurn);&#13;&#10;    // Prevent moves if active PokÃ©mon is fainted&#13;&#10;    if (active.isFainted &amp;&amp; action.startsWith(&quot;move_&quot;)) {&#13;&#10;      return;&#13;&#10;    }&#13;&#10;    if (action.startsWith(&quot;move_&quot;)) {&#13;&#10;      final index = int.parse(action.split(&quot;_&quot;)[1]);&#13;&#10;      _applyMove(index);&#13;&#10;    } else if (action.startsWith(&quot;switch_&quot;)) {&#13;&#10;      final index = int.parse(action.split(&quot;_&quot;)[1]);&#13;&#10;      if (isPlayerTurn) {&#13;&#10;        playerActive = index;&#13;&#10;      } else {&#13;&#10;        opponentActive = index;&#13;&#10;      }&#13;&#10;      isPlayerTurn = !isPlayerTurn;&#13;&#10;    }&#13;&#10;  }&#13;&#10;&#13;&#10;  void _applyMove(int index) {&#13;&#10;    final attacker = getActive(isPlayerTurn);&#13;&#10;    final defender = getActive(!isPlayerTurn);&#13;&#10;    final move = attacker.abilities[index];&#13;&#10;&#13;&#10;    if (move.remainingUses == 0) return;&#13;&#10;&#13;&#10;    move.remainingUses -= 1;&#13;&#10;&#13;&#10;    if (Random().nextInt(100) &gt;= move.hitRate) {&#13;&#10;      isPlayerTurn = !isPlayerTurn;&#13;&#10;      return; // Missed&#13;&#10;    }&#13;&#10;&#13;&#10;    final multiplier = _getTypeEffectiveness(move.type, defender.type);&#13;&#10;    final rawValue = (move.value + (attacker.attack * 0.1)) * multiplier;&#13;&#10;    final value = rawValue.floor();&#13;&#10;    if (move.value &lt; 0) {&#13;&#10;      // Healing move: heal attacker by |value|, but not above maxHealth&#13;&#10;      attacker.currentHealth = (attacker.currentHealth + value.abs()).clamp(0, attacker.maxHealth);&#13;&#10;    } else {&#13;&#10;      // Damage move: damage defender&#13;&#10;      defender.currentHealth -= value;&#13;&#10;    }&#13;&#10;    isPlayerTurn = !isPlayerTurn;&#13;&#10;  }&#13;&#10;&#13;&#10;  double _getTypeEffectiveness(String atk, String def) {&#13;&#10;    final chart = {&#13;&#10;      'Fire': {'Grass': 1.5, 'Water': 0.7, 'Rock': 0.7, 'Ice': 1.5, 'Bug': 1.2},&#13;&#10;      'Water': {'Fire': 1.5, 'Electric': 0.7, 'Rock': 1.2, 'Ground': 1.2, 'Grass': 0.7},&#13;&#10;      'Electric': {'Water': 1.5, 'Grass': 0.7, 'Flying': 1.2, 'Ground': 0.7},&#13;&#10;      'Grass': {'Water': 1.5, 'Fire': 0.7, 'Ground': 1.2, 'Rock': 1.2, 'Bug': 0.7},&#13;&#10;      'Rock': {'Fire': 1.2, 'Flying': 1.2, 'Bug': 1.2, 'Fighting': 0.7, 'Ground': 0.7},&#13;&#10;      'Ground': {'Fire': 1.2, 'Electric': 1.5, 'Rock': 1.2, 'Grass': 0.7, 'Bug': 0.7},&#13;&#10;      'Flying': {'Grass': 1.2, 'Electric': 0.7, 'Bug': 1.2, 'Rock': 0.7},&#13;&#10;      'Bug': {'Grass': 1.2, 'Fire': 0.7, 'Flying': 0.7, 'Rock': 0.7},&#13;&#10;      'Ice': {'Grass': 1.2, 'Ground': 1.2, 'Flying': 1.2, 'Water': 0.7, 'Fire': 0.7},&#13;&#10;      'Fighting': {'Rock': 1.2, 'Ice': 1.2, 'Flying': 0.7, 'Psychic': 0.7},&#13;&#10;      'Psychic': {'Fighting': 1.2, 'Poison': 1.2, 'Psychic': 0.7},&#13;&#10;      'Poison': {'Grass': 1.2, 'Poison': 0.7, 'Ground': 0.7, 'Rock': 0.7},&#13;&#10;      // Add more types as needed&#13;&#10;    };&#13;&#10;    return chart[atk]?[def] ?? 1.0;&#13;&#10;  }&#13;&#10;&#13;&#10;  bool get isTerminal {&#13;&#10;    final playerAlive = playerTeam.any((p) =&gt; !p.isFainted);&#13;&#10;    final opponentAlive = opponentTeam.any((p) =&gt; !p.isFainted);&#13;&#10;    return !playerAlive || !opponentAlive;&#13;&#10;  }&#13;&#10;&#13;&#10;  int evaluate() {&#13;&#10;    int score = 0;&#13;&#10;&#13;&#10;    for (final p in playerTeam) {&#13;&#10;      if (!p.isFainted) {&#13;&#10;        score += 5; // reward each conscious PokÃ©mon&#13;&#10;        score += (p.currentHealth ~/ 5); // reward remaining HP&#13;&#10;      }&#13;&#10;    }&#13;&#10;&#13;&#10;    for (final o in opponentTeam) {&#13;&#10;      if (!o.isFainted) {&#13;&#10;        score -= 5;&#13;&#10;        score -= (o.currentHealth ~/ 5);&#13;&#10;      }&#13;&#10;    }&#13;&#10;&#13;&#10;    return score.sign; // Returns -1, 0, or 1 (same as before)&#13;&#10;  }&#13;&#10;&#13;&#10;  double previewEffectiveness(String moveAction) {&#13;&#10;    if (!moveAction.startsWith(&quot;move_&quot;)) return 1.0;&#13;&#10;    final moveIndex = int.parse(moveAction.split('_')[1]);&#13;&#10;    final attacker = getActive(isPlayerTurn);&#13;&#10;    final defender = getActive(!isPlayerTurn);&#13;&#10;    final move = attacker.abilities[moveIndex];&#13;&#10;    return _getTypeEffectiveness(move.type, defender.type);&#13;&#10;  }&#13;&#10;&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lib/pages/pokebattle_page.dart">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lib/pages/pokebattle_page.dart" />
              <option name="originalContent" value="import 'package:flutter/material.dart';&#10;import '../mcts/pokebattle_controller.dart';&#10;import '../models/battle_game_state.dart';&#10;import '../models/pokemon_mcts.dart';&#10;import '../models/ability_mcts.dart';&#10;import '../mcts/mcts_search.dart'; // For direct MCTS call&#10;import 'package:animated_text_kit/animated_text_kit.dart';&#10;import '../services/music_service.dart';&#10;import '../services/xp_utils.dart';&#10;import '../services/ability_utils.dart';&#10;import 'package:supabase_flutter/supabase_flutter.dart';&#10;&#10;&#10;class PokeBattlePage extends StatefulWidget {&#10;  final String trainerId;&#10;  const PokeBattlePage({super.key, required this.trainerId});&#10;&#10;  @override&#10;  State&lt;PokeBattlePage&gt; createState() =&gt; _PokeBattlePageState();&#10;}&#10;&#10;class _PokeBattlePageState extends State&lt;PokeBattlePage&gt; {&#10;  late PokeBattleController? controller;&#10;  String? lastAiAction;&#10;  bool playerJustAttacked = false;&#10;  bool opponentJustAttacked = false;&#10;&#10;  String narration = &quot;&quot;;&#10;  bool isAnimating = false;&#10;&#10;  bool isMusicPlaying = true;&#10;&#10;  String selectedArena = &quot;&quot;;&#10;  String selectedArenaText = &quot;&quot;;&#10;  final List&lt;String&gt; arenaTypes = [&#10;    'desert', 'water', 'snow', 'hills', 'cave', 'beach', 'grass'&#10;  ];&#10;&#10;  final bool movesExpanded = true;&#10;&#10;  bool isLoading = true;&#10;&#10;  String? winnerTrainerName;&#10;&#10;  bool hasHandledBattleEnd = false;&#10;&#10;  String? playerTrainerName;&#10;  String? opponentTrainerName;&#10;  String? playerName;&#10;  String? opponentName;&#10;&#10;  @override&#10;  void initState() {&#10;    super.initState();&#10;    // Stop menu music before starting battle music&#10;    MusicService().stopMusic();&#10;    playBattleMusic();&#10;    isMusicPlaying = true;&#10;    controller = null;&#10;    _initTeams();&#10;  }&#10;&#10;  Future&lt;void&gt; _initTeams() async {&#10;    setState(() { isLoading = true; });&#10;    final supabase = Supabase.instance.client;&#10;    // Fetch player trainer row&#10;    final trainerRes = await supabase&#10;      .from('trainer_table')&#10;      .select()&#10;      .eq('trainer_id', widget.trainerId)&#10;      .maybeSingle(); // safer than .single()&#10;    if (trainerRes == null) {&#10;      setState(() { narration = &quot;Trainer not found.&quot;; isLoading = false; });&#10;      return;&#10;    }&#10;    playerTrainerName = trainerRes['username'] ?? 'You';&#10;    playerName = playerTrainerName;&#10;    // Get player team&#10;    final playerTeam = await _fetchTeamFromTrainerRow(trainerRes);&#10;    if (playerTeam.isEmpty) {&#10;      setState(() {&#10;        narration = &quot;You have no PokÃ©mon in your team. Please add PokÃ©mon before battling.&quot;;&#10;        isLoading = false;&#10;      });&#10;      return;&#10;    }&#10;    // Get random opponent trainer&#10;    final trainers = await supabase&#10;      .from('trainer_table')&#10;      .select('trainer_id,username');&#10;    final opponentIds = trainers.where((t) =&gt; t['trainer_id'] != widget.trainerId).toList();&#10;    opponentIds.shuffle();&#10;    final opponentId = opponentIds.isNotEmpty ? opponentIds.first['trainer_id'] : widget.trainerId;&#10;    final opponentRes = await supabase&#10;      .from('trainer_table')&#10;      .select()&#10;      .eq('trainer_id', opponentId)&#10;      .maybeSingle(); // safer than .single()&#10;    opponentTrainerName = opponentRes?['username'] ?? 'Opponent';&#10;    opponentName = opponentTrainerName;&#10;    final opponentTeam = await _fetchTeamFromTrainerRow(opponentRes ?? {});&#10;    if (opponentTeam.isEmpty) {&#10;      setState(() {&#10;        narration = &quot;Opponent has no PokÃ©mon. Try again later.&quot;;&#10;        isLoading = false;&#10;      });&#10;      return;&#10;    }&#10;    // Setup battle state&#10;    final state = BattleGameState(&#10;      playerTeam: playerTeam,&#10;      opponentTeam: opponentTeam,&#10;    );&#10;    setState(() {&#10;      controller = PokeBattleController(gameState: state);&#10;      // Randomly select an arena type&#10;      final rand = arenaTypes..shuffle();&#10;      selectedArena = rand.first;&#10;      selectedArenaText = selectedArena[0].toUpperCase() + selectedArena.substring(1);&#10;      isLoading = false;&#10;    });&#10;  }&#10;&#10;  Future&lt;List&lt;Pokemon_mcts&gt;&gt; _fetchTeamFromTrainerRow(Map trainerRow) async {&#10;    final supabase = Supabase.instance.client;&#10;    List&lt;Pokemon_mcts&gt; team = [];&#10;    for (int i = 1; i &lt;= 6; i++) {&#10;      final slotKey = 'pokemon_slot_$i';&#10;      final pokeId = trainerRow[slotKey];&#10;      if (pokeId == null) continue;&#10;      final pokeRes = await supabase&#10;        .from('pokemon_table')&#10;        .select()&#10;        .eq('pokemon_id', pokeId)&#10;        .maybeSingle(); // safer than .single()&#10;      if (pokeRes == null) continue;&#10;      // Fetch abilities&#10;      List&lt;Ability_mcts&gt; abilities = [];&#10;      for (int j = 1; j &lt;= 4; j++) {&#10;        final abKey = 'ability$j';&#10;        final abId = pokeRes[abKey];&#10;        if (abId == null) continue;&#10;        final abRes = await supabase&#10;          .from('abilities_table')&#10;          .select()&#10;          .eq('ability_id', abId)&#10;          .maybeSingle(); // safer than .single()&#10;        if (abRes == null) continue;&#10;        abilities.add(Ability_mcts(&#10;          name: abRes['ability_name'],&#10;          type: abRes['type'],&#10;          maxUses: abRes['uses'],&#10;          hitRate: abRes['hitrate'],&#10;          value: abRes['value'],&#10;        ));&#10;      }&#10;      team.add(Pokemon_mcts(&#10;        pokemonName: pokeRes['pokemon_name'],&#10;        nickname: pokeRes['nickname'],&#10;        type: pokeRes['type'],&#10;        level: pokeRes['level'],&#10;        attack: pokeRes['attack'],&#10;        maxHealth: pokeRes['health'],&#10;        abilities: abilities,&#10;      ));&#10;    }&#10;    return team;&#10;  }&#10;&#10;  String getEffectivenessText(double multiplier) {&#10;    if (multiplier &gt;= 2.0) return &quot;It's super effective!&quot;;&#10;    if (multiplier &gt;= 1.1) return &quot;It's effective!&quot;;&#10;    if (multiplier &lt;= 0.5) return &quot;It's not very effective...&quot;;&#10;    return &quot;&quot;;&#10;  }&#10;&#10;&#10;&#10;  Future&lt;void&gt; _handleBattleEnd() async {&#10;    if (hasHandledBattleEnd) return;&#10;    hasHandledBattleEnd = true;&#10;    final supabase = Supabase.instance.client;&#10;    final isWin = controller!.getWinner() == 1;&#10;    final isLoss = controller!.getWinner() == -1;&#10;    if (!isWin &amp;&amp; !isLoss) return;&#10;    final trainerRes = await supabase&#10;      .from('trainer_table')&#10;      .select()&#10;      .eq('trainer_id', widget.trainerId)&#10;      .maybeSingle();&#10;    if (trainerRes == null) return;&#10;    // Use names assigned in _initTeams&#10;    winnerTrainerName = isWin ? (playerName ?? 'You') : (opponentName ?? 'Opponent');&#10;    int wins = trainerRes['wins'] ?? 0;&#10;    int losses = trainerRes['losses'] ?? 0;&#10;    int xp = trainerRes['experience_points'] ?? 0;&#10;    int level = trainerRes['level'] ?? 1;&#10;    int gainedXp = isWin ? 250 : 100;&#10;    // Use battle context scaler (1.1) and base (100)&#10;    final trainerXpResult = calculateXpAndLevel(&#10;      currentXp: xp,&#10;      currentLevel: level,&#10;      xpChange: gainedXp,&#10;      scaler: 1.1,&#10;      base: 100,&#10;    );&#10;    xp = trainerXpResult.newXp;&#10;    level = trainerXpResult.newLevel;&#10;    bool trainerLeveledUp = trainerXpResult.levelsGained &gt; 0;&#10;    if (isWin) wins += 1;&#10;    if (isLoss) losses += 1;&#10;    await supabase&#10;      .from('trainer_table')&#10;      .update({&#10;        'wins': wins,&#10;        'losses': losses,&#10;        'experience_points': xp,&#10;        'level': level,&#10;      })&#10;      .eq('trainer_id', widget.trainerId);&#10;    List&lt;String&gt; pokemonLevelUps = [];&#10;    List&lt;Future&lt;void&gt;&gt; abilityDialogs = [];&#10;    Set&lt;String&gt; slotPokeIds = {};&#10;    for (int i = 1; i &lt;= 6; i++) {&#10;      final slotKey = 'pokemon_slot_$i';&#10;      final pokeId = trainerRes[slotKey];&#10;      if (pokeId == null) continue;&#10;      slotPokeIds.add(pokeId.toString());&#10;      final pokeRes = await supabase&#10;        .from('pokemon_table')&#10;        .select()&#10;        .eq('pokemon_id', pokeId)&#10;        .maybeSingle();&#10;      if (pokeRes == null) continue;&#10;      int pokeXp = pokeRes['experience_points'] ?? 0;&#10;      int pokeLevel = pokeRes['level'] ?? 1;&#10;      final pokeXpResult = calculateXpAndLevel(&#10;        currentXp: pokeXp,&#10;        currentLevel: pokeLevel,&#10;        xpChange: gainedXp,&#10;        scaler: 1.1,&#10;        base: 100,&#10;      );&#10;      if (pokeXpResult.levelsGained &gt; 0) {&#10;        var tempPoke = Pokemon_mcts(&#10;          pokemonName: pokeRes['pokemon_name'],&#10;          nickname: pokeRes['nickname'],&#10;          type: pokeRes['type'],&#10;          level: pokeLevel,&#10;          attack: pokeRes['attack'],&#10;          maxHealth: pokeRes['health'],&#10;          abilities: [],&#10;        );&#10;        for (int lvl = 0; lvl &lt; pokeXpResult.levelsGained; lvl++) {&#10;          tempPoke = tempPoke.levelUp();&#10;        }&#10;        String pokeName = pokeRes['nickname'] ?? pokeRes['pokemon_name'] ?? 'PokÃ©mon';&#10;        pokemonLevelUps.add('$pokeName (Lv${pokeLevel} â ${pokeXpResult.newLevel})');&#10;        await supabase&#10;          .from('pokemon_table')&#10;          .update({&#10;            'experience_points': pokeXpResult.newXp,&#10;            'level': pokeXpResult.newLevel,&#10;            'health': tempPoke.maxHealth,&#10;            'attack': tempPoke.attack,&#10;          })&#10;          .eq('pokemon_id', pokeId);&#10;      } else {&#10;        await supabase&#10;          .from('pokemon_table')&#10;          .update({&#10;            'experience_points': pokeXpResult.newXp,&#10;            'level': pokeXpResult.newLevel,&#10;          })&#10;          .eq('pokemon_id', pokeId);&#10;      }&#10;      // Always fetch the latest ability IDs after level up&#10;      if (pokeXpResult.levelsGained &gt; 0 &amp;&amp; pokeXpResult.newLevel % 5 == 0) {&#10;        final updatedPokeRes = await supabase&#10;          .from('pokemon_table')&#10;          .select()&#10;          .eq('pokemon_id', pokeId)&#10;          .maybeSingle();&#10;        List&lt;String&gt; currentAbilityIds = [];&#10;        if (updatedPokeRes != null) {&#10;          for (int j = 1; j &lt;= 4; j++) {&#10;            final abId = updatedPokeRes['ability$j'];&#10;            if (abId != null) {&#10;              currentAbilityIds.add(abId.toString());&#10;            }&#10;          }&#10;        }&#10;        final newAbility = await fetchRandomAbilityExcluding(currentAbilityIds);&#10;        if (newAbility != null &amp;&amp; mounted) {&#10;          abilityDialogs.add(Future(() async {&#10;            await Future.delayed(const Duration(seconds: 2));&#10;            await offerAbilityDialog(&#10;              context: context,&#10;              ability: newAbility,&#10;              pokeId: pokeId,&#10;              currentAbilityIds: currentAbilityIds,&#10;            );&#10;          }));&#10;        }&#10;      }&#10;    }&#10;    // --- Favorite PokÃ©mon XP logic ---&#10;    final favoritePokeId = trainerRes['favorite_pokemon'];&#10;    if (favoritePokeId != null) {&#10;      int totalXpChange = slotPokeIds.contains(favoritePokeId.toString()) ? gainedXp * 2 : gainedXp;&#10;      final pokeRes = await supabase&#10;        .from('pokemon_table')&#10;        .select()&#10;        .eq('pokemon_id', favoritePokeId)&#10;        .maybeSingle();&#10;      if (pokeRes != null) {&#10;        int pokeXp = pokeRes['experience_points'] ?? 0;&#10;        int pokeLevel = pokeRes['level'] ?? 1;&#10;        final pokeXpResult = calculateXpAndLevel(&#10;          currentXp: pokeXp,&#10;          currentLevel: pokeLevel,&#10;          xpChange: totalXpChange,&#10;          scaler: 1.1,&#10;          base: 100,&#10;        );&#10;        await supabase&#10;          .from('pokemon_table')&#10;          .update({&#10;            'experience_points': pokeXpResult.newXp,&#10;            'level': pokeXpResult.newLevel,&#10;          })&#10;          .eq('pokemon_id', favoritePokeId);&#10;      }&#10;    }&#10;    String msg = '';&#10;    if (trainerLeveledUp) {&#10;      msg += 'Trainer ${playerName ?? 'You'} leveled up!\n';&#10;      // Add a random PokÃ©mon to the trainer's team and show dialog&#10;      final newPokeId = await addRandomPokemonToTrainer(widget.trainerId);&#10;      if (newPokeId != null) {&#10;        final pokeRes = await supabase&#10;          .from('pokemon_table')&#10;          .select()&#10;          .eq('pokemon_id', newPokeId)&#10;          .maybeSingle();&#10;        if (pokeRes != null &amp;&amp; mounted) {&#10;          await showNewPokemonDialog(context, pokeRes['pokemon_name'], pokeRes['type']);&#10;        }&#10;      }&#10;    }&#10;    if (pokemonLevelUps.isNotEmpty) {&#10;      msg += 'PokÃ©mon leveled up: ${pokemonLevelUps.join(&quot;, &quot;)}!';&#10;    }&#10;    if (!mounted) return;&#10;    setState(() {&#10;      narration = &quot;${winnerTrainerName ?? 'Trainer'} wins!\n&quot; + msg;&#10;    });&#10;    if (pokemonLevelUps.isNotEmpty &amp;&amp; mounted) {&#10;      await showDialog(&#10;        context: context,&#10;        builder: (context) =&gt; AlertDialog(&#10;          title: const Text('PokÃ©mon Leveled Up!'),&#10;          content: Text(pokemonLevelUps.join('\n')),&#10;          actions: [&#10;            TextButton(&#10;              onPressed: () =&gt; Navigator.of(context).pop(),&#10;              child: const Text('OK'),&#10;            ),&#10;          ],&#10;        ),&#10;      );&#10;    }&#10;    // Show ability dialogs (sequentially)&#10;    for (final dialog in abilityDialogs) {&#10;      await dialog;&#10;    }&#10;    await Future.delayed(const Duration(seconds: 2));&#10;    if (!mounted) return;&#10;    if (Navigator.canPop(context)) {&#10;      Navigator.of(context).pop('refresh');&#10;    }&#10;  }&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    if (isLoading || controller == null) {&#10;      return Scaffold(&#10;        appBar: AppBar(title: const Text(&quot;PokÃ©mon Battle&quot;)),&#10;        body: Center(child: narration.isNotEmpty ? Text(narration, style: TextStyle(fontSize: 18, color: Colors.red)) : const CircularProgressIndicator()),&#10;      );&#10;    }&#10;    final activePlayer = controller!.state.getActive(true);&#10;    final activeOpponent = controller!.state.getActive(false);&#10;    if (controller!.isBattleOver) {&#10;      _handleBattleEnd();&#10;    }&#10;    return Scaffold(&#10;      appBar: AppBar(title: const Text(&quot;PokÃ©mon Battle&quot;)),&#10;      backgroundColor: Colors.redAccent,&#10;      body: Container(&#10;        decoration: const BoxDecoration(&#10;          color: Colors.redAccent,&#10;        ),&#10;        child: controller!.isBattleOver&#10;            ? Center(&#10;                child: Text(&#10;                  // Show winnerTrainerName instead of &quot;You win!&quot;&#10;                  controller!.getWinner() == 1&#10;                      ? &quot;${winnerTrainerName ?? 'Trainer'} wins!&quot;&#10;                      : controller!.getWinner() == -1&#10;                          ? &quot;You lose!&quot;&#10;                          : &quot;Draw&quot;,&#10;                  style: const TextStyle(fontSize: 24),&#10;                ),&#10;              )&#10;            : Padding(&#10;                padding: const EdgeInsets.all(12.0),&#10;                child: SingleChildScrollView(&#10;                  child: Column(&#10;                    children: [&#10;                      Container(&#10;                        decoration: BoxDecoration(&#10;                          image: DecorationImage(&#10;                            image: AssetImage('assets/background/' + selectedArena + '-battle-background.jpg'),&#10;                            fit: BoxFit.cover,&#10;                          ),&#10;                          borderRadius: BorderRadius.circular(12),&#10;                        ),&#10;                        child: Column(&#10;                          children: [&#10;                            Container(&#10;                              child: Column(&#10;                                  children: [&#10;                                  Stack(&#10;                                    children:[&#10;                                      _buildPokemonCard(activeOpponent, isOpponent: true),&#10;                                      Row(&#10;                                        mainAxisAlignment: MainAxisAlignment.end,&#10;                                        children: [&#10;                                          IconButton(&#10;                                            icon: Icon(isMusicPlaying ? Icons.music_note : Icons.music_off),&#10;                                            tooltip: isMusicPlaying ? 'Pause Music' : 'Play Music',&#10;                                            onPressed: toggleMusic,&#10;                                          ),&#10;                                        ],&#10;                                      ),&#10;                                    ]&#10;                                  ),&#10;                                  // OPPONENT STATS&#10;&#10;                                  const SizedBox(height: 16),&#10;&#10;                                  // BATTLE ARENA&#10;                                  Stack(&#10;                                    children: [&#10;                                      SizedBox(&#10;                                        height: 140, // Set a fixed height for the battle arena&#10;                                        child: Center(&#10;                                          child: Column(&#10;                                            children: [&#10;                                              if (lastAiAction != null &amp;&amp; lastAiAction!.startsWith(&quot;switch_&quot;))&#10;                                                Text(&#10;                                                  &quot;AI switched to &quot;+activeOpponent.nickname+&quot;!&quot;,&#10;                                                  style: const TextStyle(&#10;                                                    color: Colors.deepOrange,&#10;                                                    fontWeight: FontWeight.bold,&#10;                                                  ),&#10;                                                ),&#10;                                              const SizedBox(height: 8),&#10;                                              Row( //  FIGHTING SCREEN&#10;                                                mainAxisAlignment: MainAxisAlignment.spaceAround,&#10;                                                children: [&#10;                                                  Flexible(&#10;                                                    fit: FlexFit.loose,&#10;                                                    child: FittedBox(&#10;                                                      fit: BoxFit.scaleDown,&#10;                                                      child: _buildAnimatedSprite(activePlayer, shake: opponentJustAttacked),&#10;                                                    ),&#10;                                                  ),&#10;                                                  Flexible(&#10;                                                    fit: FlexFit.loose,&#10;                                                    child: FittedBox(&#10;                                                      fit: BoxFit.scaleDown,&#10;                                                      child: _buildAnimatedSprite(activeOpponent, shake: playerJustAttacked),&#10;                                                    ),&#10;                                                  ),&#10;                                                ],&#10;                                              ),&#10;                                            ],&#10;                                          ),&#10;                                        ),&#10;                                      ),&#10;                                      if (isAnimating)&#10;                                        Padding(&#10;                                          padding: const EdgeInsets.symmetric(vertical: 8.0),&#10;                                          child: Container(&#10;                                            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),&#10;                                            decoration: BoxDecoration(&#10;                                              color: Colors.black.withOpacity(0.6),&#10;                                              borderRadius: BorderRadius.circular(10),&#10;                                            ),&#10;                                            child: Row(&#10;                                              mainAxisSize: MainAxisSize.min,&#10;                                              mainAxisAlignment: MainAxisAlignment.center,&#10;                                              children: const [&#10;                                                SizedBox(&#10;                                                  width: 20,&#10;                                                  height: 20,&#10;                                                  child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white),&#10;                                                ),&#10;                                                SizedBox(width: 12),&#10;                                                Text(&#10;                                                  &quot;AI is thinking...&quot;,&#10;                                                  style: TextStyle(color: Colors.white),&#10;                                                ),&#10;                                              ],&#10;                                            ),&#10;                                          ),&#10;                                        ),&#10;                                    ]&#10;                                  ),&#10;                                  // PLAYER STATS&#10;                                  _buildPokemonCard(activePlayer, isOpponent: false),&#10;&#10;                                ]&#10;                              )&#10;                            ), // battle space&#10;                          ],&#10;                        ),&#10;                      ),&#10;                      Container(&#10;                        color: Colors.redAccent,&#10;                        child: Column(&#10;                          children: [&#10;                            //MOVES AND OTHER STUFF&#10;                            const SizedBox(height: 8),&#10;&#10;                            const SizedBox(height: 8),&#10;                            Padding(&#10;                              padding: const EdgeInsets.symmetric(horizontal: 12.0),&#10;                              // NARRATION&#10;                              child: Container(&#10;                                width: double.infinity,&#10;                                padding: const EdgeInsets.all(12),&#10;                                decoration: BoxDecoration(&#10;                                  color: Colors.cyanAccent,&#10;                                  borderRadius: BorderRadius.circular(8),&#10;                                  border: Border.all(color: Colors.black54, width: 2),&#10;                                ),&#10;                                child: AnimatedTextKit(&#10;                                  key: ValueKey(narration), // ensures animation restarts on narration change&#10;                                  animatedTexts: [&#10;                                    TyperAnimatedText(&#10;                                      narration,&#10;                                      textStyle: const TextStyle(color: Colors.black54, fontSize: 16),&#10;                                      speed: const Duration(milliseconds: 35),&#10;                                    ),&#10;                                  ],&#10;                                  totalRepeatCount: 1,&#10;                                  pause: Duration.zero,&#10;                                  displayFullTextOnTap: true,&#10;                                  stopPauseOnTap: true,&#10;                                ),&#10;                              ),&#10;                            ),&#10;                            const SizedBox(height: 18),&#10;                            // ACTIONS&#10;                            Column(&#10;                              crossAxisAlignment: CrossAxisAlignment.stretch,&#10;                              children: [&#10;                                ExpansionTile(&#10;                                  title: const Text(&quot;Moves&quot;, style: TextStyle(fontWeight: FontWeight.bold)),&#10;                                  initiallyExpanded: movesExpanded,&#10;                                  children: [&#10;                                    Container(&#10;                                      margin: const EdgeInsets.only(bottom: 8),&#10;                                      padding: const EdgeInsets.all(8),&#10;                                      decoration: BoxDecoration(&#10;                                        border: Border.all(color: Colors.black26, width: 1),&#10;                                        borderRadius: BorderRadius.circular(8),&#10;                                      ),&#10;                                      child: Wrap(&#10;                                        spacing: 8,&#10;                                        runSpacing: 8,&#10;                                        children: controller!.getValidActions().where((action) =&gt; action.startsWith(&quot;move_&quot;)).map((action) {&#10;                                          final label = _getActionLabel(action);&#10;                                          String usesInfo = &quot;&quot;;&#10;                                          final player = controller!.state.getActive(true);&#10;                                          final index = int.tryParse(action.split(&quot;_&quot;)[1]) ?? 0;&#10;                                          if (index &gt;= 0 &amp;&amp; index &lt; player.abilities.length) {&#10;                                            final ability = player.abilities[index];&#10;                                            usesInfo = &quot; (${ability.remainingUses}/${ability.maxUses})&quot;;&#10;                                          }&#10;                                          return ElevatedButton(&#10;                                            onPressed: () =&gt; onPlayerAction(action),&#10;                                            child: Text(label + usesInfo),&#10;                                          );&#10;                                        }).toList(),&#10;                                      ),&#10;                                    ),&#10;                                  ],&#10;                                ),&#10;                                ExpansionTile(&#10;                                  title: const Text(&quot;Switch&quot;, style: TextStyle(fontWeight: FontWeight.bold)),&#10;                                  children: [&#10;                                    Container(&#10;                                      padding: const EdgeInsets.all(8),&#10;                                      decoration: BoxDecoration(&#10;                                        border: Border.all(color: Colors.black26, width: 1),&#10;                                        borderRadius: BorderRadius.circular(8),&#10;                                      ),&#10;                                      child: GridView.count(&#10;                                        crossAxisCount: 2,&#10;                                        shrinkWrap: true,&#10;                                        physics: const NeverScrollableScrollPhysics(),&#10;                                        childAspectRatio: 2.8,&#10;                                        mainAxisSpacing: 8,&#10;                                        crossAxisSpacing: 8,&#10;                                        children: controller!.getValidActions().where((action) =&gt; action.startsWith(&quot;switch_&quot;)).map((action) {&#10;                                          final label = _getActionLabel(action);&#10;                                          final team = controller!.state.playerTeam;&#10;                                          final index = int.tryParse(action.split(&quot;_&quot;)[1]) ?? 0;&#10;                                          String hpInfo = &quot;&quot;;&#10;                                          if (index &gt;= 0 &amp;&amp; index &lt; team.length) {&#10;                                            final poke = team[index];&#10;                                            hpInfo = &quot;  HP: ${poke.currentHealth}/${poke.maxHealth}&quot;;&#10;                                          }&#10;                                          return ElevatedButton(&#10;                                            onPressed: () =&gt; onPlayerAction(action),&#10;                                            child: Text(label + hpInfo),&#10;                                          );&#10;                                        }).toList(),&#10;                                      ),&#10;                                    ),&#10;                                  ],&#10;                                ),&#10;                              ],&#10;                            ),&#10;&#10;&#10;                            const SizedBox(height: 16),&#10;                          ]&#10;                        )&#10;                      ),&#10;                    ],&#10;                  ),&#10;                ),&#10;              ),&#10;            ),&#10;    );&#10;  }&#10;  String _getActionLabel(String action) {&#10;    final player = controller!.state.getActive(true);&#10;    final team = controller!.state.playerTeam;&#10;&#10;    if (action.startsWith(&quot;move_&quot;)) {&#10;      final index = int.tryParse(action.split(&quot;_&quot;)[1]) ?? 0;&#10;      if (index &gt;= 0 &amp;&amp; index &lt; player.abilities.length) {&#10;        return player.abilities[index].name;&#10;      } else {&#10;        return &quot;Unknown Move&quot;;&#10;      }&#10;    } else if (action.startsWith(&quot;switch_&quot;)) {&#10;      final index = int.tryParse(action.split(&quot;_&quot;)[1]) ?? 0;&#10;      if (index &gt;= 0 &amp;&amp; index &lt; team.length) {&#10;        return team[index].nickname;&#10;      } else {&#10;        return &quot;Unknown Switch&quot;;&#10;      }&#10;    }&#10;&#10;    return action;&#10;  }&#10;&#10;&#10;  Widget _buildPokemonCard(Pokemon_mcts p, {required bool isOpponent}) {&#10;    return Card(&#10;      elevation: 2,&#10;      color: p.isFainted ? Colors.grey[200] : (isOpponent ? Colors.red[100] : Colors.blue[100]),&#10;      child: Padding(&#10;        padding: const EdgeInsets.all(12.0),&#10;        child: Column(&#10;          crossAxisAlignment: CrossAxisAlignment.start,&#10;          children: [&#10;            Text(&quot;${p.nickname} (${p.pokemonName})&quot;,&#10;                style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),&#10;            const SizedBox(height: 4),&#10;            Row(&#10;              children: [&#10;                Text(&quot;HP: ${p.currentHealth}/${p.maxHealth}&quot;),&#10;                const SizedBox(width: 16),&#10;                Text(&quot;Type: ${p.type}&quot;),&#10;              ],&#10;            ),&#10;            const SizedBox(height: 4),&#10;            AnimatedHPBar(current: p.currentHealth, max: p.maxHealth),&#10;          ],&#10;        ),&#10;      ),&#10;      );&#10;  }&#10;&#10;  Widget _buildAnimatedSprite(Pokemon_mcts p, {bool shake = false}) {&#10;    final spritePath = 'assets/sprites/${p.pokemonName.toLowerCase()}.png';&#10;&#10;    return TweenAnimationBuilder&lt;Offset&gt;(&#10;      key: ValueKey(p.nickname + p.currentHealth.toString()),&#10;      tween: Tween&lt;Offset&gt;(&#10;        begin: Offset.zero,&#10;        end: shake ? const Offset(0.05, 0) : Offset.zero,&#10;      ),&#10;      duration: const Duration(milliseconds: 150),&#10;      curve: Curves.elasticIn,&#10;      builder: (context, value, _) {&#10;        return Transform.translate(&#10;          offset: Offset(value.dx * 10, 0),&#10;          child: Stack(&#10;            children: [&#10;              Image.asset(&#10;                spritePath,&#10;                width: 96,&#10;                height: 96,&#10;                errorBuilder: (context, error, stack) =&gt; const Icon(Icons.error),&#10;              ),&#10;              if (shake)&#10;                Positioned.fill(&#10;                  child: ColoredBox(&#10;                    color: Colors.white.withOpacity(0.5),&#10;                  ),&#10;                ),&#10;            ],&#10;          ),&#10;        );&#10;      },&#10;    );&#10;  }&#10;&#10;&#10;  String getAbilityName(String action, bool isPlayer) {&#10;    if (!action.startsWith(&quot;move_&quot;)) return &quot;&quot;;&#10;    final index = int.parse(action.split(&quot;_&quot;)[1]);&#10;    final p = controller!.state.getActive(isPlayer);&#10;    return p.abilities[index].name;&#10;  }&#10;&#10;&#10;  Future&lt;void&gt; playTurnAnimationSequence(String playerAction) async {&#10;    setState(() {&#10;      playerJustAttacked = playerAction.startsWith(&quot;move_&quot;);&#10;      opponentJustAttacked = false;&#10;      narration = &quot;You used ${getAbilityName(playerAction, true)}!&quot;;&#10;      isAnimating = true;&#10;    });&#10;&#10;    // Pause to show player attack + shake&#10;    await Future.delayed(const Duration(milliseconds: 500));&#10;&#10;    setState(() {&#10;      controller!.applyPlayerAction(playerAction);&#10;      // After controller.applyPlayerAction(playerAction);&#10;      final effectiveness = controller!.lastEffectiveness;&#10;      final feedback = getEffectivenessText(effectiveness);&#10;&#10;      setState(() {&#10;        narration += &quot;\n$feedback&quot;;&#10;      });&#10;&#10;    });&#10;&#10;    if (!controller!.isBattleOver) {&#10;      final aiAction = runMCTS(controller!.state, 100);&#10;      final isSwitch = aiAction.startsWith(&quot;switch_&quot;);&#10;      final aiUsed = isSwitch&#10;          ? &quot;AI switched to ${controller!.state.getActive(false).nickname}!&quot;&#10;          : &quot;Enemy used ${getAbilityName(aiAction, false)}!&quot;;&#10;&#10;      await Future.delayed(const Duration(milliseconds: 300));&#10;&#10;      setState(() {&#10;        narration = aiUsed;&#10;        opponentJustAttacked = !isSwitch;&#10;      });&#10;&#10;      await Future.delayed(const Duration(milliseconds: 500));&#10;&#10;      setState(() {&#10;        controller!.state.applyAction(aiAction);&#10;        isAnimating = false;&#10;      });&#10;    } else {&#10;      setState(() {&#10;        isAnimating = false;&#10;      });&#10;    }&#10;  }&#10;&#10;  void playBattleMusic() {&#10;    MusicService().playMusic('music/battle_music.mp3');&#10;  }&#10;&#10;  void toggleMusic() {&#10;    setState(() {&#10;      isMusicPlaying = !isMusicPlaying;&#10;      if (isMusicPlaying) {&#10;        MusicService().playMusic('music/battle_music.mp3');&#10;      } else {&#10;        MusicService().stopMusic();&#10;      }&#10;    });&#10;  }&#10;&#10;  void onPlayerAction(String action) {&#10;    playTurnAnimationSequence(action);&#10;  }&#10;&#10;&#10;  @override&#10;  void dispose() {&#10;    // Stop battle music and resume menu music when leaving the page&#10;    MusicService().stopMusic(); // Stop battle music&#10;    MusicService().playMusic('music/menu_music.mp3'); // Resume menu music&#10;    super.dispose();&#10;  }&#10;}&#10;class AnimatedHPBar extends StatelessWidget {&#10;  final int current;&#10;  final int max;&#10;&#10;  const AnimatedHPBar({super.key, required this.current, required this.max});&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    final ratio = current / max;&#10;    final color = ratio &gt; 0.5&#10;        ? Colors.green&#10;        : ratio &gt; 0.2&#10;        ? Colors.orange&#10;        : Colors.red;&#10;&#10;    return TweenAnimationBuilder&lt;double&gt;(&#10;      tween: Tween&lt;double&gt;(begin: 0, end: ratio),&#10;      duration: const Duration(milliseconds: 500),&#10;      builder: (context, value, _) {&#10;        return SizedBox(&#10;          width: 170, // or MediaQuery.of(context).size.width * 0.4 for responsive&#10;          child: ClipRRect(&#10;            borderRadius: BorderRadius.circular(6),&#10;            child: LinearProgressIndicator(&#10;              value: value,&#10;              backgroundColor: Colors.grey[300],&#10;              color: color,&#10;              minHeight: 12,&#10;            ),&#10;          ),&#10;        );&#10;      },&#10;    );&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import 'package:flutter/material.dart';&#10;import '../mcts/pokebattle_controller.dart';&#10;import '../models/battle_game_state.dart';&#10;import '../models/pokemon_mcts.dart';&#10;import '../models/ability_mcts.dart';&#10;import '../mcts/mcts_search.dart'; // For direct MCTS call&#10;import 'package:animated_text_kit/animated_text_kit.dart';&#10;import '../services/music_service.dart';&#10;import '../services/xp_utils.dart';&#10;import '../services/ability_utils.dart';&#10;import 'package:supabase_flutter/supabase_flutter.dart';&#10;&#10;&#10;class PokeBattlePage extends StatefulWidget {&#10;  final String trainerId;&#10;  const PokeBattlePage({super.key, required this.trainerId});&#10;&#10;  @override&#10;  State&lt;PokeBattlePage&gt; createState() =&gt; _PokeBattlePageState();&#10;}&#10;&#10;class _PokeBattlePageState extends State&lt;PokeBattlePage&gt; {&#10;  late PokeBattleController? controller;&#10;  String? lastAiAction;&#10;  bool playerJustAttacked = false;&#10;  bool opponentJustAttacked = false;&#10;&#10;  String narration = &quot;&quot;;&#10;  bool isAnimating = false;&#10;&#10;  bool isMusicPlaying = true;&#10;&#10;  String selectedArena = &quot;&quot;;&#10;  String selectedArenaText = &quot;&quot;;&#10;  final List&lt;String&gt; arenaTypes = [&#10;    'desert', 'water', 'snow', 'hills', 'cave', 'beach', 'grass'&#10;  ];&#10;&#10;  final bool movesExpanded = true;&#10;&#10;  bool isLoading = true;&#10;&#10;  String? winnerTrainerName;&#10;&#10;  bool hasHandledBattleEnd = false;&#10;&#10;  String? playerTrainerName;&#10;  String? opponentTrainerName;&#10;  String? playerName;&#10;  String? opponentName;&#10;&#10;  @override&#10;  void initState() {&#10;    super.initState();&#10;    // Stop menu music before starting battle music&#10;    MusicService().stopMusic();&#10;    playBattleMusic();&#10;    isMusicPlaying = true;&#10;    controller = null;&#10;    _initTeams();&#10;  }&#10;&#10;  Future&lt;void&gt; _initTeams() async {&#10;    setState(() { isLoading = true; });&#10;    final supabase = Supabase.instance.client;&#10;    // Fetch player trainer row&#10;    final trainerRes = await supabase&#10;      .from('trainer_table')&#10;      .select()&#10;      .eq('trainer_id', widget.trainerId)&#10;      .maybeSingle(); // safer than .single()&#10;    if (trainerRes == null) {&#10;      setState(() { narration = &quot;Trainer not found.&quot;; isLoading = false; });&#10;      return;&#10;    }&#10;    playerTrainerName = trainerRes['username'] ?? 'You';&#10;    playerName = playerTrainerName;&#10;    // Get player team&#10;    final playerTeam = await _fetchTeamFromTrainerRow(trainerRes);&#10;    if (playerTeam.isEmpty) {&#10;      setState(() {&#10;        narration = &quot;You have no PokÃ©mon in your team. Please add PokÃ©mon before battling.&quot;;&#10;        isLoading = false;&#10;      });&#10;      return;&#10;    }&#10;    // Get random opponent trainer&#10;    final trainers = await supabase&#10;      .from('trainer_table')&#10;      .select('trainer_id,username');&#10;    final opponentIds = trainers.where((t) =&gt; t['trainer_id'] != widget.trainerId).toList();&#10;    opponentIds.shuffle();&#10;    final opponentId = opponentIds.isNotEmpty ? opponentIds.first['trainer_id'] : widget.trainerId;&#10;    final opponentRes = await supabase&#10;      .from('trainer_table')&#10;      .select()&#10;      .eq('trainer_id', opponentId)&#10;      .maybeSingle(); // safer than .single()&#10;    opponentTrainerName = opponentRes?['username'] ?? 'Opponent';&#10;    opponentName = opponentTrainerName;&#10;    final opponentTeam = await _fetchTeamFromTrainerRow(opponentRes ?? {});&#10;    if (opponentTeam.isEmpty) {&#10;      setState(() {&#10;        narration = &quot;Opponent has no PokÃ©mon. Try again later.&quot;;&#10;        isLoading = false;&#10;      });&#10;      return;&#10;    }&#10;    // Setup battle state&#10;    final state = BattleGameState(&#10;      playerTeam: playerTeam,&#10;      opponentTeam: opponentTeam,&#10;    );&#10;    setState(() {&#10;      controller = PokeBattleController(gameState: state);&#10;      // Randomly select an arena type&#10;      final rand = arenaTypes..shuffle();&#10;      selectedArena = rand.first;&#10;      selectedArenaText = selectedArena[0].toUpperCase() + selectedArena.substring(1);&#10;      isLoading = false;&#10;    });&#10;  }&#10;&#10;  Future&lt;List&lt;Pokemon_mcts&gt;&gt; _fetchTeamFromTrainerRow(Map trainerRow) async {&#10;    final supabase = Supabase.instance.client;&#10;    List&lt;Pokemon_mcts&gt; team = [];&#10;    for (int i = 1; i &lt;= 6; i++) {&#10;      final slotKey = 'pokemon_slot_$i';&#10;      final pokeId = trainerRow[slotKey];&#10;      if (pokeId == null) continue;&#10;      final pokeRes = await supabase&#10;        .from('pokemon_table')&#10;        .select()&#10;        .eq('pokemon_id', pokeId)&#10;        .maybeSingle(); // safer than .single()&#10;      if (pokeRes == null) continue;&#10;      // Fetch abilities&#10;      List&lt;Ability_mcts&gt; abilities = [];&#10;      for (int j = 1; j &lt;= 4; j++) {&#10;        final abKey = 'ability$j';&#10;        final abId = pokeRes[abKey];&#10;        if (abId == null) continue;&#10;        final abRes = await supabase&#10;          .from('abilities_table')&#10;          .select()&#10;          .eq('ability_id', abId)&#10;          .maybeSingle(); // safer than .single()&#10;        if (abRes == null) continue;&#10;        abilities.add(Ability_mcts(&#10;          name: abRes['ability_name'],&#10;          type: abRes['type'],&#10;          maxUses: abRes['uses'],&#10;          hitRate: abRes['hitrate'],&#10;          value: abRes['value'],&#10;        ));&#10;      }&#10;      team.add(Pokemon_mcts(&#10;        pokemonName: pokeRes['pokemon_name'],&#10;        nickname: pokeRes['nickname'],&#10;        type: pokeRes['type'],&#10;        level: pokeRes['level'],&#10;        attack: pokeRes['attack'],&#10;        maxHealth: pokeRes['health'],&#10;        abilities: abilities,&#10;      ));&#10;    }&#10;    return team;&#10;  }&#10;&#10;  String getEffectivenessText(double multiplier) {&#10;    if (multiplier &gt;= 2.0) return &quot;It's super effective!&quot;;&#10;    if (multiplier &gt;= 1.1) return &quot;It's effective!&quot;;&#10;    if (multiplier &lt;= 0.5) return &quot;It's not very effective...&quot;;&#10;    return &quot;&quot;;&#10;  }&#10;&#10;&#10;&#10;  Future&lt;void&gt; _handleBattleEnd() async {&#10;    if (hasHandledBattleEnd) return;&#10;    hasHandledBattleEnd = true;&#10;    final supabase = Supabase.instance.client;&#10;    final isWin = controller!.getWinner() == 1;&#10;    final isLoss = controller!.getWinner() == -1;&#10;    if (!isWin &amp;&amp; !isLoss) return;&#10;    final trainerRes = await supabase&#10;      .from('trainer_table')&#10;      .select()&#10;      .eq('trainer_id', widget.trainerId)&#10;      .maybeSingle();&#10;    if (trainerRes == null) return;&#10;    // Always set username before using it&#10;    playerTrainerName = trainerRes['username'] ?? 'You';&#10;    playerName = playerTrainerName;&#10;    winnerTrainerName = isWin ? (playerName ?? 'You') : (opponentName ?? 'Opponent');&#10;    int wins = trainerRes['wins'] ?? 0;&#10;    int losses = trainerRes['losses'] ?? 0;&#10;    int xp = trainerRes['experience_points'] ?? 0;&#10;    int level = trainerRes['level'] ?? 1;&#10;    int gainedXp = isWin ? 250 : 100;&#10;    // Use battle context scaler (1.1) and base (100)&#10;    final trainerXpResult = calculateXpAndLevel(&#10;      currentXp: xp,&#10;      currentLevel: level,&#10;      xpChange: gainedXp,&#10;      scaler: 1.1,&#10;      base: 100,&#10;    );&#10;    xp = trainerXpResult.newXp;&#10;    level = trainerXpResult.newLevel;&#10;    bool trainerLeveledUp = trainerXpResult.levelsGained &gt; 0;&#10;    if (isWin) wins += 1;&#10;    if (isLoss) losses += 1;&#10;    await supabase&#10;      .from('trainer_table')&#10;      .update({&#10;        'wins': wins,&#10;        'losses': losses,&#10;        'experience_points': xp,&#10;        'level': level,&#10;      })&#10;      .eq('trainer_id', widget.trainerId);&#10;    List&lt;String&gt; pokemonLevelUps = [];&#10;    List&lt;Future&lt;void&gt;&gt; abilityDialogs = [];&#10;    Set&lt;String&gt; slotPokeIds = {};&#10;    for (int i = 1; i &lt;= 6; i++) {&#10;      final slotKey = 'pokemon_slot_$i';&#10;      final pokeId = trainerRes[slotKey];&#10;      if (pokeId == null) continue;&#10;      slotPokeIds.add(pokeId.toString());&#10;      final pokeRes = await supabase&#10;        .from('pokemon_table')&#10;        .select()&#10;        .eq('pokemon_id', pokeId)&#10;        .maybeSingle();&#10;      if (pokeRes == null) continue;&#10;      int pokeXp = pokeRes['experience_points'] ?? 0;&#10;      int pokeLevel = pokeRes['level'] ?? 1;&#10;      final pokeXpResult = calculateXpAndLevel(&#10;        currentXp: pokeXp,&#10;        currentLevel: pokeLevel,&#10;        xpChange: gainedXp,&#10;        scaler: 1.1,&#10;        base: 100,&#10;      );&#10;      if (pokeXpResult.levelsGained &gt; 0) {&#10;        var tempPoke = Pokemon_mcts(&#10;          pokemonName: pokeRes['pokemon_name'],&#10;          nickname: pokeRes['nickname'],&#10;          type: pokeRes['type'],&#10;          level: pokeLevel,&#10;          attack: pokeRes['attack'],&#10;          maxHealth: pokeRes['health'],&#10;          abilities: [],&#10;        );&#10;        for (int lvl = 0; lvl &lt; pokeXpResult.levelsGained; lvl++) {&#10;          tempPoke = tempPoke.levelUp();&#10;        }&#10;        String pokeName = pokeRes['nickname'] ?? pokeRes['pokemon_name'] ?? 'PokÃ©mon';&#10;        pokemonLevelUps.add('$pokeName (Lv${pokeLevel} â ${pokeXpResult.newLevel})');&#10;        await supabase&#10;          .from('pokemon_table')&#10;          .update({&#10;            'experience_points': pokeXpResult.newXp,&#10;            'level': pokeXpResult.newLevel,&#10;            'health': tempPoke.maxHealth,&#10;            'attack': tempPoke.attack,&#10;          })&#10;          .eq('pokemon_id', pokeId);&#10;      } else {&#10;        await supabase&#10;          .from('pokemon_table')&#10;          .update({&#10;            'experience_points': pokeXpResult.newXp,&#10;            'level': pokeXpResult.newLevel,&#10;          })&#10;          .eq('pokemon_id', pokeId);&#10;      }&#10;      // Always fetch the latest ability IDs after level up&#10;      if (pokeXpResult.levelsGained &gt; 0 &amp;&amp; pokeXpResult.newLevel % 5 == 0) {&#10;        final updatedPokeRes = await supabase&#10;          .from('pokemon_table')&#10;          .select()&#10;          .eq('pokemon_id', pokeId)&#10;          .maybeSingle();&#10;        List&lt;String&gt; currentAbilityIds = [];&#10;        if (updatedPokeRes != null) {&#10;          for (int j = 1; j &lt;= 4; j++) {&#10;            final abId = updatedPokeRes['ability$j'];&#10;            if (abId != null) {&#10;              currentAbilityIds.add(abId.toString());&#10;            }&#10;          }&#10;        }&#10;        final newAbility = await fetchRandomAbilityExcluding(currentAbilityIds);&#10;        if (newAbility != null &amp;&amp; mounted) {&#10;          // Show ability dialog and wait for user action before continuing&#10;          await offerAbilityDialog(&#10;            context: context,&#10;            ability: newAbility,&#10;            pokeId: pokeId,&#10;            currentAbilityIds: currentAbilityIds,&#10;          );&#10;        }&#10;      }&#10;    }&#10;    // --- Favorite PokÃ©mon XP logic ---&#10;    final favoritePokeId = trainerRes['favorite_pokemon'];&#10;    if (favoritePokeId != null) {&#10;      int totalXpChange = slotPokeIds.contains(favoritePokeId.toString()) ? gainedXp * 2 : gainedXp;&#10;      final pokeRes = await supabase&#10;        .from('pokemon_table')&#10;        .select()&#10;        .eq('pokemon_id', favoritePokeId)&#10;        .maybeSingle();&#10;      if (pokeRes != null) {&#10;        int pokeXp = pokeRes['experience_points'] ?? 0;&#10;        int pokeLevel = pokeRes['level'] ?? 1;&#10;        final pokeXpResult = calculateXpAndLevel(&#10;          currentXp: pokeXp,&#10;          currentLevel: pokeLevel,&#10;          xpChange: totalXpChange,&#10;          scaler: 1.1,&#10;          base: 100,&#10;        );&#10;        await supabase&#10;          .from('pokemon_table')&#10;          .update({&#10;            'experience_points': pokeXpResult.newXp,&#10;            'level': pokeXpResult.newLevel,&#10;          })&#10;          .eq('pokemon_id', favoritePokeId);&#10;      }&#10;    }&#10;    String msg = '';&#10;    if (trainerLeveledUp) {&#10;      msg += 'Trainer ${playerName ?? 'You'} leveled up!\n';&#10;      // Add a random PokÃ©mon to the trainer's team and show dialog&#10;      final newPokeId = await addRandomPokemonToTrainer(widget.trainerId);&#10;      if (newPokeId != null) {&#10;        final pokeRes = await supabase&#10;          .from('pokemon_table')&#10;          .select()&#10;          .eq('pokemon_id', newPokeId)&#10;          .maybeSingle();&#10;        if (pokeRes != null &amp;&amp; mounted) {&#10;          await showNewPokemonDialog(context, pokeRes['pokemon_name'], pokeRes['type']);&#10;        }&#10;      }&#10;    }&#10;    if (pokemonLevelUps.isNotEmpty) {&#10;      msg += 'PokÃ©mon leveled up: ${pokemonLevelUps.join(&quot;, &quot;)}!';&#10;    }&#10;    if (!mounted) return;&#10;    setState(() {&#10;      narration = &quot;${winnerTrainerName ?? 'Trainer'} wins!\n&quot; + msg;&#10;    });&#10;    if (pokemonLevelUps.isNotEmpty &amp;&amp; mounted) {&#10;      await showDialog(&#10;        context: context,&#10;        builder: (context) =&gt; AlertDialog(&#10;          title: const Text('PokÃ©mon Leveled Up!'),&#10;          content: Text(pokemonLevelUps.join('\n')),&#10;          actions: [&#10;            TextButton(&#10;              onPressed: () =&gt; Navigator.of(context).pop(),&#10;              child: const Text('OK'),&#10;            ),&#10;          ],&#10;        ),&#10;      );&#10;    }&#10;    await Future.delayed(const Duration(seconds: 2));&#10;    if (!mounted) return;&#10;    if (Navigator.canPop(context)) {&#10;      Navigator.of(context).pop('refresh');&#10;    }&#10;  }&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    if (isLoading || controller == null) {&#10;      return Scaffold(&#10;        appBar: AppBar(title: const Text(&quot;PokÃ©mon Battle&quot;)),&#10;        body: Center(child: narration.isNotEmpty ? Text(narration, style: TextStyle(fontSize: 18, color: Colors.red)) : const CircularProgressIndicator()),&#10;      );&#10;    }&#10;    final activePlayer = controller!.state.getActive(true);&#10;    final activeOpponent = controller!.state.getActive(false);&#10;    if (controller!.isBattleOver) {&#10;      _handleBattleEnd();&#10;    }&#10;    return Scaffold(&#10;      appBar: AppBar(title: const Text(&quot;PokÃ©mon Battle&quot;)),&#10;      backgroundColor: Colors.redAccent,&#10;      body: Container(&#10;        decoration: const BoxDecoration(&#10;          color: Colors.redAccent,&#10;        ),&#10;        child: controller!.isBattleOver&#10;            ? Center(&#10;                child: Text(&#10;                  // Show winnerTrainerName instead of &quot;You win!&quot;&#10;                  controller!.getWinner() == 1&#10;                      ? &quot;${winnerTrainerName ?? 'Trainer'} wins!&quot;&#10;                      : controller!.getWinner() == -1&#10;                          ? &quot;You lose!&quot;&#10;                          : &quot;Draw&quot;,&#10;                  style: const TextStyle(fontSize: 24),&#10;                ),&#10;              )&#10;            : Padding(&#10;                padding: const EdgeInsets.all(12.0),&#10;                child: SingleChildScrollView(&#10;                  child: Column(&#10;                    children: [&#10;                      Container(&#10;                        decoration: BoxDecoration(&#10;                          image: DecorationImage(&#10;                            image: AssetImage('assets/background/' + selectedArena + '-battle-background.jpg'),&#10;                            fit: BoxFit.cover,&#10;                          ),&#10;                          borderRadius: BorderRadius.circular(12),&#10;                        ),&#10;                        child: Column(&#10;                          children: [&#10;                            Container(&#10;                              child: Column(&#10;                                  children: [&#10;                                  Stack(&#10;                                    children:[&#10;                                      _buildPokemonCard(activeOpponent, isOpponent: true),&#10;                                      Row(&#10;                                        mainAxisAlignment: MainAxisAlignment.end,&#10;                                        children: [&#10;                                          IconButton(&#10;                                            icon: Icon(isMusicPlaying ? Icons.music_note : Icons.music_off),&#10;                                            tooltip: isMusicPlaying ? 'Pause Music' : 'Play Music',&#10;                                            onPressed: toggleMusic,&#10;                                          ),&#10;                                        ],&#10;                                      ),&#10;                                    ]&#10;                                  ),&#10;                                  // OPPONENT STATS&#10;&#10;                                  const SizedBox(height: 16),&#10;&#10;                                  // BATTLE ARENA&#10;                                  Stack(&#10;                                    children: [&#10;                                      SizedBox(&#10;                                        height: 140, // Set a fixed height for the battle arena&#10;                                        child: Center(&#10;                                          child: Column(&#10;                                            children: [&#10;                                              if (lastAiAction != null &amp;&amp; lastAiAction!.startsWith(&quot;switch_&quot;))&#10;                                                Text(&#10;                                                  &quot;AI switched to &quot;+activeOpponent.nickname+&quot;!&quot;,&#10;                                                  style: const TextStyle(&#10;                                                    color: Colors.deepOrange,&#10;                                                    fontWeight: FontWeight.bold,&#10;                                                  ),&#10;                                                ),&#10;                                              const SizedBox(height: 8),&#10;                                              Row( //  FIGHTING SCREEN&#10;                                                mainAxisAlignment: MainAxisAlignment.spaceAround,&#10;                                                children: [&#10;                                                  Flexible(&#10;                                                    fit: FlexFit.loose,&#10;                                                    child: FittedBox(&#10;                                                      fit: BoxFit.scaleDown,&#10;                                                      child: _buildAnimatedSprite(activePlayer, shake: opponentJustAttacked),&#10;                                                    ),&#10;                                                  ),&#10;                                                  Flexible(&#10;                                                    fit: FlexFit.loose,&#10;                                                    child: FittedBox(&#10;                                                      fit: BoxFit.scaleDown,&#10;                                                      child: _buildAnimatedSprite(activeOpponent, shake: playerJustAttacked),&#10;                                                    ),&#10;                                                  ),&#10;                                                ],&#10;                                              ),&#10;                                            ],&#10;                                          ),&#10;                                        ),&#10;                                      ),&#10;                                      if (isAnimating)&#10;                                        Padding(&#10;                                          padding: const EdgeInsets.symmetric(vertical: 8.0),&#10;                                          child: Container(&#10;                                            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),&#10;                                            decoration: BoxDecoration(&#10;                                              color: Colors.black.withOpacity(0.6),&#10;                                              borderRadius: BorderRadius.circular(10),&#10;                                            ),&#10;                                            child: Row(&#10;                                              mainAxisSize: MainAxisSize.min,&#10;                                              mainAxisAlignment: MainAxisAlignment.center,&#10;                                              children: const [&#10;                                                SizedBox(&#10;                                                  width: 20,&#10;                                                  height: 20,&#10;                                                  child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white),&#10;                                                ),&#10;                                                SizedBox(width: 12),&#10;                                                Text(&#10;                                                  &quot;AI is thinking...&quot;,&#10;                                                  style: TextStyle(color: Colors.white),&#10;                                                ),&#10;                                              ],&#10;                                            ),&#10;                                          ),&#10;                                        ),&#10;                                    ]&#10;                                  ),&#10;                                  // PLAYER STATS&#10;                                  _buildPokemonCard(activePlayer, isOpponent: false),&#10;&#10;                                ]&#10;                              )&#10;                            ), // battle space&#10;                          ],&#10;                        ),&#10;                      ),&#10;                      Container(&#10;                        color: Colors.redAccent,&#10;                        child: Column(&#10;                          children: [&#10;                            //MOVES AND OTHER STUFF&#10;                            const SizedBox(height: 8),&#10;&#10;                            const SizedBox(height: 8),&#10;                            Padding(&#10;                              padding: const EdgeInsets.symmetric(horizontal: 12.0),&#10;                              // NARRATION&#10;                              child: Container(&#10;                                width: double.infinity,&#10;                                padding: const EdgeInsets.all(12),&#10;                                decoration: BoxDecoration(&#10;                                  color: Colors.cyanAccent,&#10;                                  borderRadius: BorderRadius.circular(8),&#10;                                  border: Border.all(color: Colors.black54, width: 2),&#10;                                ),&#10;                                child: AnimatedTextKit(&#10;                                  key: ValueKey(narration), // ensures animation restarts on narration change&#10;                                  animatedTexts: [&#10;                                    TyperAnimatedText(&#10;                                      narration,&#10;                                      textStyle: const TextStyle(color: Colors.black54, fontSize: 16),&#10;                                      speed: const Duration(milliseconds: 35),&#10;                                    ),&#10;                                  ],&#10;                                  totalRepeatCount: 1,&#10;                                  pause: Duration.zero,&#10;                                  displayFullTextOnTap: true,&#10;                                  stopPauseOnTap: true,&#10;                                ),&#10;                              ),&#10;                            ),&#10;                            const SizedBox(height: 18),&#10;                            // ACTIONS&#10;                            Column(&#10;                              crossAxisAlignment: CrossAxisAlignment.stretch,&#10;                              children: [&#10;                                ExpansionTile(&#10;                                  title: const Text(&quot;Moves&quot;, style: TextStyle(fontWeight: FontWeight.bold)),&#10;                                  initiallyExpanded: movesExpanded,&#10;                                  children: [&#10;                                    Container(&#10;                                      margin: const EdgeInsets.only(bottom: 8),&#10;                                      padding: const EdgeInsets.all(8),&#10;                                      decoration: BoxDecoration(&#10;                                        border: Border.all(color: Colors.black26, width: 1),&#10;                                        borderRadius: BorderRadius.circular(8),&#10;                                      ),&#10;                                      child: Wrap(&#10;                                        spacing: 8,&#10;                                        runSpacing: 8,&#10;                                        children: controller!.getValidActions().where((action) =&gt; action.startsWith(&quot;move_&quot;)).map((action) {&#10;                                          final label = _getActionLabel(action);&#10;                                          String usesInfo = &quot;&quot;;&#10;                                          final player = controller!.state.getActive(true);&#10;                                          final index = int.tryParse(action.split(&quot;_&quot;)[1]) ?? 0;&#10;                                          if (index &gt;= 0 &amp;&amp; index &lt; player.abilities.length) {&#10;                                            final ability = player.abilities[index];&#10;                                            usesInfo = &quot; (${ability.remainingUses}/${ability.maxUses})&quot;;&#10;                                          }&#10;                                          return ElevatedButton(&#10;                                            onPressed: () =&gt; onPlayerAction(action),&#10;                                            child: Text(label + usesInfo),&#10;                                          );&#10;                                        }).toList(),&#10;                                      ),&#10;                                    ),&#10;                                  ],&#10;                                ),&#10;                                ExpansionTile(&#10;                                  title: const Text(&quot;Switch&quot;, style: TextStyle(fontWeight: FontWeight.bold)),&#10;                                  children: [&#10;                                    Container(&#10;                                      padding: const EdgeInsets.all(8),&#10;                                      decoration: BoxDecoration(&#10;                                        border: Border.all(color: Colors.black26, width: 1),&#10;                                        borderRadius: BorderRadius.circular(8),&#10;                                      ),&#10;                                      child: GridView.count(&#10;                                        crossAxisCount: 2,&#10;                                        shrinkWrap: true,&#10;                                        physics: const NeverScrollableScrollPhysics(),&#10;                                        childAspectRatio: 2.8,&#10;                                        mainAxisSpacing: 8,&#10;                                        crossAxisSpacing: 8,&#10;                                        children: controller!.getValidActions().where((action) =&gt; action.startsWith(&quot;switch_&quot;)).map((action) {&#10;                                          final label = _getActionLabel(action);&#10;                                          final team = controller!.state.playerTeam;&#10;                                          final index = int.tryParse(action.split(&quot;_&quot;)[1]) ?? 0;&#10;                                          String hpInfo = &quot;&quot;;&#10;                                          if (index &gt;= 0 &amp;&amp; index &lt; team.length) {&#10;                                            final poke = team[index];&#10;                                            hpInfo = &quot;  HP: ${poke.currentHealth}/${poke.maxHealth}&quot;;&#10;                                          }&#10;                                          return ElevatedButton(&#10;                                            onPressed: () =&gt; onPlayerAction(action),&#10;                                            child: Text(label + hpInfo),&#10;                                          );&#10;                                        }).toList(),&#10;                                      ),&#10;                                    ),&#10;                                  ],&#10;                                ),&#10;                              ],&#10;                            ),&#10;&#10;&#10;                            const SizedBox(height: 16),&#10;                          ]&#10;                        )&#10;                      ),&#10;                    ],&#10;                  ),&#10;                ),&#10;              ),&#10;            ),&#10;    );&#10;  }&#10;  String _getActionLabel(String action) {&#10;    final player = controller!.state.getActive(true);&#10;    final team = controller!.state.playerTeam;&#10;&#10;    if (action.startsWith(&quot;move_&quot;)) {&#10;      final index = int.tryParse(action.split(&quot;_&quot;)[1]) ?? 0;&#10;      if (index &gt;= 0 &amp;&amp; index &lt; player.abilities.length) {&#10;        return player.abilities[index].name;&#10;      } else {&#10;        return &quot;Unknown Move&quot;;&#10;      }&#10;    } else if (action.startsWith(&quot;switch_&quot;)) {&#10;      final index = int.tryParse(action.split(&quot;_&quot;)[1]) ?? 0;&#10;      if (index &gt;= 0 &amp;&amp; index &lt; team.length) {&#10;        return team[index].nickname;&#10;      } else {&#10;        return &quot;Unknown Switch&quot;;&#10;      }&#10;    }&#10;&#10;    return action;&#10;  }&#10;&#10;&#10;  Widget _buildPokemonCard(Pokemon_mcts p, {required bool isOpponent}) {&#10;    return Card(&#10;      elevation: 2,&#10;      color: p.isFainted ? Colors.grey[200] : (isOpponent ? Colors.red[100] : Colors.blue[100]),&#10;      child: Padding(&#10;        padding: const EdgeInsets.all(12.0),&#10;        child: Column(&#10;          crossAxisAlignment: CrossAxisAlignment.start,&#10;          children: [&#10;            Text(&quot;${p.nickname} (${p.pokemonName})&quot;,&#10;                style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),&#10;            const SizedBox(height: 4),&#10;            Row(&#10;              children: [&#10;                Text(&quot;HP: ${p.currentHealth}/${p.maxHealth}&quot;),&#10;                const SizedBox(width: 16),&#10;                Text(&quot;Type: ${p.type}&quot;),&#10;              ],&#10;            ),&#10;            const SizedBox(height: 4),&#10;            AnimatedHPBar(current: p.currentHealth, max: p.maxHealth),&#10;          ],&#10;        ),&#10;      ),&#10;      );&#10;  }&#10;&#10;  Widget _buildAnimatedSprite(Pokemon_mcts p, {bool shake = false}) {&#10;    final spritePath = 'assets/sprites/${p.pokemonName.toLowerCase()}.png';&#10;&#10;    return TweenAnimationBuilder&lt;Offset&gt;(&#10;      key: ValueKey(p.nickname + p.currentHealth.toString()),&#10;      tween: Tween&lt;Offset&gt;(&#10;        begin: Offset.zero,&#10;        end: shake ? const Offset(0.05, 0) : Offset.zero,&#10;      ),&#10;      duration: const Duration(milliseconds: 150),&#10;      curve: Curves.elasticIn,&#10;      builder: (context, value, _) {&#10;        return Transform.translate(&#10;          offset: Offset(value.dx * 10, 0),&#10;          child: Stack(&#10;            children: [&#10;              Image.asset(&#10;                spritePath,&#10;                width: 96,&#10;                height: 96,&#10;                errorBuilder: (context, error, stack) =&gt; const Icon(Icons.error),&#10;              ),&#10;              if (shake)&#10;                Positioned.fill(&#10;                  child: ColoredBox(&#10;                    color: Colors.white.withOpacity(0.5),&#10;                  ),&#10;                ),&#10;            ],&#10;          ),&#10;        );&#10;      },&#10;    );&#10;  }&#10;&#10;&#10;  String getAbilityName(String action, bool isPlayer) {&#10;    if (!action.startsWith(&quot;move_&quot;)) return &quot;&quot;;&#10;    final index = int.parse(action.split(&quot;_&quot;)[1]);&#10;    final p = controller!.state.getActive(isPlayer);&#10;    return p.abilities[index].name;&#10;  }&#10;&#10;&#10;  Future&lt;void&gt; playTurnAnimationSequence(String playerAction) async {&#10;    setState(() {&#10;      playerJustAttacked = playerAction.startsWith(&quot;move_&quot;);&#10;      opponentJustAttacked = false;&#10;      narration = &quot;You used ${getAbilityName(playerAction, true)}!&quot;;&#10;      isAnimating = true;&#10;    });&#10;&#10;    // Pause to show player attack + shake&#10;    await Future.delayed(const Duration(milliseconds: 500));&#10;&#10;    setState(() {&#10;      controller!.applyPlayerAction(playerAction);&#10;      // After controller.applyPlayerAction(playerAction);&#10;      final effectiveness = controller!.lastEffectiveness;&#10;      final feedback = getEffectivenessText(effectiveness);&#10;&#10;      setState(() {&#10;        narration += &quot;\n$feedback&quot;;&#10;      });&#10;&#10;    });&#10;&#10;    if (!controller!.isBattleOver) {&#10;      final aiAction = runMCTS(controller!.state, 100);&#10;      final isSwitch = aiAction.startsWith(&quot;switch_&quot;);&#10;      final aiUsed = isSwitch&#10;          ? &quot;AI switched to ${controller!.state.getActive(false).nickname}!&quot;&#10;          : &quot;Enemy used ${getAbilityName(aiAction, false)}!&quot;;&#10;&#10;      await Future.delayed(const Duration(milliseconds: 300));&#10;&#10;      setState(() {&#10;        narration = aiUsed;&#10;        opponentJustAttacked = !isSwitch;&#10;      });&#10;&#10;      await Future.delayed(const Duration(milliseconds: 500));&#10;&#10;      setState(() {&#10;        controller!.state.applyAction(aiAction);&#10;        isAnimating = false;&#10;      });&#10;    } else {&#10;      setState(() {&#10;        isAnimating = false;&#10;      });&#10;    }&#10;  }&#10;&#10;  void playBattleMusic() {&#10;    MusicService().playMusic('music/battle_music.mp3');&#10;  }&#10;&#10;  void toggleMusic() {&#10;    setState(() {&#10;      isMusicPlaying = !isMusicPlaying;&#10;      if (isMusicPlaying) {&#10;        MusicService().playMusic('music/battle_music.mp3');&#10;      } else {&#10;        MusicService().stopMusic();&#10;      }&#10;    });&#10;  }&#10;&#10;  void onPlayerAction(String action) {&#10;    playTurnAnimationSequence(action);&#10;  }&#10;&#10;&#10;  @override&#10;  void dispose() {&#10;    // Stop battle music and resume menu music when leaving the page&#10;    MusicService().stopMusic(); // Stop battle music&#10;    MusicService().playMusic('music/menu_music.mp3'); // Resume menu music&#10;    super.dispose();&#10;  }&#10;}&#10;class AnimatedHPBar extends StatelessWidget {&#10;  final int current;&#10;  final int max;&#10;&#10;  const AnimatedHPBar({super.key, required this.current, required this.max});&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    final ratio = current / max;&#10;    final color = ratio &gt; 0.5&#10;        ? Colors.green&#10;        : ratio &gt; 0.2&#10;        ? Colors.orange&#10;        : Colors.red;&#10;&#10;    return TweenAnimationBuilder&lt;double&gt;(&#10;      tween: Tween&lt;double&gt;(begin: 0, end: ratio),&#10;      duration: const Duration(milliseconds: 500),&#10;      builder: (context, value, _) {&#10;        return SizedBox(&#10;          width: 170, // or MediaQuery.of(context).size.width * 0.4 for responsive&#10;          child: ClipRRect(&#10;            borderRadius: BorderRadius.circular(6),&#10;            child: LinearProgressIndicator(&#10;              value: value,&#10;              backgroundColor: Colors.grey[300],&#10;              color: color,&#10;              minHeight: 12,&#10;            ),&#10;          ),&#10;        );&#10;      },&#10;    );&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lib/services/ability_utils.dart">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lib/services/ability_utils.dart" />
              <option name="originalContent" value="import 'package:flutter/material.dart';&#10;import 'package:supabase_flutter/supabase_flutter.dart';&#10;import 'dart:math';&#10;import 'dart:convert';&#10;import 'package:flutter/services.dart' show rootBundle;&#10;&#10;&#10;/// Fetches a random ability from the abilities_table, excluding the given ability IDs.&#10;Future&lt;Map&lt;String, dynamic&gt;?&gt; fetchRandomAbilityExcluding(List&lt;String&gt; excludeAbilityIds) async {&#10;  final supabase = Supabase.instance.client;&#10;  // Exclude abilities already owned&#10;  if (excludeAbilityIds.isEmpty) {&#10;    final abilities = await supabase&#10;        .from('abilities_table')&#10;        .select();&#10;    if (abilities == null || abilities.isEmpty) return null;&#10;    abilities.shuffle();&#10;    return abilities.first;&#10;  } else {&#10;    // Join UUIDs without extra quotes for Postgres&#10;    final excludeList = excludeAbilityIds.map((id) =&gt; &quot;'$id'&quot;).join(&quot;,&quot;);&#10;    final abilities = await supabase&#10;        .from('abilities_table')&#10;        .select()&#10;        .not('ability_id', 'in', '($excludeList)');&#10;    if (abilities == null || abilities.isEmpty) return null;&#10;    abilities.shuffle();&#10;    return abilities.first;&#10;  }&#10;}&#10;&#10;/// Offers a dialog to the user to swap a new ability with an existing one or ignore it.&#10;Future&lt;void&gt; offerAbilityDialog({&#10;  required BuildContext context,&#10;  required Map&lt;String, dynamic&gt; ability,&#10;  required String pokeId,&#10;  required List&lt;String&gt; currentAbilityIds,&#10;}) async {&#10;  final supabase = Supabase.instance.client;&#10;  String abilityName = ability['ability_name'] ?? 'Unknown';&#10;  String abilityType = ability['type'] ?? '';&#10;  String abilityId = ability['ability_id'].toString();&#10;  // Fetch current ability details for better button labels&#10;  List&lt;Map&lt;String, dynamic&gt;&gt; currentAbilities = [];&#10;  if (currentAbilityIds.isNotEmpty) {&#10;    final abilitiesRes = await supabase&#10;      .from('abilities_table')&#10;      .select()&#10;      .filter('ability_id', 'in', '(${currentAbilityIds.join(',')})');&#10;    if (abilitiesRes != null &amp;&amp; abilitiesRes is List) {&#10;      // Sort abilities to match the order of currentAbilityIds&#10;      final abilityMap = {for (var ab in abilitiesRes) ab['ability_id'].toString(): ab};&#10;      currentAbilities = currentAbilityIds.map((id) =&gt; abilityMap[id] ?? {'ability_name': 'Unknown', 'type': ''}).toList();&#10;    }&#10;  }&#10;  await showDialog(&#10;    context: context,&#10;    builder: (context) {&#10;      return AlertDialog(&#10;        title: Text('New Ability Unlocked!'),&#10;        content: Column(&#10;          mainAxisSize: MainAxisSize.min,&#10;          children: [&#10;            Text('Your PokÃ©mon can learn a new ability:'),&#10;            Text('$abilityName ($abilityType)'),&#10;            const SizedBox(height: 16),&#10;            Text('Do you want to replace an existing ability?'),&#10;          ],&#10;        ),&#10;        actions: [&#10;          TextButton(&#10;            onPressed: () =&gt; Navigator.of(context).pop(),&#10;            child: const Text('Ignore'),&#10;          ),&#10;          for (int i = 0; i &lt; currentAbilityIds.length; i++)&#10;            TextButton(&#10;              onPressed: () async {&#10;                await supabase.from('pokemon_table').update({&#10;                  'ability${i + 1}': abilityId,&#10;                }).eq('pokemon_id', pokeId);&#10;                Navigator.of(context).pop();&#10;              },&#10;              child: Text(&#10;                currentAbilities.isNotEmpty&#10;                  ? '${currentAbilities[i]['ability_name']} (${currentAbilities[i]['type']})'&#10;                  : 'Ability ${i + 1}'&#10;              ),&#10;            ),&#10;        ],&#10;      );&#10;    },&#10;  );&#10;}&#10;&#10;/// Fetches a random PokÃ©mon (name and type) from the CSV file.&#10;Future&lt;Map&lt;String, String&gt;&gt; fetchRandomPokemonFromCsv() async {&#10;  final csvString = await rootBundle.loadString('assets/pokemon_names_list.csv');&#10;  final lines = LineSplitter.split(csvString).toList();&#10;  if (lines.length &lt;= 1) throw Exception('No PokÃ©mon data found');&#10;  final rng = Random();&#10;  final idx = rng.nextInt(lines.length - 1) + 1; // skip header&#10;  final row = lines[idx].split(',');&#10;  return {'pokemon_name': row[0], 'type': row[1]};&#10;}&#10;&#10;/// Adds a new PokÃ©mon to the trainer's team in the database and returns the new pokemon_id.&#10;Future&lt;String?&gt; addRandomPokemonToTrainer(String trainerId, {BuildContext? context}) async {&#10;  final supabase = Supabase.instance.client;&#10;  final pokemon = await fetchRandomPokemonFromCsv();&#10;&#10;  // --- Ability selection logic ---&#10;  final abilities = await supabase&#10;      .from('abilities_table')&#10;      .select();&#10;  if (abilities == null || abilities.isEmpty) {&#10;    print('No abilities found in abilities_table');&#10;    return null;&#10;  }&#10;  final typeAbilities = abilities.where((a) =&gt; a['type'] == pokemon['type']).toList();&#10;  final otherAbilities = abilities.where((a) =&gt; a['type'] != pokemon['type']).toList();&#10;  final rng = Random();&#10;  List chosenAbilities = [];&#10;  final usedAbilityIds = &lt;dynamic&gt;{};&#10;&#10;  // Ensure at least two unique type-matching abilities if possible&#10;  typeAbilities.shuffle(rng);&#10;  for (var ab in typeAbilities) {&#10;    if (chosenAbilities.length &lt; 2 &amp;&amp; !usedAbilityIds.contains(ab['ability_id'])) {&#10;      chosenAbilities.add(ab);&#10;      usedAbilityIds.add(ab['ability_id']);&#10;    }&#10;  }&#10;  // If not enough type-matching, fill with other types, still unique&#10;  final allAbilities = [...typeAbilities, ...otherAbilities];&#10;  allAbilities.shuffle(rng);&#10;  for (var ab in allAbilities) {&#10;    if (chosenAbilities.length &gt;= 4) break;&#10;    if (!usedAbilityIds.contains(ab['ability_id'])) {&#10;      chosenAbilities.add(ab);&#10;      usedAbilityIds.add(ab['ability_id']);&#10;    }&#10;  }&#10;  // Defensive: if not enough, fill with empty maps&#10;  while (chosenAbilities.length &lt; 4) {&#10;    chosenAbilities.add({});&#10;  }&#10;  // Assign random health (25-40) and attack (10-30)&#10;  final health = 25 + rng.nextInt(16); // 25 to 40 inclusive&#10;  final attack = 10 + rng.nextInt(21); // 10 to 30 inclusive&#10;  // Insert new PokÃ©mon (do NOT assign to any slot, just set trainer_id)&#10;  final insertRes = await supabase&#10;      .from('pokemon_table')&#10;      .insert({&#10;        'pokemon_name': pokemon['pokemon_name'],&#10;        'type': pokemon['type'],&#10;        'level': 1,&#10;        'experience_points': 0,&#10;        'nickname': pokemon['pokemon_name'],&#10;        'trainer_id': trainerId,&#10;        'ability1': chosenAbilities[0]['ability_id'],&#10;        'ability2': chosenAbilities[1]['ability_id'],&#10;        'ability3': chosenAbilities[2]['ability_id'],&#10;        'ability4': chosenAbilities[3]['ability_id'],&#10;        'health': health,&#10;        'attack': attack,&#10;        // Add other default fields as needed&#10;      })&#10;      .select()&#10;      .maybeSingle();&#10;  if (insertRes == null) {&#10;    print('Failed to insert new PokÃ©mon for trainer $trainerId');&#10;    return null;&#10;  }&#10;  print('Added new PokÃ©mon ${pokemon['pokemon_name']} for trainer $trainerId');&#10;  return insertRes['pokemon_id']?.toString();&#10;}&#10;&#10;/// Shows a dialog to notify the user of a new PokÃ©mon.&#10;Future&lt;void&gt; showNewPokemonDialog(BuildContext context, String pokemonName, String type) async {&#10;  await showDialog(&#10;    context: context,&#10;    builder: (context) =&gt; AlertDialog(&#10;      title: const Text('New PokÃ©mon!'),&#10;      content: Text('You received a new PokÃ©mon: $pokemonName ($type)!'),&#10;      actions: [&#10;        TextButton(&#10;          onPressed: () =&gt; Navigator.of(context).pop(),&#10;          child: const Text('OK'),&#10;        ),&#10;      ],&#10;    ),&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="import 'package:flutter/material.dart';&#13;&#10;import 'package:supabase_flutter/supabase_flutter.dart';&#13;&#10;import 'dart:math';&#13;&#10;import 'dart:convert';&#13;&#10;import 'package:flutter/services.dart' show rootBundle;&#13;&#10;&#13;&#10;&#13;&#10;/// Fetches a random ability from the abilities_table, excluding the given ability IDs.&#13;&#10;Future&lt;Map&lt;String, dynamic&gt;?&gt; fetchRandomAbilityExcluding(List&lt;String&gt; excludeAbilityIds) async {&#13;&#10;  final supabase = Supabase.instance.client;&#13;&#10;  // Exclude abilities already owned&#13;&#10;  if (excludeAbilityIds.isEmpty) {&#13;&#10;    final abilities = await supabase&#13;&#10;        .from('abilities_table')&#13;&#10;        .select();&#13;&#10;    if (abilities == null || abilities.isEmpty) return null;&#13;&#10;    abilities.shuffle();&#13;&#10;    return abilities.first;&#13;&#10;  } else {&#13;&#10;    // Join UUIDs without extra quotes for Postgres&#13;&#10;    final excludeList = excludeAbilityIds.join(&quot;,&quot;);&#13;&#10;    final abilities = await supabase&#13;&#10;        .from('abilities_table')&#13;&#10;        .select()&#13;&#10;        .not('ability_id', 'in', '($excludeList)');&#13;&#10;    if (abilities == null || abilities.isEmpty) return null;&#13;&#10;    abilities.shuffle();&#13;&#10;    return abilities.first;&#13;&#10;  }&#13;&#10;}&#13;&#10;&#13;&#10;/// Offers a dialog to the user to swap a new ability with an existing one or ignore it.&#13;&#10;Future&lt;void&gt; offerAbilityDialog({&#13;&#10;  required BuildContext context,&#13;&#10;  required Map&lt;String, dynamic&gt; ability,&#13;&#10;  required String pokeId,&#13;&#10;  required List&lt;String&gt; currentAbilityIds,&#13;&#10;}) async {&#13;&#10;  final supabase = Supabase.instance.client;&#13;&#10;  String abilityName = ability['ability_name'] ?? 'Unknown';&#13;&#10;  String abilityType = ability['type'] ?? '';&#13;&#10;  String abilityId = ability['ability_id'].toString();&#13;&#10;  // Fetch current ability details for better button labels&#13;&#10;  List&lt;Map&lt;String, dynamic&gt;&gt; currentAbilities = [];&#13;&#10;  if (currentAbilityIds.isNotEmpty) {&#13;&#10;    final abilitiesRes = await supabase&#13;&#10;      .from('abilities_table')&#13;&#10;      .select()&#13;&#10;      .filter('ability_id', 'in', '(${currentAbilityIds.join(',')})');&#13;&#10;    if (abilitiesRes != null &amp;&amp; abilitiesRes is List) {&#13;&#10;      // Sort abilities to match the order of currentAbilityIds&#13;&#10;      final abilityMap = {for (var ab in abilitiesRes) ab['ability_id'].toString(): ab};&#13;&#10;      currentAbilities = currentAbilityIds.map((id) =&gt; abilityMap[id] ?? {'ability_name': 'Unknown', 'type': ''}).toList();&#13;&#10;    }&#13;&#10;  }&#13;&#10;  await showDialog(&#13;&#10;    context: context,&#13;&#10;    builder: (context) {&#13;&#10;      return AlertDialog(&#13;&#10;        title: Text('New Ability Unlocked!'),&#13;&#10;        content: Column(&#13;&#10;          mainAxisSize: MainAxisSize.min,&#13;&#10;          children: [&#13;&#10;            Text('Your PokÃ©mon can learn a new ability:'),&#13;&#10;            Text('$abilityName ($abilityType)'),&#13;&#10;            const SizedBox(height: 16),&#13;&#10;            Text('Do you want to replace an existing ability?'),&#13;&#10;          ],&#13;&#10;        ),&#13;&#10;        actions: [&#13;&#10;          TextButton(&#13;&#10;            onPressed: () =&gt; Navigator.of(context).pop(),&#13;&#10;            child: const Text('Ignore'),&#13;&#10;          ),&#13;&#10;          for (int i = 0; i &lt; currentAbilityIds.length; i++)&#13;&#10;            TextButton(&#13;&#10;              onPressed: () async {&#13;&#10;                await supabase.from('pokemon_table').update({&#13;&#10;                  'ability${i + 1}': abilityId,&#13;&#10;                }).eq('pokemon_id', pokeId);&#13;&#10;                Navigator.of(context).pop();&#13;&#10;              },&#13;&#10;              child: Text(&#13;&#10;                currentAbilities.isNotEmpty&#13;&#10;                  ? '${currentAbilities[i]['ability_name']} (${currentAbilities[i]['type']})'&#13;&#10;                  : 'Ability ${i + 1}'&#13;&#10;              ),&#13;&#10;            ),&#13;&#10;        ],&#13;&#10;      );&#13;&#10;    },&#13;&#10;  );&#13;&#10;}&#13;&#10;&#13;&#10;/// Fetches a random PokÃ©mon (name and type) from the CSV file.&#13;&#10;Future&lt;Map&lt;String, String&gt;&gt; fetchRandomPokemonFromCsv() async {&#13;&#10;  final csvString = await rootBundle.loadString('assets/pokemon_names_list.csv');&#13;&#10;  final lines = LineSplitter.split(csvString).toList();&#13;&#10;  if (lines.length &lt;= 1) throw Exception('No PokÃ©mon data found');&#13;&#10;  final rng = Random();&#13;&#10;  final idx = rng.nextInt(lines.length - 1) + 1; // skip header&#13;&#10;  final row = lines[idx].split(',');&#13;&#10;  return {'pokemon_name': row[0], 'type': row[1]};&#13;&#10;}&#13;&#10;&#13;&#10;/// Adds a new PokÃ©mon to the trainer's team in the database and returns the new pokemon_id.&#13;&#10;Future&lt;String?&gt; addRandomPokemonToTrainer(String trainerId, {BuildContext? context}) async {&#13;&#10;  final supabase = Supabase.instance.client;&#13;&#10;  final pokemon = await fetchRandomPokemonFromCsv();&#13;&#10;&#13;&#10;  // --- Ability selection logic ---&#13;&#10;  final abilities = await supabase&#13;&#10;      .from('abilities_table')&#13;&#10;      .select();&#13;&#10;  if (abilities == null || abilities.isEmpty) {&#13;&#10;    print('No abilities found in abilities_table');&#13;&#10;    return null;&#13;&#10;  }&#13;&#10;  final typeAbilities = abilities.where((a) =&gt; a['type'] == pokemon['type']).toList();&#13;&#10;  final otherAbilities = abilities.where((a) =&gt; a['type'] != pokemon['type']).toList();&#13;&#10;  final rng = Random();&#13;&#10;  List chosenAbilities = [];&#13;&#10;  final usedAbilityIds = &lt;dynamic&gt;{};&#13;&#10;&#13;&#10;  // Ensure at least two unique type-matching abilities if possible&#13;&#10;  typeAbilities.shuffle(rng);&#13;&#10;  for (var ab in typeAbilities) {&#13;&#10;    if (chosenAbilities.length &lt; 2 &amp;&amp; !usedAbilityIds.contains(ab['ability_id'])) {&#13;&#10;      chosenAbilities.add(ab);&#13;&#10;      usedAbilityIds.add(ab['ability_id']);&#13;&#10;    }&#13;&#10;  }&#13;&#10;  // If not enough type-matching, fill with other types, still unique&#13;&#10;  final allAbilities = [...typeAbilities, ...otherAbilities];&#13;&#10;  allAbilities.shuffle(rng);&#13;&#10;  for (var ab in allAbilities) {&#13;&#10;    if (chosenAbilities.length &gt;= 4) break;&#13;&#10;    if (!usedAbilityIds.contains(ab['ability_id'])) {&#13;&#10;      chosenAbilities.add(ab);&#13;&#10;      usedAbilityIds.add(ab['ability_id']);&#13;&#10;    }&#13;&#10;  }&#13;&#10;  // Defensive: if not enough, fill with empty maps&#13;&#10;  while (chosenAbilities.length &lt; 4) {&#13;&#10;    chosenAbilities.add({});&#13;&#10;  }&#13;&#10;  // Assign random health (25-40) and attack (10-30)&#13;&#10;  final health = 25 + rng.nextInt(16); // 25 to 40 inclusive&#13;&#10;  final attack = 10 + rng.nextInt(21); // 10 to 30 inclusive&#13;&#10;  // Insert new PokÃ©mon (do NOT assign to any slot, just set trainer_id)&#13;&#10;  final insertRes = await supabase&#13;&#10;      .from('pokemon_table')&#13;&#10;      .insert({&#13;&#10;        'pokemon_name': pokemon['pokemon_name'],&#13;&#10;        'type': pokemon['type'],&#13;&#10;        'level': 1,&#13;&#10;        'experience_points': 0,&#13;&#10;        'nickname': pokemon['pokemon_name'],&#13;&#10;        'trainer_id': trainerId,&#13;&#10;        'ability1': chosenAbilities[0]['ability_id'],&#13;&#10;        'ability2': chosenAbilities[1]['ability_id'],&#13;&#10;        'ability3': chosenAbilities[2]['ability_id'],&#13;&#10;        'ability4': chosenAbilities[3]['ability_id'],&#13;&#10;        'health': health,&#13;&#10;        'attack': attack,&#13;&#10;        // Add other default fields as needed&#13;&#10;      })&#13;&#10;      .select()&#13;&#10;      .maybeSingle();&#13;&#10;  if (insertRes == null) {&#13;&#10;    print('Failed to insert new PokÃ©mon for trainer $trainerId');&#13;&#10;    return null;&#13;&#10;  }&#13;&#10;  print('Added new PokÃ©mon ${pokemon['pokemon_name']} for trainer $trainerId');&#13;&#10;  return insertRes['pokemon_id']?.toString();&#13;&#10;}&#13;&#10;&#13;&#10;/// Shows a dialog to notify the user of a new PokÃ©mon.&#13;&#10;Future&lt;void&gt; showNewPokemonDialog(BuildContext context, String pokemonName, String type) async {&#13;&#10;  await showDialog(&#13;&#10;    context: context,&#13;&#10;    builder: (context) =&gt; AlertDialog(&#13;&#10;      title: const Text('New PokÃ©mon!'),&#13;&#10;      content: Text('You received a new PokÃ©mon: $pokemonName ($type)!'),&#13;&#10;      actions: [&#13;&#10;        TextButton(&#13;&#10;          onPressed: () =&gt; Navigator.of(context).pop(),&#13;&#10;          child: const Text('OK'),&#13;&#10;        ),&#13;&#10;      ],&#13;&#10;    ),&#13;&#10;  );&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lib/services/task_details_card.dart">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lib/services/task_details_card.dart" />
              <option name="originalContent" value="import 'package:flutter/material.dart';&#10;import 'package:poketask/services/xp_utils.dart';&#10;import 'package:poketask/services/ability_utils.dart';&#10;import 'package:supabase_flutter/supabase_flutter.dart';&#10;import '../../models/task.dart';&#10;import '../models/pokemon_mcts.dart';&#10;&#10;class TaskDetailsCard extends StatefulWidget {&#10;  final Task task;&#10;  const TaskDetailsCard({super.key, required this.task});&#10;&#10;  @override&#10;  State&lt;TaskDetailsCard&gt; createState() =&gt; _TaskDetailsCardState();&#10;}&#10;&#10;class _TaskDetailsCardState extends State&lt;TaskDetailsCard&gt; {&#10;  late bool isCompleted;&#10;  late String notes;&#10;  final TextEditingController _notesController = TextEditingController();&#10;&#10;  @override&#10;  void initState() {&#10;    super.initState();&#10;    isCompleted = widget.task.isCompleted;&#10;    notes = widget.task.taskNotes;&#10;    _notesController.text = notes;&#10;  }&#10;&#10;  @override&#10;  void dispose() {&#10;    _notesController.dispose();&#10;    super.dispose();&#10;  }&#10;&#10;  Future&lt;void&gt; updateTaskCompleted(bool completed) async {&#10;    final supabase = Supabase.instance.client;&#10;    final now = DateTime.now();&#10;    await supabase&#10;        .from('task_table')&#10;        .update({&#10;          'is_completed': completed,&#10;          'date_completed': completed ? now.toIso8601String() : null,&#10;        })&#10;        .eq('task_id', widget.task.taskId);&#10;&#10;    final trainerId = widget.task.trainerId;&#10;    if (trainerId != null &amp;&amp; trainerId.isNotEmpty) {&#10;      final trainerResponse = await supabase&#10;        .from('trainer_table')&#10;        .select()&#10;        .eq('trainer_id', trainerId)&#10;        .maybeSingle();&#10;      int completedTasks = (trainerResponse != null &amp;&amp; trainerResponse['completed_tasks'] != null)&#10;        ? trainerResponse['completed_tasks'] as int&#10;        : 0;&#10;      final newCompletedTasks = completed&#10;        ? completedTasks + 1&#10;        : (completedTasks &gt; 0 ? completedTasks - 1 : 0);&#10;      int trainerXp = trainerResponse?['experience_points'] ?? 0;&#10;      int trainerLevel = trainerResponse?['level'] ?? 1;&#10;      int xpChange = completed ? 25 : -25;&#10;      final trainerXpResult = calculateXpAndLevel(&#10;        currentXp: trainerXp,&#10;        currentLevel: trainerLevel,&#10;        xpChange: xpChange,&#10;        scaler: 1.1,&#10;        base: 100,&#10;      );&#10;      trainerXp = trainerXpResult.newXp;&#10;      trainerLevel = trainerXpResult.newLevel;&#10;      bool trainerLeveledUp = trainerXpResult.levelsGained &gt; 0;&#10;      await supabase&#10;        .from('trainer_table')&#10;        .update({&#10;          'completed_tasks': newCompletedTasks,&#10;          'experience_points': trainerXp,&#10;          'level': trainerLevel,&#10;        })&#10;        .eq('trainer_id', trainerId);&#10;      // --- Trainer level up: add random PokÃ©mon and show dialog ---&#10;      if (trainerLeveledUp) {&#10;        final newPokeId = await addRandomPokemonToTrainer(trainerId);&#10;        if (newPokeId != null) {&#10;          final pokeRes = await supabase&#10;            .from('pokemon_table')&#10;            .select()&#10;            .eq('pokemon_id', newPokeId)&#10;            .maybeSingle();&#10;          if (pokeRes != null &amp;&amp; context.mounted) {&#10;            await showNewPokemonDialog(context, pokeRes['pokemon_name'], pokeRes['type']);&#10;          }&#10;        }&#10;      }&#10;      // --- PokÃ©mon XP/Level/Ability logic ---&#10;      List&lt;String&gt; pokemonLevelUps = [];&#10;      List&lt;Future&lt;void&gt;&gt; abilityDialogs = [];&#10;      for (int i = 1; i &lt;= 6; i++) {&#10;        final slotKey = 'pokemon_slot_$i';&#10;        final pokeId = trainerResponse?[slotKey];&#10;        if (pokeId == null) continue;&#10;        final pokeRes = await supabase&#10;          .from('pokemon_table')&#10;          .select()&#10;          .eq('pokemon_id', pokeId)&#10;          .maybeSingle();&#10;        if (pokeRes == null) continue;&#10;        int pokeXp = pokeRes['experience_points'] ?? 0;&#10;        int pokeLevel = pokeRes['level'] ?? 1;&#10;        final pokeXpResult = calculateXpAndLevel(&#10;          currentXp: pokeXp,&#10;          currentLevel: pokeLevel,&#10;          xpChange: xpChange,&#10;          scaler: 1.1,&#10;          base: 100,&#10;        );&#10;        // Only add to level up list if level increased&#10;        if (pokeXpResult.levelsGained &gt; 0) {&#10;          // Apply stat scaling for each level gained&#10;          var tempPoke = Pokemon_mcts(&#10;            pokemonName: pokeRes['pokemon_name'],&#10;            nickname: pokeRes['nickname'],&#10;            type: pokeRes['type'],&#10;            level: pokeLevel,&#10;            attack: pokeRes['attack'],&#10;            maxHealth: pokeRes['health'],&#10;            abilities: [], // Not needed for stat scaling&#10;          );&#10;          for (int lvl = 0; lvl &lt; pokeXpResult.levelsGained; lvl++) {&#10;            tempPoke = tempPoke.levelUp();&#10;          }&#10;          String pokeName = pokeRes['nickname'] ?? pokeRes['pokemon_name'] ?? 'PokÃ©mon';&#10;          pokemonLevelUps.add('$pokeName (Lv ${pokeLevel} â ${pokeXpResult.newLevel})');&#10;          // Update DB with new XP/level and new stats&#10;          await supabase&#10;            .from('pokemon_table')&#10;            .update({&#10;              'experience_points': pokeXpResult.newXp,&#10;              'level': pokeXpResult.newLevel,&#10;              'health': tempPoke.maxHealth,&#10;              'attack': tempPoke.attack,&#10;            })&#10;            .eq('pokemon_id', pokeId);&#10;        } else {&#10;          // Update DB with new XP/level only&#10;          await supabase&#10;            .from('pokemon_table')&#10;            .update({&#10;              'experience_points': pokeXpResult.newXp,&#10;              'level': pokeXpResult.newLevel,&#10;            })&#10;            .eq('pokemon_id', pokeId);&#10;        }&#10;        // Offer new ability if new level is a multiple of 5 and at least one level was gained&#10;        if (pokeXpResult.levelsGained &gt; 0 &amp;&amp; pokeXpResult.newLevel % 5 == 0) {&#10;          List&lt;String&gt; currentAbilityIds = [];&#10;          for (int j = 1; j &lt;= 4; j++) {&#10;            final abId = pokeRes['ability$j'];&#10;            if (abId != null) currentAbilityIds.add(abId.toString());&#10;          }&#10;          final newAbility = await fetchRandomAbilityExcluding(currentAbilityIds);&#10;          if (newAbility != null &amp;&amp; context.mounted) {&#10;            // Queue the dialog to show after level-up notification&#10;            abilityDialogs.add(Future(() async {&#10;              await Future.delayed(const Duration(seconds: 2));&#10;              await offerAbilityDialog(&#10;                context: context,&#10;                ability: newAbility,&#10;                pokeId: pokeId.toString(),&#10;                currentAbilityIds: currentAbilityIds,&#10;              );&#10;            }));&#10;          }&#10;        }&#10;      }&#10;      // Show level-up notification if any&#10;      if (pokemonLevelUps.isNotEmpty &amp;&amp; context.mounted) {&#10;        await showDialog(&#10;          context: context,&#10;          builder: (context) =&gt; AlertDialog(&#10;            title: const Text('PokÃ©mon Leveled Up!'),&#10;            content: Text(pokemonLevelUps.join('\n')),&#10;            actions: [&#10;              TextButton(&#10;                onPressed: () =&gt; Navigator.of(context).pop(),&#10;                child: const Text('OK'),&#10;              ),&#10;            ],&#10;          ),&#10;        );&#10;      }&#10;      // Show ability dialogs (sequentially)&#10;      for (final dialog in abilityDialogs) {&#10;        await dialog;&#10;      }&#10;    }&#10;    if (!mounted) return;&#10;    setState(() {&#10;      isCompleted = completed;&#10;      widget.task.isCompleted = completed;&#10;      widget.task.dateCompleted = completed ? now : DateTime(2100);&#10;    });&#10;    // Do not close the dialog here&#10;  }&#10;&#10;  Future&lt;void&gt; updateTaskNotes(String notes) async {&#10;    final supabase = Supabase.instance.client;&#10;    await supabase&#10;        .from('task_table')&#10;        .update({'task_notes': notes})&#10;        .eq('task_id', widget.task.taskId);&#10;  }&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    return AlertDialog(&#10;      titlePadding: EdgeInsets.zero,&#10;      title: Column(&#10;        crossAxisAlignment: CrossAxisAlignment.stretch,&#10;        children: [&#10;          if (widget.task.highPriority == true)&#10;            Container(&#10;              color: Colors.red[700],&#10;              padding: EdgeInsets.symmetric(vertical: 8, horizontal: 16),&#10;              child: Row(&#10;                children: [&#10;                  Icon(Icons.priority_high, color: Colors.white, size: 22),&#10;                  SizedBox(width: 8),&#10;                  Text(&#10;                    'High Priority',&#10;                    style: TextStyle(&#10;                      color: Colors.white,&#10;                      fontWeight: FontWeight.bold,&#10;                      fontSize: 16,&#10;                      letterSpacing: 1.1,&#10;                    ),&#10;                  ),&#10;                ],&#10;              ),&#10;            ),&#10;          if (widget.task.endDate.isBefore(DateTime.now()))&#10;            Container(&#10;              color: Colors.orange[800],&#10;              padding: EdgeInsets.symmetric(vertical: 8, horizontal: 16),&#10;              child: Row(&#10;                children: [&#10;                  Icon(Icons.warning_amber_rounded, color: Colors.white, size: 22),&#10;                  SizedBox(width: 8),&#10;                  Text(&#10;                    'Past Deadline',&#10;                    style: TextStyle(&#10;                      color: Colors.white,&#10;                      fontWeight: FontWeight.bold,&#10;                      fontSize: 16,&#10;                      letterSpacing: 1.1,&#10;                    ),&#10;                  ),&#10;                ],&#10;              ),&#10;            ),&#10;          Padding(&#10;            padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 8.0),&#10;            child: Row(&#10;              children: [&#10;                Expanded(child: Text(widget.task.taskText)),&#10;                IconButton(&#10;                  icon: Icon(&#10;                    isCompleted ? Icons.check_circle : Icons.radio_button_unchecked,&#10;                    color: isCompleted ? Colors.green : Colors.grey,&#10;                  ),&#10;                  tooltip: isCompleted ? 'Completed' : 'Mark as complete',&#10;                  onPressed: () async {&#10;                    await updateTaskCompleted(!isCompleted);&#10;                  },&#10;                ),&#10;              ],&#10;            ),&#10;          ),&#10;        ],&#10;      ),&#10;      content: SingleChildScrollView(&#10;        child: Column(&#10;          mainAxisSize: MainAxisSize.min,&#10;          crossAxisAlignment: CrossAxisAlignment.start,&#10;          children: [&#10;            Text('Notes:'),&#10;            TextField(&#10;              controller: _notesController,&#10;              maxLines: 2,&#10;              decoration: InputDecoration(&#10;                hintText: 'Add notes...',&#10;                border: OutlineInputBorder(),&#10;                suffixIcon: IconButton(&#10;                  icon: Icon(Icons.save),&#10;                  tooltip: 'Save Notes',&#10;                  onPressed: () async {&#10;                    setState(() {&#10;                      notes = _notesController.text;&#10;                      widget.task.taskNotes = notes;&#10;                    });&#10;                    await updateTaskNotes(notes);&#10;                  },&#10;                ),&#10;              ),&#10;            ),&#10;            SizedBox(height: 8),&#10;            Text('Start: '&#10;                '${widget.task.startDate.year}-${widget.task.startDate.month.toString().padLeft(2, '0')}-${widget.task.startDate.day.toString().padLeft(2, '0')} '&#10;                '${widget.task.startDate.hour.toString().padLeft(2, '0')}:${widget.task.startDate.minute.toString().padLeft(2, '0')}'),&#10;            Text('End: '&#10;                '${widget.task.endDate.year}-${widget.task.endDate.month.toString().padLeft(2, '0')}-${widget.task.endDate.day.toString().padLeft(2, '0')} '&#10;                '${widget.task.endDate.hour.toString().padLeft(2, '0')}:${widget.task.endDate.minute.toString().padLeft(2, '0')}'),&#10;            SizedBox(height: 8),&#10;            Text('Completed: ${isCompleted ? &quot;Yes&quot; : &quot;No&quot;}'),&#10;          ],&#10;        ),&#10;      ),&#10;      actions: [&#10;        TextButton(&#10;          onPressed: () =&gt; Navigator.of(context).pop(isCompleted),&#10;          child: Text('Close'),&#10;        ),&#10;        TextButton(&#10;          onPressed: () async {&#10;            final supabase = Supabase.instance.client;&#10;            await supabase&#10;                .from('task_table')&#10;                .delete()&#10;                .eq('task_id', widget.task.taskId);&#10;            Navigator.of(context).pop('delete');&#10;          },&#10;          child: Text('Delete', style: TextStyle(color: Colors.red)),&#10;        ),&#10;      ],&#10;    );&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import 'package:flutter/material.dart';&#13;&#10;import 'package:poketask/services/xp_utils.dart';&#13;&#10;import 'package:poketask/services/ability_utils.dart';&#13;&#10;import 'package:supabase_flutter/supabase_flutter.dart';&#13;&#10;import '../../models/task.dart';&#13;&#10;import '../models/pokemon_mcts.dart';&#13;&#10;&#13;&#10;class TaskDetailsCard extends StatefulWidget {&#13;&#10;  final Task task;&#13;&#10;  const TaskDetailsCard({super.key, required this.task});&#13;&#10;&#13;&#10;  @override&#13;&#10;  State&lt;TaskDetailsCard&gt; createState() =&gt; _TaskDetailsCardState();&#13;&#10;}&#13;&#10;&#13;&#10;class _TaskDetailsCardState extends State&lt;TaskDetailsCard&gt; {&#13;&#10;  late bool isCompleted;&#13;&#10;  late String notes;&#13;&#10;  final TextEditingController _notesController = TextEditingController();&#13;&#10;&#13;&#10;  @override&#13;&#10;  void initState() {&#13;&#10;    super.initState();&#13;&#10;    isCompleted = widget.task.isCompleted;&#13;&#10;    notes = widget.task.taskNotes;&#13;&#10;    _notesController.text = notes;&#13;&#10;  }&#13;&#10;&#13;&#10;  @override&#13;&#10;  void dispose() {&#13;&#10;    _notesController.dispose();&#13;&#10;    super.dispose();&#13;&#10;  }&#13;&#10;&#13;&#10;  Future&lt;void&gt; updateTaskCompleted(bool completed) async {&#13;&#10;    final supabase = Supabase.instance.client;&#13;&#10;    final now = DateTime.now();&#13;&#10;    await supabase&#13;&#10;        .from('task_table')&#13;&#10;        .update({&#13;&#10;          'is_completed': completed,&#13;&#10;          'date_completed': completed ? now.toIso8601String() : null,&#13;&#10;        })&#13;&#10;        .eq('task_id', widget.task.taskId);&#13;&#10;&#13;&#10;    final trainerId = widget.task.trainerId;&#13;&#10;    if (trainerId != null &amp;&amp; trainerId.isNotEmpty) {&#13;&#10;      final trainerResponse = await supabase&#13;&#10;        .from('trainer_table')&#13;&#10;        .select()&#13;&#10;        .eq('trainer_id', trainerId)&#13;&#10;        .maybeSingle();&#13;&#10;      int completedTasks = (trainerResponse != null &amp;&amp; trainerResponse['completed_tasks'] != null)&#13;&#10;        ? trainerResponse['completed_tasks'] as int&#13;&#10;        : 0;&#13;&#10;      final newCompletedTasks = completed&#13;&#10;        ? completedTasks + 1&#13;&#10;        : (completedTasks &gt; 0 ? completedTasks - 1 : 0);&#13;&#10;      int trainerXp = trainerResponse?['experience_points'] ?? 0;&#13;&#10;      int trainerLevel = trainerResponse?['level'] ?? 1;&#13;&#10;      // --- XP Scaling ---&#13;&#10;      int xpChange = 0;&#13;&#10;      if (completed) {&#13;&#10;        if (widget.task.highPriority == true) {&#13;&#10;          xpChange = 75;&#13;&#10;        } else {&#13;&#10;          xpChange = 50;&#13;&#10;        }&#13;&#10;        if (widget.task.endDate.isAfter(now)) {&#13;&#10;          xpChange += 25;&#13;&#10;        }&#13;&#10;      } else {&#13;&#10;        xpChange = -50; // If un-completing, revert base XP&#13;&#10;      }&#13;&#10;      final trainerXpResult = calculateXpAndLevel(&#13;&#10;        currentXp: trainerXp,&#13;&#10;        currentLevel: trainerLevel,&#13;&#10;        xpChange: xpChange,&#13;&#10;        scaler: 1.1,&#13;&#10;        base: 100,&#13;&#10;      );&#13;&#10;      trainerXp = trainerXpResult.newXp;&#13;&#10;      trainerLevel = trainerXpResult.newLevel;&#13;&#10;      bool trainerLeveledUp = trainerXpResult.levelsGained &gt; 0;&#13;&#10;      await supabase&#13;&#10;        .from('trainer_table')&#13;&#10;        .update({&#13;&#10;          'completed_tasks': newCompletedTasks,&#13;&#10;          'experience_points': trainerXp,&#13;&#10;          'level': trainerLevel,&#13;&#10;        })&#13;&#10;        .eq('trainer_id', trainerId);&#13;&#10;      // --- Trainer level up: add random PokÃ©mon and show dialog ---&#13;&#10;      if (trainerLeveledUp) {&#13;&#10;        final newPokeId = await addRandomPokemonToTrainer(trainerId);&#13;&#10;        if (newPokeId != null) {&#13;&#10;          final pokeRes = await supabase&#13;&#10;            .from('pokemon_table')&#13;&#10;            .select()&#13;&#10;            .eq('pokemon_id', newPokeId)&#13;&#10;            .maybeSingle();&#13;&#10;          if (pokeRes != null &amp;&amp; context.mounted) {&#13;&#10;            await showNewPokemonDialog(context, pokeRes['pokemon_name'], pokeRes['type']);&#13;&#10;          }&#13;&#10;        }&#13;&#10;      }&#13;&#10;      // --- PokÃ©mon XP/Level/Ability logic ---&#13;&#10;      List&lt;String&gt; pokemonLevelUps = [];&#13;&#10;      List&lt;Future&lt;void&gt;&gt; abilityDialogs = [];&#13;&#10;      // Collect slot PokÃ©mon IDs&#13;&#10;      Set&lt;String&gt; slotPokeIds = {};&#13;&#10;      for (int i = 1; i &lt;= 6; i++) {&#13;&#10;        final slotKey = 'pokemon_slot_$i';&#13;&#10;        final pokeId = trainerResponse?[slotKey];&#13;&#10;        if (pokeId == null) continue;&#13;&#10;        slotPokeIds.add(pokeId.toString());&#13;&#10;        final pokeRes = await supabase&#13;&#10;          .from('pokemon_table')&#13;&#10;          .select()&#13;&#10;          .eq('pokemon_id', pokeId)&#13;&#10;          .maybeSingle();&#13;&#10;        if (pokeRes == null) continue;&#13;&#10;        int pokeXp = pokeRes['experience_points'] ?? 0;&#13;&#10;        int pokeLevel = pokeRes['level'] ?? 1;&#13;&#10;        final pokeXpResult = calculateXpAndLevel(&#13;&#10;          currentXp: pokeXp,&#13;&#10;          currentLevel: pokeLevel,&#13;&#10;          xpChange: xpChange,&#13;&#10;          scaler: 1.1,&#13;&#10;          base: 100,&#13;&#10;        );&#13;&#10;        if (pokeXpResult.levelsGained &gt; 0) {&#13;&#10;          var tempPoke = Pokemon_mcts(&#13;&#10;            pokemonName: pokeRes['pokemon_name'],&#13;&#10;            nickname: pokeRes['nickname'],&#13;&#10;            type: pokeRes['type'],&#13;&#10;            level: pokeLevel,&#13;&#10;            attack: pokeRes['attack'],&#13;&#10;            maxHealth: pokeRes['health'],&#13;&#10;            abilities: [],&#13;&#10;          );&#13;&#10;          for (int lvl = 0; lvl &lt; pokeXpResult.levelsGained; lvl++) {&#13;&#10;            tempPoke = tempPoke.levelUp();&#13;&#10;          }&#13;&#10;          String pokeName = pokeRes['nickname'] ?? pokeRes['pokemon_name'] ?? 'PokÃ©mon';&#13;&#10;          pokemonLevelUps.add('$pokeName (Lv ${pokeLevel} â ${pokeXpResult.newLevel})');&#13;&#10;          await supabase&#13;&#10;            .from('pokemon_table')&#13;&#10;            .update({&#13;&#10;              'experience_points': pokeXpResult.newXp,&#13;&#10;              'level': pokeXpResult.newLevel,&#13;&#10;              'health': tempPoke.maxHealth,&#13;&#10;              'attack': tempPoke.attack,&#13;&#10;            })&#13;&#10;            .eq('pokemon_id', pokeId);&#13;&#10;        } else {&#13;&#10;          await supabase&#13;&#10;            .from('pokemon_table')&#13;&#10;            .update({&#13;&#10;              'experience_points': pokeXpResult.newXp,&#13;&#10;              'level': pokeXpResult.newLevel,&#13;&#10;            })&#13;&#10;            .eq('pokemon_id', pokeId);&#13;&#10;        }&#13;&#10;        if (pokeXpResult.levelsGained &gt; 0 &amp;&amp; pokeXpResult.newLevel % 5 == 0) {&#13;&#10;          List&lt;String&gt; currentAbilityIds = [];&#13;&#10;          for (int j = 1; j &lt;= 4; j++) {&#13;&#10;            final abId = pokeRes['ability$j'];&#13;&#10;            if (abId != null) currentAbilityIds.add(abId.toString());&#13;&#10;          }&#13;&#10;          final newAbility = await fetchRandomAbilityExcluding(currentAbilityIds);&#13;&#10;          if (newAbility != null &amp;&amp; context.mounted) {&#13;&#10;            abilityDialogs.add(Future(() async {&#13;&#10;              await Future.delayed(const Duration(seconds: 2));&#13;&#10;              await offerAbilityDialog(&#13;&#10;                context: context,&#13;&#10;                ability: newAbility,&#13;&#10;                pokeId: pokeId.toString(),&#13;&#10;                currentAbilityIds: currentAbilityIds,&#13;&#10;              );&#13;&#10;            }));&#13;&#10;          }&#13;&#10;        }&#13;&#10;      }&#13;&#10;      // --- Favorite PokÃ©mon XP logic ---&#13;&#10;      final favoritePokeId = trainerResponse?['favorite_pokemon'];&#13;&#10;      if (favoritePokeId != null) {&#13;&#10;        // If favorite is also in a slot, it gets double XP&#13;&#10;        int favoriteXpChange = slotPokeIds.contains(favoritePokeId.toString()) ? xpChange : xpChange;&#13;&#10;        // If in slot, it will get XP again below, so add again for double&#13;&#10;        if (slotPokeIds.contains(favoritePokeId.toString())) {&#13;&#10;          favoriteXpChange = xpChange; // Already applied above, so add again&#13;&#10;        }&#13;&#10;        final pokeRes = await supabase&#13;&#10;          .from('pokemon_table')&#13;&#10;          .select()&#13;&#10;          .eq('pokemon_id', favoritePokeId)&#13;&#10;          .maybeSingle();&#13;&#10;        if (pokeRes != null) {&#13;&#10;          int pokeXp = pokeRes['experience_points'] ?? 0;&#13;&#10;          int pokeLevel = pokeRes['level'] ?? 1;&#13;&#10;          // If in slot, add XP again for double&#13;&#10;          int totalXpChange = slotPokeIds.contains(favoritePokeId.toString()) ? xpChange : xpChange;&#13;&#10;          if (slotPokeIds.contains(favoritePokeId.toString())) {&#13;&#10;            totalXpChange += xpChange;&#13;&#10;          }&#13;&#10;          final pokeXpResult = calculateXpAndLevel(&#13;&#10;            currentXp: pokeXp,&#13;&#10;            currentLevel: pokeLevel,&#13;&#10;            xpChange: totalXpChange,&#13;&#10;            scaler: 1.1,&#13;&#10;            base: 100,&#13;&#10;          );&#13;&#10;          await supabase&#13;&#10;            .from('pokemon_table')&#13;&#10;            .update({&#13;&#10;              'experience_points': pokeXpResult.newXp,&#13;&#10;              'level': pokeXpResult.newLevel,&#13;&#10;            })&#13;&#10;            .eq('pokemon_id', favoritePokeId);&#13;&#10;        }&#13;&#10;      }&#13;&#10;      // Show level-up notification if any&#13;&#10;      if (pokemonLevelUps.isNotEmpty &amp;&amp; context.mounted) {&#13;&#10;        await showDialog(&#13;&#10;          context: context,&#13;&#10;          builder: (context) =&gt; AlertDialog(&#13;&#10;            title: const Text('PokÃ©mon Leveled Up!'),&#13;&#10;            content: Text(pokemonLevelUps.join('\n')),&#13;&#10;            actions: [&#13;&#10;              TextButton(&#13;&#10;                onPressed: () =&gt; Navigator.of(context).pop(),&#13;&#10;                child: const Text('OK'),&#13;&#10;              ),&#13;&#10;            ],&#13;&#10;          ),&#13;&#10;        );&#13;&#10;      }&#13;&#10;      // Show ability dialogs (sequentially)&#13;&#10;      for (final dialog in abilityDialogs) {&#13;&#10;        await dialog;&#13;&#10;      }&#13;&#10;    }&#13;&#10;    if (!mounted) return;&#13;&#10;    setState(() {&#13;&#10;      isCompleted = completed;&#13;&#10;      widget.task.isCompleted = completed;&#13;&#10;      widget.task.dateCompleted = completed ? now : DateTime(2100);&#13;&#10;    });&#13;&#10;    // Do not close the dialog here&#13;&#10;  }&#13;&#10;&#13;&#10;  Future&lt;void&gt; updateTaskNotes(String notes) async {&#13;&#10;    final supabase = Supabase.instance.client;&#13;&#10;    await supabase&#13;&#10;        .from('task_table')&#13;&#10;        .update({'task_notes': notes})&#13;&#10;        .eq('task_id', widget.task.taskId);&#13;&#10;  }&#13;&#10;&#13;&#10;  @override&#13;&#10;  Widget build(BuildContext context) {&#13;&#10;    return AlertDialog(&#13;&#10;      titlePadding: EdgeInsets.zero,&#13;&#10;      title: Column(&#13;&#10;        crossAxisAlignment: CrossAxisAlignment.stretch,&#13;&#10;        children: [&#13;&#10;          if (widget.task.highPriority == true)&#13;&#10;            Container(&#13;&#10;              color: Colors.red[700],&#13;&#10;              padding: EdgeInsets.symmetric(vertical: 8, horizontal: 16),&#13;&#10;              child: Row(&#13;&#10;                children: [&#13;&#10;                  Icon(Icons.priority_high, color: Colors.white, size: 22),&#13;&#10;                  SizedBox(width: 8),&#13;&#10;                  Text(&#13;&#10;                    'High Priority',&#13;&#10;                    style: TextStyle(&#13;&#10;                      color: Colors.white,&#13;&#10;                      fontWeight: FontWeight.bold,&#13;&#10;                      fontSize: 16,&#13;&#10;                      letterSpacing: 1.1,&#13;&#10;                    ),&#13;&#10;                  ),&#13;&#10;                ],&#13;&#10;              ),&#13;&#10;            ),&#13;&#10;          if (widget.task.endDate.isBefore(DateTime.now()))&#13;&#10;            Container(&#13;&#10;              color: Colors.orange[800],&#13;&#10;              padding: EdgeInsets.symmetric(vertical: 8, horizontal: 16),&#13;&#10;              child: Row(&#13;&#10;                children: [&#13;&#10;                  Icon(Icons.warning_amber_rounded, color: Colors.white, size: 22),&#13;&#10;                  SizedBox(width: 8),&#13;&#10;                  Text(&#13;&#10;                    'Past Deadline',&#13;&#10;                    style: TextStyle(&#13;&#10;                      color: Colors.white,&#13;&#10;                      fontWeight: FontWeight.bold,&#13;&#10;                      fontSize: 16,&#13;&#10;                      letterSpacing: 1.1,&#13;&#10;                    ),&#13;&#10;                  ),&#13;&#10;                ],&#13;&#10;              ),&#13;&#10;            ),&#13;&#10;          Padding(&#13;&#10;            padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 8.0),&#13;&#10;            child: Row(&#13;&#10;              children: [&#13;&#10;                Expanded(child: Text(widget.task.taskText)),&#13;&#10;                IconButton(&#13;&#10;                  icon: Icon(&#13;&#10;                    isCompleted ? Icons.check_circle : Icons.radio_button_unchecked,&#13;&#10;                    color: isCompleted ? Colors.green : Colors.grey,&#13;&#10;                  ),&#13;&#10;                  tooltip: isCompleted ? 'Completed' : 'Mark as complete',&#13;&#10;                  onPressed: () async {&#13;&#10;                    await updateTaskCompleted(!isCompleted);&#13;&#10;                  },&#13;&#10;                ),&#13;&#10;              ],&#13;&#10;            ),&#13;&#10;          ),&#13;&#10;        ],&#13;&#10;      ),&#13;&#10;      content: SingleChildScrollView(&#13;&#10;        child: Column(&#13;&#10;          mainAxisSize: MainAxisSize.min,&#13;&#10;          crossAxisAlignment: CrossAxisAlignment.start,&#13;&#10;          children: [&#13;&#10;            Text('Notes:'),&#13;&#10;            TextField(&#13;&#10;              controller: _notesController,&#13;&#10;              maxLines: 2,&#13;&#10;              decoration: InputDecoration(&#13;&#10;                hintText: 'Add notes...',&#13;&#10;                border: OutlineInputBorder(),&#13;&#10;                suffixIcon: IconButton(&#13;&#10;                  icon: Icon(Icons.save),&#13;&#10;                  tooltip: 'Save Notes',&#13;&#10;                  onPressed: () async {&#13;&#10;                    setState(() {&#13;&#10;                      notes = _notesController.text;&#13;&#10;                      widget.task.taskNotes = notes;&#13;&#10;                    });&#13;&#10;                    await updateTaskNotes(notes);&#13;&#10;                  },&#13;&#10;                ),&#13;&#10;              ),&#13;&#10;            ),&#13;&#10;            SizedBox(height: 8),&#13;&#10;            Text('Start: '&#13;&#10;                '${widget.task.startDate.year}-${widget.task.startDate.month.toString().padLeft(2, '0')}-${widget.task.startDate.day.toString().padLeft(2, '0')} '&#13;&#10;                '${widget.task.startDate.hour.toString().padLeft(2, '0')}:${widget.task.startDate.minute.toString().padLeft(2, '0')}'),&#13;&#10;            Text('End: '&#13;&#10;                '${widget.task.endDate.year}-${widget.task.endDate.month.toString().padLeft(2, '0')}-${widget.task.endDate.day.toString().padLeft(2, '0')} '&#13;&#10;                '${widget.task.endDate.hour.toString().padLeft(2, '0')}:${widget.task.endDate.minute.toString().padLeft(2, '0')}'),&#13;&#10;            SizedBox(height: 8),&#13;&#10;            Text('Completed: ${isCompleted ? &quot;Yes&quot; : &quot;No&quot;}'),&#13;&#10;          ],&#13;&#10;        ),&#13;&#10;      ),&#13;&#10;      actions: [&#13;&#10;        TextButton(&#13;&#10;          onPressed: () =&gt; Navigator.of(context).pop(isCompleted),&#13;&#10;          child: Text('Close'),&#13;&#10;        ),&#13;&#10;        TextButton(&#13;&#10;          onPressed: () async {&#13;&#10;            final supabase = Supabase.instance.client;&#13;&#10;            await supabase&#13;&#10;                .from('task_table')&#13;&#10;                .delete()&#13;&#10;                .eq('task_id', widget.task.taskId);&#13;&#10;            Navigator.of(context).pop('delete');&#13;&#10;          },&#13;&#10;          child: Text('Delete', style: TextStyle(color: Colors.red)),&#13;&#10;        ),&#13;&#10;      ],&#13;&#10;    );&#13;&#10;  }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>