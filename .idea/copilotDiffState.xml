<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/lib/pages/folders_page.dart">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lib/pages/folders_page.dart" />
              <option name="originalContent" value="import 'package:flutter/material.dart';&#10;import 'package:flutter_colorpicker/flutter_colorpicker.dart';&#10;import 'package:supabase_flutter/supabase_flutter.dart';&#10;import 'package:uuid/uuid.dart';&#10;&#10;import '../models/task.dart';&#10;import '../services/task_details_card.dart';&#10;import '../services/task_form.dart';&#10;&#10;class FoldersPage extends StatefulWidget {&#10;  final String trainerId;&#10;  const FoldersPage({super.key, required this.trainerId});&#10;&#10;  @override&#10;  State&lt;FoldersPage&gt; createState() =&gt; _FoldersPageState();&#10;}&#10;&#10;class _FoldersPageState extends State&lt;FoldersPage&gt; {&#10;  final List&lt;Task&gt; tasks = [&#10;&#10;  ];&#10;&#10;  List&lt;Map&lt;String, dynamic&gt;&gt; folders = [];&#10;  String? expandedFolderId;&#10;&#10;  @override&#10;  void initState() {&#10;    super.initState();&#10;    fetchFolders();&#10;  }&#10;&#10;  Future&lt;void&gt; fetchFolders() async {&#10;    final supabase = Supabase.instance.client;&#10;    final response = await supabase&#10;        .from('folder_table')&#10;        .select()&#10;        .eq('trainer_id', widget.trainerId);&#10;    setState(() {&#10;      folders = [&#10;        {'folder_id': '0', 'folder_name': 'No Folder'},&#10;        ...List&lt;Map&lt;String, dynamic&gt;&gt;.from(response)&#10;      ];&#10;    });&#10;  }&#10;&#10;  void onFolderSelected(String? folderId) async {&#10;    setState(() {&#10;      expandedFolderId = folderId;&#10;      tasks.clear();&#10;    });&#10;    final supabase = Supabase.instance.client;&#10;    List response;&#10;    if (folderId == null || folderId == '0') {&#10;      response = await supabase&#10;          .from('task_table')&#10;          .select()&#10;          .eq('trainer_id', widget.trainerId);&#10;      print('Fetched tasks for trainer_id: \\${widget.trainerId} =&gt; \\${response.length} tasks');&#10;      // Filter for tasks with folder_id == null&#10;      response = response.where((t) =&gt; t['folder_id'] == null).toList();&#10;      print('Filtered tasks with folder_id == null: \\${response.length} tasks');&#10;    } else {&#10;      response = await supabase&#10;          .from('task_table')&#10;          .select()&#10;          .eq('trainer_id', widget.trainerId)&#10;          .eq('folder_id', folderId);&#10;    }&#10;    setState(() {&#10;      tasks.clear();&#10;      for (final t in response) {&#10;        tasks.add(Task.fromJson(t));&#10;      }&#10;    });&#10;  }&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    return Scaffold(&#10;      appBar: AppBar(&#10;        leading: IconButton(&#10;          icon: Icon(Icons.arrow_back),&#10;          onPressed: () {&#10;            Navigator.pop(context);&#10;          },&#10;        ),&#10;        title: Text('Folders'),&#10;        backgroundColor: Colors.redAccent,&#10;        elevation: 0,&#10;      ),&#10;      body: Row(&#10;        children: [&#10;          // Sidebar for folders&#10;          Container(&#10;            width: 160,&#10;            color: Colors.grey[300],&#10;            child: Column(&#10;              children: [&#10;                Padding(&#10;                  padding: const EdgeInsets.symmetric(vertical: 8.0, horizontal: 8.0),&#10;                  child: ElevatedButton.icon(&#10;                    icon: Icon(Icons.create_new_folder, size: 20),&#10;                    label: Text('Add Folder', style: TextStyle(fontSize: 13)),&#10;                    style: ElevatedButton.styleFrom(&#10;                      backgroundColor: Colors.redAccent,&#10;                      foregroundColor: Colors.white,&#10;                      minimumSize: Size(double.infinity, 36),&#10;                      padding: EdgeInsets.symmetric(horizontal: 8, vertical: 4),&#10;                    ),&#10;                    onPressed: () async {&#10;                      final controller = TextEditingController();&#10;                      Color selectedColor = Colors.blue; // Default color&#10;                      final result = await showDialog&lt;Map&lt;String, dynamic&gt;&gt;(&#10;                        context: context,&#10;                        builder: (context) {&#10;                          return StatefulBuilder(&#10;                            builder: (context, setState) =&gt; AlertDialog(&#10;                              title: Text('New Folder'),&#10;                              content: Column(&#10;                                mainAxisSize: MainAxisSize.min,&#10;                                children: [&#10;                                  TextField(&#10;                                    controller: controller,&#10;                                    autofocus: true,&#10;                                    decoration: InputDecoration(hintText: 'Folder name'),&#10;                                  ),&#10;                                  SizedBox(height: 16),&#10;                                  Row(&#10;                                    children: [&#10;                                      Text('Color:'),&#10;                                      SizedBox(width: 8),&#10;                                      GestureDetector(&#10;                                        onTap: () async {&#10;                                          Color? picked = await showDialog&lt;Color&gt;(&#10;                                            context: context,&#10;                                            builder: (context) =&gt; AlertDialog(&#10;                                              title: Text('Pick a color'),&#10;                                              content: SingleChildScrollView(&#10;                                                child: BlockPicker(&#10;                                                  pickerColor: selectedColor,&#10;                                                  onColorChanged: (color) {&#10;                                                    Navigator.of(context).pop(color);&#10;                                                  },&#10;                                                ),&#10;                                              ),&#10;                                            ),&#10;                                          );&#10;                                          if (picked != null) {&#10;                                            setState(() =&gt; selectedColor = picked);&#10;                                          }&#10;                                        },&#10;                                        child: Container(&#10;                                          width: 24,&#10;                                          height: 24,&#10;                                          decoration: BoxDecoration(&#10;                                            color: selectedColor,&#10;                                            shape: BoxShape.circle,&#10;                                            border: Border.all(color: Colors.black26),&#10;                                          ),&#10;                                        ),&#10;                                      ),&#10;                                    ],&#10;                                  ),&#10;                                ],&#10;                              ),&#10;                              actions: [&#10;                                TextButton(&#10;                                  onPressed: () =&gt; Navigator.of(context).pop(),&#10;                                  child: Text('Cancel'),&#10;                                ),&#10;                                ElevatedButton(&#10;                                  onPressed: () {&#10;                                    if (controller.text.trim().isNotEmpty) {&#10;                                      Navigator.of(context).pop({&#10;                                        'folder_name': controller.text.trim(),&#10;                                        'color': selectedColor.value,&#10;                                      });&#10;                                    }&#10;                                  },&#10;                                  child: Text('Add'),&#10;                                ),&#10;                              ],&#10;                            ),&#10;                          );&#10;                        },&#10;                      );&#10;                      if (result != null &amp;&amp; result['folder_name'].isNotEmpty) {&#10;                        final uuid = Uuid();&#10;                        final folderId = uuid.v4();&#10;                        final folderName = result['folder_name'];&#10;                        final colorValue = result['color'];&#10;                        final trainerId = widget.trainerId;&#10;                        // Convert color int to hex string with #&#10;                        final colorHex = '#'&#10;                            + colorValue.toRadixString(16).padLeft(8, '0').substring(2).toUpperCase();&#10;                        // Insert into database&#10;                        final supabase = Supabase.instance.client;&#10;                        await supabase.from('folder_table').insert({&#10;                          'folder_id': folderId,&#10;                          'folder_name': folderName,&#10;                          'trainer_id': trainerId,&#10;                          'color': colorHex,&#10;                        });&#10;                        // Add to local list&#10;                        setState(() {&#10;                          folders.add({&#10;                            'folder_id': folderId,&#10;                            'folder_name': folderName,&#10;                            'trainer_id': trainerId,&#10;                            'color': colorHex,&#10;                          });&#10;                        });&#10;&#10;                      }&#10;                    },&#10;                  ),&#10;                ),&#10;                Expanded(&#10;                  child: LayoutBuilder(&#10;                    builder: (context, constraints) {&#10;                      return ListView(&#10;                        children: folders.map((folder) {&#10;                          final folderId = (folder['folder_id'] ?? '0').toString();&#10;                          final isExpanded = expandedFolderId == folderId;&#10;                          String folderName = (folder['folder_name'] ?? 'Unnamed Folder').toString();&#10;                          double fontSize = 15;&#10;                          final textPainter = TextPainter(&#10;                            text: TextSpan(text: folderName, style: TextStyle(fontSize: fontSize)),&#10;                            maxLines: 1,&#10;                            textDirection: TextDirection.ltr,&#10;                          );&#10;                          textPainter.layout(maxWidth: constraints.maxWidth - 48);&#10;                          while (textPainter.didExceedMaxLines &amp;&amp; fontSize &gt; 10) {&#10;                            fontSize -= 1;&#10;                            textPainter.text = TextSpan(text: folderName, style: TextStyle(fontSize: fontSize));&#10;                            textPainter.layout(maxWidth: constraints.maxWidth - 48);&#10;                          }&#10;                          return Row(&#10;                            children: [&#10;                              Expanded(&#10;                                child: Dismissible(&#10;                                  key: ValueKey(folderId),&#10;                                  direction: folderId != '0' ? DismissDirection.endToStart : DismissDirection.none,&#10;                                  background: Container(&#10;                                    color: Colors.redAccent,&#10;                                    alignment: Alignment.centerRight,&#10;                                    padding: EdgeInsets.symmetric(horizontal: 20),&#10;                                    child: Icon(Icons.delete, color: Colors.white),&#10;                                  ),&#10;                                  confirmDismiss: folderId != '0'&#10;                                      ? (direction) async {&#10;                                          return await showDialog&lt;bool&gt;(&#10;                                            context: context,&#10;                                            builder: (context) =&gt; AlertDialog(&#10;                                              title: Text('Delete Folder'),&#10;                                              content: Text('Are you sure you want to delete the folder &quot;$folderName&quot;? All tasks in this folder will be moved to &quot;No Folder&quot;.'),&#10;                                              actions: [&#10;                                                TextButton(&#10;                                                  onPressed: () =&gt; Navigator.of(context).pop(false),&#10;                                                  child: Text('Cancel'),&#10;                                                ),&#10;                                                ElevatedButton(&#10;                                                  onPressed: () =&gt; Navigator.of(context).pop(true),&#10;                                                  style: ElevatedButton.styleFrom(backgroundColor: Colors.redAccent),&#10;                                                  child: Text('Delete', style: TextStyle(color: Colors.white)),&#10;                                                ),&#10;                                              ],&#10;                                            ),&#10;                                          );&#10;                                        }&#10;                                      : null,&#10;                                  onDismissed: (direction) {&#10;                                    setState(() {&#10;                                      for (final t in tasks) {&#10;                                        if (t.folderId == folderId) {&#10;                                          t.folderId = '0';&#10;                                        }&#10;                                      }&#10;                                      folders.removeWhere((f) =&gt; f['folder_id'] == folder['folder_id']);&#10;                                      if (expandedFolderId == folderId) expandedFolderId = null;&#10;                                    });&#10;                                  },&#10;                                  child: ListTile(&#10;                                    leading: Icon(&#10;                                      Icons.folder,&#10;                                      color: folderId == '0'&#10;                                          ? Colors.grey&#10;                                          : (folder['color'] != null &amp;&amp; folder['color'] is String &amp;&amp; (folder['color'] as String).startsWith('#')&#10;                                              ? Color(int.parse((folder['color'] as String).replaceFirst('#', '0xff')))&#10;                                              : Colors.redAccent),&#10;                                    ),&#10;                                    title: Text(&#10;                                      folderName,&#10;                                      style: TextStyle(fontSize: fontSize),&#10;                                      softWrap: true,&#10;                                      overflow: TextOverflow.visible,&#10;                                    ),&#10;                                    selected: isExpanded,&#10;                                    onTap: () {&#10;                                      onFolderSelected(isExpanded ? null : folderId);&#10;                                    },&#10;                                    onLongPress: folder['id'] != 0&#10;                                        ? () async {&#10;                                            final action = await showModalBottomSheet&lt;String&gt;(&#10;                                              context: context,&#10;                                              builder: (context) =&gt; SafeArea(&#10;                                                child: Column(&#10;                                                  mainAxisSize: MainAxisSize.min,&#10;                                                  children: [&#10;                                                    ListTile(&#10;                                                      leading: Icon(Icons.edit),&#10;                                                      title: Text('Rename'),&#10;                                                      onTap: () =&gt; Navigator.of(context).pop('rename'),&#10;                                                    ),&#10;                                                    ListTile(&#10;                                                      leading: Icon(Icons.delete, color: Colors.redAccent),&#10;                                                      title: Text('Delete', style: TextStyle(color: Colors.redAccent)),&#10;                                                      onTap: () =&gt; Navigator.of(context).pop('delete'),&#10;                                                    ),&#10;                                                  ],&#10;                                                ),&#10;                                              ),&#10;                                            );&#10;                                            if (action == 'rename') {&#10;                                              final controller = TextEditingController(text: folderName);&#10;                                              final newName = await showDialog&lt;String&gt;(&#10;                                                context: context,&#10;                                                builder: (context) =&gt; AlertDialog(&#10;                                                  title: Text('Rename Folder'),&#10;                                                  content: TextField(&#10;                                                    controller: controller,&#10;                                                    autofocus: true,&#10;                                                    decoration: InputDecoration(hintText: 'Folder name'),&#10;                                                  ),&#10;                                                  actions: [&#10;                                                    TextButton(&#10;                                                      onPressed: () =&gt; Navigator.of(context).pop(),&#10;                                                      child: Text('Cancel'),&#10;                                                    ),&#10;                                                    ElevatedButton(&#10;                                                      onPressed: () {&#10;                                                        if (controller.text.trim().isNotEmpty) {&#10;                                                          Navigator.of(context).pop(controller.text.trim());&#10;                                                        }&#10;                                                      },&#10;                                                      child: Text('Rename'),&#10;                                                    ),&#10;                                                  ],&#10;                                                ),&#10;                                              );&#10;                                              if (newName != null &amp;&amp; newName.isNotEmpty &amp;&amp; newName != folderName) {&#10;                                                setState(() {&#10;                                                  folder['name'] = newName;&#10;                                                });&#10;                                              }&#10;                                            } else if (action == 'delete') {&#10;                                              final confirm = await showDialog&lt;bool&gt;(&#10;                                                context: context,&#10;                                                builder: (context) =&gt; AlertDialog(&#10;                                                  title: Text('Delete Folder'),&#10;                                                  content: Text('Are you sure you want to delete the folder &quot;$folderName&quot;? All tasks in this folder will be moved to &quot;No Folder&quot;.'),&#10;                                                  actions: [&#10;                                                    TextButton(&#10;                                                      onPressed: () =&gt; Navigator.of(context).pop(false),&#10;                                                      child: Text('Cancel'),&#10;                                                    ),&#10;                                                    ElevatedButton(&#10;                                                      onPressed: () =&gt; Navigator.of(context).pop(true),&#10;                                                      style: ElevatedButton.styleFrom(backgroundColor: Colors.redAccent),&#10;                                                      child: Text('Delete', style: TextStyle(color: Colors.white)),&#10;                                                    ),&#10;                                                  ],&#10;                                                ),&#10;                                              );&#10;                                              if (confirm == true) {&#10;                                                setState(() {&#10;                                                  for (final t in tasks) {&#10;                                                    if (t.folderId == folder['id'].toString()) {&#10;                                                      t.folderId = '0';&#10;                                                    }&#10;                                                  }&#10;                                                  folders.removeWhere((f) =&gt; f['id'] == folder['id']);&#10;                                                  if (expandedFolderId == folder['id']) expandedFolderId = null;&#10;                                                });&#10;                                              }&#10;                                            }&#10;                                          }&#10;                                        : null,&#10;                                    trailing: Icon(isExpanded ? Icons.expand_less : Icons.expand_more),&#10;                                    contentPadding: EdgeInsets.symmetric(horizontal: 2, vertical: 0), // Reduced horizontal padding&#10;                                    minVerticalPadding: 0,&#10;                                    dense: true,&#10;                                  ),&#10;                                ),&#10;                              ),&#10;                            ],&#10;                          );&#10;                        }).toList(),&#10;                      );&#10;                    },&#10;                  ),&#10;                ),&#10;                // Move the Add Task button up using a Spacer and MediaQuery for adaptive padding&#10;                Spacer(),&#10;                Padding(&#10;                  padding: EdgeInsets.only(&#10;                    left: 8.0,&#10;                    right: 8.0,&#10;                    bottom: MediaQuery.of(context).viewPadding.bottom + 16, // Add extra space above system nav bar&#10;                    top: 8.0,&#10;                  ),&#10;                  child: ElevatedButton.icon(&#10;                    icon: Icon(Icons.add_task),&#10;                    label: Text('Add Task'),&#10;                    style: ElevatedButton.styleFrom(&#10;                      backgroundColor: Colors.redAccent,&#10;                      foregroundColor: Colors.white,&#10;                      minimumSize: Size(double.infinity, 40),&#10;                    ),&#10;                    onPressed: () async {&#10;                      await Navigator.of(context).push(&#10;                        MaterialPageRoute(&#10;                          builder: (context) =&gt; TaskForm(&#10;                            trainerId: widget.trainerId,&#10;                            onSubmit: (task) {&#10;                              onFolderSelected(expandedFolderId);&#10;                              Navigator.of(context).pop();&#10;                            },&#10;                          ),&#10;                        ),&#10;                      );&#10;                    },&#10;                  ),&#10;                ),&#10;              ],&#10;            ),&#10;          ),&#10;          // Main area for tasks in selected folder&#10;          Expanded(&#10;            child: Container(&#10;              color: Colors.grey[100],&#10;              child: expandedFolderId == null&#10;                  ? Center(child: Text('Select a folder to view tasks'))&#10;                  : AnimatedSwitcher(&#10;                      duration: Duration(milliseconds: 400),&#10;                      switchInCurve: Curves.easeOut,&#10;                      child: ListView.builder(&#10;                        key: ValueKey(expandedFolderId),&#10;                        padding: EdgeInsets.all(10),&#10;                        itemCount: expandedFolderId == '0'&#10;                            ? tasks.where((task) =&gt; task.folderId == null).length&#10;                            : tasks.where((task) =&gt; task.folderId == expandedFolderId?.toString()).length,&#10;                        itemBuilder: (context, idx) {&#10;                          final visibleTasks = expandedFolderId == '0'&#10;                              ? tasks.where((task) =&gt; task.folderId == null).toList()&#10;                              : tasks.where((task) =&gt; task.folderId == expandedFolderId?.toString()).toList();&#10;                          final task = visibleTasks[idx];&#10;                          return TweenAnimationBuilder&lt;Offset&gt;(&#10;                            tween: Tween&lt;Offset&gt;(&#10;                              begin: Offset(0, 0.3 + 0.1 * (visibleTasks.length - idx)),&#10;                              end: Offset.zero,&#10;                            ),&#10;                            duration: Duration(milliseconds: 350 + idx * 80),&#10;                            curve: Curves.easeOut,&#10;                            builder: (context, offset, child) {&#10;                              return Transform.translate(&#10;                                offset: Offset(0, offset.dy * 60),&#10;                                child: child,&#10;                              );&#10;                            },&#10;                            child: Card(&#10;                              child: Column(&#10;                                crossAxisAlignment: CrossAxisAlignment.stretch,&#10;                                children: [&#10;                                  if (task.highPriority == true)&#10;                                    Container(&#10;                                      color: Colors.red[700],&#10;                                      padding: EdgeInsets.symmetric(vertical: 6, horizontal: 16),&#10;                                      child: Row(&#10;                                        children: [&#10;                                          Icon(Icons.priority_high, color: Colors.white, size: 18),&#10;                                          SizedBox(width: 6),&#10;                                          Text(&#10;                                            'High Priority',&#10;                                            style: TextStyle(&#10;                                              color: Colors.white,&#10;                                              fontWeight: FontWeight.bold,&#10;                                              fontSize: 14,&#10;                                              letterSpacing: 1.1,&#10;                                            ),&#10;                                          ),&#10;                                        ],&#10;                                      ),&#10;                                    ),&#10;                                  if (task.to.isBefore(DateTime.now()))&#10;                                    Container(&#10;                                      color: Colors.orange[800],&#10;                                      padding: EdgeInsets.symmetric(vertical: 6, horizontal: 16),&#10;                                      child: Row(&#10;                                        children: [&#10;                                          Icon(Icons.warning_amber_rounded, color: Colors.white, size: 18),&#10;                                          SizedBox(width: 6),&#10;                                          Text(&#10;                                            'Past Deadline',&#10;                                            style: TextStyle(&#10;                                              color: Colors.white,&#10;                                              fontWeight: FontWeight.bold,&#10;                                              fontSize: 14,&#10;                                              letterSpacing: 1.1,&#10;                                            ),&#10;                                          ),&#10;                                        ],&#10;                                      ),&#10;                                    ),&#10;                                  SizedBox(&#10;                                    width: double.infinity,&#10;                                    child: InkWell(&#10;                                      onTap: () async {&#10;                                        await showDialog(&#10;                                          context: context,&#10;                                          builder: (context) =&gt; TaskDetailsCard(task: task),&#10;                                        );&#10;                                        setState(() {});&#10;                                      },&#10;                                      child: ListTile(&#10;                                        leading: Icon(&#10;                                          task.isCompleted ? Icons.check_circle : Icons.radio_button_unchecked,&#10;                                          color: task.isCompleted ? Colors.green : Colors.grey,&#10;                                        ),&#10;                                        title: Text(&#10;                                          task.eventName.replaceAll(' ', '\n'),&#10;                                          maxLines: 3,&#10;                                          overflow: TextOverflow.ellipsis,&#10;                                          style: TextStyle(fontSize: 18, height: 1.2),&#10;                                          softWrap: true,&#10;                                        ),&#10;                                        subtitle: Text(&#10;                                          task.notes,&#10;                                          maxLines: 5,&#10;                                          overflow: TextOverflow.ellipsis,&#10;                                          style: TextStyle(fontSize: 15),&#10;                                        ),&#10;                                        contentPadding: EdgeInsets.symmetric(horizontal: 24, vertical: 12),&#10;                                      ),&#10;                                    ),&#10;                                  ),&#10;                                ],&#10;                              ),&#10;                            ),&#10;                          );&#10;                        },&#10;                      ),&#10;                    ),&#10;            ),&#10;          ),&#10;        ],&#10;      ),&#10;    );&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import 'package:flutter/material.dart';&#10;import 'package:flutter_colorpicker/flutter_colorpicker.dart';&#10;import 'package:supabase_flutter/supabase_flutter.dart';&#10;import 'package:uuid/uuid.dart';&#10;&#10;import '../models/task.dart';&#10;import '../services/task_details_card.dart';&#10;import '../services/task_form.dart';&#10;&#10;class FoldersPage extends StatefulWidget {&#10;  final String trainerId;&#10;  const FoldersPage({super.key, required this.trainerId});&#10;&#10;  @override&#10;  State&lt;FoldersPage&gt; createState() =&gt; _FoldersPageState();&#10;}&#10;&#10;class _FoldersPageState extends State&lt;FoldersPage&gt; {&#10;  final List&lt;Task&gt; tasks = [&#10;&#10;  ];&#10;&#10;  List&lt;Map&lt;String, dynamic&gt;&gt; folders = [];&#10;  String? expandedFolderId;&#10;&#10;  @override&#10;  void initState() {&#10;    super.initState();&#10;    fetchFolders();&#10;  }&#10;&#10;  Future&lt;void&gt; fetchFolders() async {&#10;    final supabase = Supabase.instance.client;&#10;    final response = await supabase&#10;        .from('folder_table')&#10;        .select()&#10;        .eq('trainer_id', widget.trainerId);&#10;    setState(() {&#10;      folders = [&#10;        {'folder_id': '0', 'folder_name': 'No Folder'},&#10;        ...List&lt;Map&lt;String, dynamic&gt;&gt;.from(response)&#10;      ];&#10;    });&#10;  }&#10;&#10;  void onFolderSelected(String? folderId) async {&#10;    setState(() {&#10;      expandedFolderId = folderId;&#10;      tasks.clear();&#10;    });&#10;    final supabase = Supabase.instance.client;&#10;    List response;&#10;    if (folderId == null || folderId == '0') {&#10;      response = await supabase&#10;          .from('task_table')&#10;          .select()&#10;          .eq('trainer_id', widget.trainerId);&#10;      print('Fetched tasks for trainer_id: \\${widget.trainerId} =&gt; \\${response.length} tasks');&#10;      // Filter for tasks with folder_id == null&#10;      response = response.where((t) =&gt; t['folder_id'] == null).toList();&#10;      print('Filtered tasks with folder_id == null: \\${response.length} tasks');&#10;    } else {&#10;      response = await supabase&#10;          .from('task_table')&#10;          .select()&#10;          .eq('trainer_id', widget.trainerId)&#10;          .eq('folder_id', folderId);&#10;    }&#10;    setState(() {&#10;      tasks.clear();&#10;      for (final t in response) {&#10;        tasks.add(Task.fromJson(t));&#10;      }&#10;    });&#10;  }&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    return Scaffold(&#10;      appBar: AppBar(&#10;        leading: IconButton(&#10;          icon: Icon(Icons.arrow_back),&#10;          onPressed: () {&#10;            Navigator.pop(context);&#10;          },&#10;        ),&#10;        title: Text('Folders'),&#10;        backgroundColor: Colors.redAccent,&#10;        elevation: 0,&#10;      ),&#10;      body: Row(&#10;        children: [&#10;          // Sidebar for folders&#10;          Container(&#10;            width: 160,&#10;            color: Colors.grey[300],&#10;            child: Column(&#10;              children: [&#10;                Padding(&#10;                  padding: const EdgeInsets.symmetric(vertical: 8.0, horizontal: 8.0),&#10;                  child: ElevatedButton.icon(&#10;                    icon: Icon(Icons.create_new_folder, size: 20),&#10;                    label: Text('Add Folder', style: TextStyle(fontSize: 13)),&#10;                    style: ElevatedButton.styleFrom(&#10;                      backgroundColor: Colors.redAccent,&#10;                      foregroundColor: Colors.white,&#10;                      minimumSize: Size(double.infinity, 36),&#10;                      padding: EdgeInsets.symmetric(horizontal: 8, vertical: 4),&#10;                    ),&#10;                    onPressed: () async {&#10;                      final controller = TextEditingController();&#10;                      Color selectedColor = Colors.blue; // Default color&#10;                      final result = await showDialog&lt;Map&lt;String, dynamic&gt;&gt;(&#10;                        context: context,&#10;                        builder: (context) {&#10;                          return StatefulBuilder(&#10;                            builder: (context, setState) =&gt; AlertDialog(&#10;                              title: Text('New Folder'),&#10;                              content: Column(&#10;                                mainAxisSize: MainAxisSize.min,&#10;                                children: [&#10;                                  TextField(&#10;                                    controller: controller,&#10;                                    autofocus: true,&#10;                                    decoration: InputDecoration(hintText: 'Folder name'),&#10;                                  ),&#10;                                  SizedBox(height: 16),&#10;                                  Row(&#10;                                    children: [&#10;                                      Text('Color:'),&#10;                                      SizedBox(width: 8),&#10;                                      GestureDetector(&#10;                                        onTap: () async {&#10;                                          Color? picked = await showDialog&lt;Color&gt;(&#10;                                            context: context,&#10;                                            builder: (context) =&gt; AlertDialog(&#10;                                              title: Text('Pick a color'),&#10;                                              content: SingleChildScrollView(&#10;                                                child: BlockPicker(&#10;                                                  pickerColor: selectedColor,&#10;                                                  onColorChanged: (color) {&#10;                                                    Navigator.of(context).pop(color);&#10;                                                  },&#10;                                                ),&#10;                                              ),&#10;                                            ),&#10;                                          );&#10;                                          if (picked != null) {&#10;                                            setState(() =&gt; selectedColor = picked);&#10;                                          }&#10;                                        },&#10;                                        child: Container(&#10;                                          width: 24,&#10;                                          height: 24,&#10;                                          decoration: BoxDecoration(&#10;                                            color: selectedColor,&#10;                                            shape: BoxShape.circle,&#10;                                            border: Border.all(color: Colors.black26),&#10;                                          ),&#10;                                        ),&#10;                                      ),&#10;                                    ],&#10;                                  ),&#10;                                ],&#10;                              ),&#10;                              actions: [&#10;                                TextButton(&#10;                                  onPressed: () =&gt; Navigator.of(context).pop(),&#10;                                  child: Text('Cancel'),&#10;                                ),&#10;                                ElevatedButton(&#10;                                  onPressed: () {&#10;                                    if (controller.text.trim().isNotEmpty) {&#10;                                      Navigator.of(context).pop({&#10;                                        'folder_name': controller.text.trim(),&#10;                                        'color': selectedColor.value,&#10;                                      });&#10;                                    }&#10;                                  },&#10;                                  child: Text('Add'),&#10;                                ),&#10;                              ],&#10;                            ),&#10;                          );&#10;                        },&#10;                      );&#10;                      if (result != null &amp;&amp; result['folder_name'].isNotEmpty) {&#10;                        final uuid = Uuid();&#10;                        final folderId = uuid.v4();&#10;                        final folderName = result['folder_name'];&#10;                        final colorValue = result['color'];&#10;                        final trainerId = widget.trainerId;&#10;                        // Convert color int to hex string with #&#10;                        final colorHex = '#'&#10;                            + colorValue.toRadixString(16).padLeft(8, '0').substring(2).toUpperCase();&#10;                        // Insert into database&#10;                        final supabase = Supabase.instance.client;&#10;                        await supabase.from('folder_table').insert({&#10;                          'folder_id': folderId,&#10;                          'folder_name': folderName,&#10;                          'trainer_id': trainerId,&#10;                          'color': colorHex,&#10;                        });&#10;                        // Add to local list&#10;                        setState(() {&#10;                          folders.add({&#10;                            'folder_id': folderId,&#10;                            'folder_name': folderName,&#10;                            'trainer_id': trainerId,&#10;                            'color': colorHex,&#10;                          });&#10;                        });&#10;&#10;                      }&#10;                    },&#10;                  ),&#10;                ),&#10;                Expanded(&#10;                  child: Scrollbar(&#10;                    thumbVisibility: true,&#10;                    child: LayoutBuilder(&#10;                      builder: (context, constraints) {&#10;                        return ListView(&#10;                          children: folders.map((folder) {&#10;                            final folderId = (folder['folder_id'] ?? '0').toString();&#10;                            final isExpanded = expandedFolderId == folderId;&#10;                            String folderName = (folder['folder_name'] ?? 'Unnamed Folder').toString();&#10;                            double fontSize = 15;&#10;                            final textPainter = TextPainter(&#10;                              text: TextSpan(text: folderName, style: TextStyle(fontSize: fontSize)),&#10;                              maxLines: 1,&#10;                              textDirection: TextDirection.ltr,&#10;                            );&#10;                            textPainter.layout(maxWidth: constraints.maxWidth - 48);&#10;                            while (textPainter.didExceedMaxLines &amp;&amp; fontSize &gt; 10) {&#10;                              fontSize -= 1;&#10;                              textPainter.text = TextSpan(text: folderName, style: TextStyle(fontSize: fontSize));&#10;                              textPainter.layout(maxWidth: constraints.maxWidth - 48);&#10;                            }&#10;                            return Row(&#10;                              children: [&#10;                                Expanded(&#10;                                  child: Dismissible(&#10;                                    key: ValueKey(folderId),&#10;                                    direction: folderId != '0' ? DismissDirection.endToStart : DismissDirection.none,&#10;                                    background: Container(&#10;                                      color: Colors.redAccent,&#10;                                      alignment: Alignment.centerRight,&#10;                                      padding: EdgeInsets.symmetric(horizontal: 20),&#10;                                      child: Icon(Icons.delete, color: Colors.white),&#10;                                    ),&#10;                                    confirmDismiss: folderId != '0'&#10;                                        ? (direction) async {&#10;                                            return await showDialog&lt;bool&gt;(&#10;                                              context: context,&#10;                                              builder: (context) =&gt; AlertDialog(&#10;                                                title: Text('Delete Folder'),&#10;                                                content: Text('Are you sure you want to delete the folder &quot;$folderName&quot;? All tasks in this folder will be moved to &quot;No Folder&quot;.'),&#10;                                                actions: [&#10;                                                  TextButton(&#10;                                                    onPressed: () =&gt; Navigator.of(context).pop(false),&#10;                                                    child: Text('Cancel'),&#10;                                                  ),&#10;                                                  ElevatedButton(&#10;                                                    onPressed: () =&gt; Navigator.of(context).pop(true),&#10;                                                    style: ElevatedButton.styleFrom(backgroundColor: Colors.redAccent),&#10;                                                    child: Text('Delete', style: TextStyle(color: Colors.white)),&#10;                                                  ),&#10;                                                ],&#10;                                              ),&#10;                                            );&#10;                                          }&#10;                                        : null,&#10;                                    onDismissed: (direction) {&#10;                                      setState(() {&#10;                                        for (final t in tasks) {&#10;                                          if (t.folderId == folderId) {&#10;                                            t.folderId = '0';&#10;                                          }&#10;                                        }&#10;                                        folders.removeWhere((f) =&gt; f['folder_id'] == folder['folder_id']);&#10;                                        if (expandedFolderId == folderId) expandedFolderId = null;&#10;                                      });&#10;                                    },&#10;                                    child: ListTile(&#10;                                      leading: Icon(&#10;                                        Icons.folder,&#10;                                        color: folderId == '0'&#10;                                            ? Colors.grey&#10;                                            : (folder['color'] != null &amp;&amp; folder['color'] is String &amp;&amp; (folder['color'] as String).startsWith('#')&#10;                                                ? Color(int.parse((folder['color'] as String).replaceFirst('#', '0xff')))&#10;                                                : Colors.redAccent),&#10;                                      ),&#10;                                      title: Text(&#10;                                        folderName,&#10;                                        style: TextStyle(fontSize: fontSize),&#10;                                        softWrap: true,&#10;                                        overflow: TextOverflow.visible,&#10;                                      ),&#10;                                      selected: isExpanded,&#10;                                      onTap: () {&#10;                                        onFolderSelected(isExpanded ? null : folderId);&#10;                                      },&#10;                                      onLongPress: folder['id'] != 0&#10;                                          ? () async {&#10;                                              final action = await showModalBottomSheet&lt;String&gt;(&#10;                                                context: context,&#10;                                                builder: (context) =&gt; SafeArea(&#10;                                                  child: Column(&#10;                                                    mainAxisSize: MainAxisSize.min,&#10;                                                    children: [&#10;                                                      ListTile(&#10;                                                        leading: Icon(Icons.edit),&#10;                                                        title: Text('Rename'),&#10;                                                        onTap: () =&gt; Navigator.of(context).pop('rename'),&#10;                                                      ),&#10;                                                      ListTile(&#10;                                                        leading: Icon(Icons.delete, color: Colors.redAccent),&#10;                                                        title: Text('Delete', style: TextStyle(color: Colors.redAccent)),&#10;                                                        onTap: () =&gt; Navigator.of(context).pop('delete'),&#10;                                                      ),&#10;                                                    ],&#10;                                                  ),&#10;                                                ),&#10;                                              );&#10;                                              if (action == 'rename') {&#10;                                                final controller = TextEditingController(text: folderName);&#10;                                                final newName = await showDialog&lt;String&gt;(&#10;                                                  context: context,&#10;                                                  builder: (context) =&gt; AlertDialog(&#10;                                                    title: Text('Rename Folder'),&#10;                                                    content: TextField(&#10;                                                      controller: controller,&#10;                                                      autofocus: true,&#10;                                                      decoration: InputDecoration(hintText: 'Folder name'),&#10;                                                    ),&#10;                                                    actions: [&#10;                                                      TextButton(&#10;                                                        onPressed: () =&gt; Navigator.of(context).pop(),&#10;                                                        child: Text('Cancel'),&#10;                                                      ),&#10;                                                      ElevatedButton(&#10;                                                        onPressed: () {&#10;                                                          if (controller.text.trim().isNotEmpty) {&#10;                                                            Navigator.of(context).pop(controller.text.trim());&#10;                                                          }&#10;                                                        },&#10;                                                        child: Text('Rename'),&#10;                                                      ),&#10;                                                    ],&#10;                                                  ),&#10;                                                );&#10;                                                if (newName != null &amp;&amp; newName.isNotEmpty &amp;&amp; newName != folderName) {&#10;                                                  setState(() {&#10;                                                    folder['name'] = newName;&#10;                                                  });&#10;                                                }&#10;                                              } else if (action == 'delete') {&#10;                                                final confirm = await showDialog&lt;bool&gt;(&#10;                                                  context: context,&#10;                                                  builder: (context) =&gt; AlertDialog(&#10;                                                    title: Text('Delete Folder'),&#10;                                                    content: Text('Are you sure you want to delete the folder &quot;$folderName&quot;? All tasks in this folder will be moved to &quot;No Folder&quot;.'),&#10;                                                    actions: [&#10;                                                      TextButton(&#10;                                                        onPressed: () =&gt; Navigator.of(context).pop(false),&#10;                                                        child: Text('Cancel'),&#10;                                                      ),&#10;                                                      ElevatedButton(&#10;                                                        onPressed: () =&gt; Navigator.of(context).pop(true),&#10;                                                        style: ElevatedButton.styleFrom(backgroundColor: Colors.redAccent),&#10;                                                        child: Text('Delete', style: TextStyle(color: Colors.white)),&#10;                                                      ),&#10;                                                    ],&#10;                                                  ),&#10;                                                );&#10;                                                if (confirm == true) {&#10;                                                  setState(() {&#10;                                                    for (final t in tasks) {&#10;                                                      if (t.folderId == folder['id'].toString()) {&#10;                                                        t.folderId = '0';&#10;                                                      }&#10;                                                    }&#10;                                                    folders.removeWhere((f) =&gt; f['id'] == folder['id']);&#10;                                                    if (expandedFolderId == folder['id']) expandedFolderId = null;&#10;                                                  });&#10;                                                }&#10;                                              }&#10;                                            }&#10;                                          : null,&#10;                                      trailing: Icon(isExpanded ? Icons.expand_less : Icons.expand_more),&#10;                                      contentPadding: EdgeInsets.symmetric(horizontal: 2, vertical: 0), // Reduced horizontal padding&#10;                                      minVerticalPadding: 0,&#10;                                      dense: true,&#10;                                    ),&#10;                                  ),&#10;                                ),&#10;                              ],&#10;                            );&#10;                          }).toList(),&#10;                        );&#10;                      },&#10;                    ),&#10;                  ),&#10;                ),&#10;                // Remove Spacer(), keep Add Task button at the bottom&#10;                Padding(&#10;                  padding: EdgeInsets.only(&#10;                    left: 8.0,&#10;                    right: 8.0,&#10;                    bottom: MediaQuery.of(context).viewPadding.bottom + 16, // Add extra space above system nav bar&#10;                    top: 8.0,&#10;                  ),&#10;                  child: ElevatedButton.icon(&#10;                    icon: Icon(Icons.add_task),&#10;                    label: Text('Add Task'),&#10;                    style: ElevatedButton.styleFrom(&#10;                      backgroundColor: Colors.redAccent,&#10;                      foregroundColor: Colors.white,&#10;                      minimumSize: Size(double.infinity, 40),&#10;                    ),&#10;                    onPressed: () async {&#10;                      await Navigator.of(context).push(&#10;                        MaterialPageRoute(&#10;                          builder: (context) =&gt; TaskForm(&#10;                            trainerId: widget.trainerId,&#10;                            onSubmit: (task) {&#10;                              onFolderSelected(expandedFolderId);&#10;                              Navigator.of(context).pop();&#10;                            },&#10;                          ),&#10;                        ),&#10;                      );&#10;                    },&#10;                  ),&#10;                ),&#10;              ],&#10;            ),&#10;          ),&#10;          // Main area for tasks in selected folder&#10;          Expanded(&#10;            child: Container(&#10;              color: Colors.grey[100],&#10;              child: expandedFolderId == null&#10;                  ? Center(child: Text('Select a folder to view tasks'))&#10;                  : AnimatedSwitcher(&#10;                      duration: Duration(milliseconds: 400),&#10;                      switchInCurve: Curves.easeOut,&#10;                      child: ListView.builder(&#10;                        key: ValueKey(expandedFolderId),&#10;                        padding: EdgeInsets.all(10),&#10;                        itemCount: expandedFolderId == '0'&#10;                            ? tasks.where((task) =&gt; task.folderId == null).length&#10;                            : tasks.where((task) =&gt; task.folderId == expandedFolderId?.toString()).length,&#10;                        itemBuilder: (context, idx) {&#10;                          final visibleTasks = expandedFolderId == '0'&#10;                              ? tasks.where((task) =&gt; task.folderId == null).toList()&#10;                              : tasks.where((task) =&gt; task.folderId == expandedFolderId?.toString()).toList();&#10;                          final task = visibleTasks[idx];&#10;                          return TweenAnimationBuilder&lt;Offset&gt;(&#10;                            tween: Tween&lt;Offset&gt;(&#10;                              begin: Offset(0, 0.3 + 0.1 * (visibleTasks.length - idx)),&#10;                              end: Offset.zero,&#10;                            ),&#10;                            duration: Duration(milliseconds: 350 + idx * 80),&#10;                            curve: Curves.easeOut,&#10;                            builder: (context, offset, child) {&#10;                              return Transform.translate(&#10;                                offset: Offset(0, offset.dy * 60),&#10;                                child: child,&#10;                              );&#10;                            },&#10;                            child: Card(&#10;                              child: Column(&#10;                                crossAxisAlignment: CrossAxisAlignment.stretch,&#10;                                children: [&#10;                                  if (task.highPriority == true)&#10;                                    Container(&#10;                                      color: Colors.red[700],&#10;                                      padding: EdgeInsets.symmetric(vertical: 6, horizontal: 16),&#10;                                      child: Row(&#10;                                        children: [&#10;                                          Icon(Icons.priority_high, color: Colors.white, size: 18),&#10;                                          SizedBox(width: 6),&#10;                                          Text(&#10;                                            'High Priority',&#10;                                            style: TextStyle(&#10;                                              color: Colors.white,&#10;                                              fontWeight: FontWeight.bold,&#10;                                              fontSize: 14,&#10;                                              letterSpacing: 1.1,&#10;                                            ),&#10;                                          ),&#10;                                        ],&#10;                                      ),&#10;                                    ),&#10;                                  if (task.to.isBefore(DateTime.now()))&#10;                                    Container(&#10;                                      color: Colors.orange[800],&#10;                                      padding: EdgeInsets.symmetric(vertical: 6, horizontal: 16),&#10;                                      child: Row(&#10;                                        children: [&#10;                                          Icon(Icons.warning_amber_rounded, color: Colors.white, size: 18),&#10;                                          SizedBox(width: 6),&#10;                                          Text(&#10;                                            'Past Deadline',&#10;                                            style: TextStyle(&#10;                                              color: Colors.white,&#10;                                              fontWeight: FontWeight.bold,&#10;                                              fontSize: 14,&#10;                                              letterSpacing: 1.1,&#10;                                            ),&#10;                                          ),&#10;                                        ],&#10;                                      ),&#10;                                    ),&#10;                                  SizedBox(&#10;                                    width: double.infinity,&#10;                                    child: InkWell(&#10;                                      onTap: () async {&#10;                                        await showDialog(&#10;                                          context: context,&#10;                                          builder: (context) =&gt; TaskDetailsCard(task: task),&#10;                                        );&#10;                                        setState(() {});&#10;                                      },&#10;                                      child: ListTile(&#10;                                        leading: Icon(&#10;                                          task.isCompleted ? Icons.check_circle : Icons.radio_button_unchecked,&#10;                                          color: task.isCompleted ? Colors.green : Colors.grey,&#10;                                        ),&#10;                                        title: Text(&#10;                                          task.eventName.replaceAll(' ', '\n'),&#10;                                          maxLines: 3,&#10;                                          overflow: TextOverflow.ellipsis,&#10;                                          style: TextStyle(fontSize: 18, height: 1.2),&#10;                                          softWrap: true,&#10;                                        ),&#10;                                        subtitle: Text(&#10;                                          task.notes,&#10;                                          maxLines: 5,&#10;                                          overflow: TextOverflow.ellipsis,&#10;                                          style: TextStyle(fontSize: 15),&#10;                                        ),&#10;                                        contentPadding: EdgeInsets.symmetric(horizontal: 24, vertical: 12),&#10;                                      ),&#10;                                    ),&#10;                                  ),&#10;                                ],&#10;                              ),&#10;                            ),&#10;                          );&#10;                        },&#10;                      ),&#10;                    ),&#10;            ),&#10;          ),&#10;        ],&#10;      ),&#10;    );&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lib/pages/pokebattle_page.dart">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lib/pages/pokebattle_page.dart" />
              <option name="originalContent" value="import 'package:flutter/material.dart';&#10;import '../mcts/pokebattle_controller.dart';&#10;import '../models/battle_game_state.dart';&#10;import '../models/pokemon_mcts.dart';&#10;import '../models/ability_mcts.dart';&#10;import '../mcts/mcts_search.dart'; // For direct MCTS call&#10;import 'package:animated_text_kit/animated_text_kit.dart';&#10;import '../services/music_service.dart';&#10;import '../services/xp_utils.dart';&#10;import '../services/ability_utils.dart';&#10;import 'package:supabase_flutter/supabase_flutter.dart';&#10;&#10;&#10;class PokeBattlePage extends StatefulWidget {&#10;  final String trainerId;&#10;  const PokeBattlePage({super.key, required this.trainerId});&#10;&#10;  @override&#10;  State&lt;PokeBattlePage&gt; createState() =&gt; _PokeBattlePageState();&#10;}&#10;&#10;class _PokeBattlePageState extends State&lt;PokeBattlePage&gt; {&#10;  late PokeBattleController? controller;&#10;  String? lastAiAction;&#10;  bool playerJustAttacked = false;&#10;  bool opponentJustAttacked = false;&#10;&#10;  String narration = &quot;&quot;;&#10;  bool isAnimating = false;&#10;&#10;  bool isMusicPlaying = true;&#10;&#10;  String selectedArena = &quot;&quot;;&#10;  String selectedArenaText = &quot;&quot;;&#10;  final List&lt;String&gt; arenaTypes = [&#10;    'desert', 'water', 'snow', 'hills', 'cave', 'beach', 'grass'&#10;  ];&#10;&#10;  final bool movesExpanded = true;&#10;&#10;  bool isLoading = true;&#10;&#10;  String? winnerTrainerName;&#10;&#10;  bool hasHandledBattleEnd = false;&#10;&#10;  String? playerTrainerName;&#10;  String? opponentTrainerName;&#10;  String? playerName;&#10;  String? opponentName;&#10;&#10;  @override&#10;  void initState() {&#10;    super.initState();&#10;    // Stop menu music before starting battle music&#10;    MusicService().stopMusic();&#10;    playBattleMusic();&#10;    isMusicPlaying = true;&#10;    controller = null;&#10;    _initTeams();&#10;  }&#10;&#10;  Future&lt;void&gt; _initTeams() async {&#10;    setState(() { isLoading = true; });&#10;    final supabase = Supabase.instance.client;&#10;    // Fetch player trainer row&#10;    final trainerRes = await supabase&#10;      .from('trainer_table')&#10;      .select()&#10;      .eq('trainer_id', widget.trainerId)&#10;      .maybeSingle(); // safer than .single()&#10;    if (trainerRes == null) {&#10;      setState(() { narration = &quot;Trainer not found.&quot;; isLoading = false; });&#10;      return;&#10;    }&#10;    playerTrainerName = trainerRes['username'] ?? 'You';&#10;    playerName = playerTrainerName;&#10;    // Get player team&#10;    final playerTeam = await _fetchTeamFromTrainerRow(trainerRes);&#10;    if (playerTeam.isEmpty) {&#10;      setState(() {&#10;        narration = &quot;You have no Pokmon in your team. Please add Pokmon before battling.&quot;;&#10;        isLoading = false;&#10;      });&#10;      return;&#10;    }&#10;    // Get random opponent trainer&#10;    final trainers = await supabase&#10;      .from('trainer_table')&#10;      .select('trainer_id,username');&#10;    final opponentIds = trainers.where((t) =&gt; t['trainer_id'] != widget.trainerId).toList();&#10;    opponentIds.shuffle();&#10;    final opponentId = opponentIds.isNotEmpty ? opponentIds.first['trainer_id'] : widget.trainerId;&#10;    final opponentRes = await supabase&#10;      .from('trainer_table')&#10;      .select()&#10;      .eq('trainer_id', opponentId)&#10;      .maybeSingle(); // safer than .single()&#10;    opponentTrainerName = opponentRes?['username'] ?? 'Opponent';&#10;    opponentName = opponentTrainerName;&#10;    final opponentTeam = await _fetchTeamFromTrainerRow(opponentRes ?? {});&#10;    if (opponentTeam.isEmpty) {&#10;      setState(() {&#10;        narration = &quot;Opponent has no Pokmon. Try again later.&quot;;&#10;        isLoading = false;&#10;      });&#10;      return;&#10;    }&#10;    // Setup battle state&#10;    final state = BattleGameState(&#10;      playerTeam: playerTeam,&#10;      opponentTeam: opponentTeam,&#10;    );&#10;    setState(() {&#10;      controller = PokeBattleController(gameState: state);&#10;      // Randomly select an arena type&#10;      final rand = arenaTypes..shuffle();&#10;      selectedArena = rand.first;&#10;      selectedArenaText = selectedArena[0].toUpperCase() + selectedArena.substring(1);&#10;      isLoading = false;&#10;    });&#10;  }&#10;&#10;  Future&lt;List&lt;Pokemon_mcts&gt;&gt; _fetchTeamFromTrainerRow(Map trainerRow) async {&#10;    final supabase = Supabase.instance.client;&#10;    List&lt;Pokemon_mcts&gt; team = [];&#10;    for (int i = 1; i &lt;= 6; i++) {&#10;      final slotKey = 'pokemon_slot_$i';&#10;      final pokeId = trainerRow[slotKey];&#10;      if (pokeId == null) continue;&#10;      final pokeRes = await supabase&#10;        .from('pokemon_table')&#10;        .select()&#10;        .eq('pokemon_id', pokeId)&#10;        .maybeSingle(); // safer than .single()&#10;      if (pokeRes == null) continue;&#10;      // Fetch abilities&#10;      List&lt;Ability_mcts&gt; abilities = [];&#10;      for (int j = 1; j &lt;= 4; j++) {&#10;        final abKey = 'ability$j';&#10;        final abId = pokeRes[abKey];&#10;        if (abId == null) continue;&#10;        final abRes = await supabase&#10;          .from('abilities_table')&#10;          .select()&#10;          .eq('ability_id', abId)&#10;          .maybeSingle(); // safer than .single()&#10;        if (abRes == null) continue;&#10;        abilities.add(Ability_mcts(&#10;          name: abRes['ability_name'],&#10;          type: abRes['type'],&#10;          maxUses: abRes['uses'],&#10;          hitRate: abRes['hitrate'],&#10;          value: abRes['value'],&#10;        ));&#10;      }&#10;      team.add(Pokemon_mcts(&#10;        pokemonName: pokeRes['pokemon_name'],&#10;        nickname: pokeRes['nickname'],&#10;        type: pokeRes['type'],&#10;        level: pokeRes['level'],&#10;        attack: pokeRes['attack'],&#10;        maxHealth: pokeRes['health'],&#10;        abilities: abilities,&#10;      ));&#10;    }&#10;    return team;&#10;  }&#10;&#10;  String getEffectivenessText(double multiplier) {&#10;    if (multiplier &gt;= 2.0) return &quot;It's super effective!&quot;;&#10;    if (multiplier &gt;= 1.1) return &quot;It's effective!&quot;;&#10;    if (multiplier &lt;= 0.5) return &quot;It's not very effective...&quot;;&#10;    return &quot;&quot;;&#10;  }&#10;&#10;&#10;&#10;  Future&lt;void&gt; _handleBattleEnd() async {&#10;    if (hasHandledBattleEnd) return;&#10;    hasHandledBattleEnd = true;&#10;    final supabase = Supabase.instance.client;&#10;    final isWin = controller!.getWinner() == 1;&#10;    final isLoss = controller!.getWinner() == -1;&#10;    if (!isWin &amp;&amp; !isLoss) return;&#10;    final trainerRes = await supabase&#10;      .from('trainer_table')&#10;      .select()&#10;      .eq('trainer_id', widget.trainerId)&#10;      .maybeSingle();&#10;    if (trainerRes == null) return;&#10;    // Always set username before using it&#10;    playerTrainerName = trainerRes['username'] ?? 'You';&#10;    playerName = playerTrainerName;&#10;    winnerTrainerName = isWin ? (playerName ?? 'You') : (opponentName ?? 'Opponent');&#10;    int wins = trainerRes['wins'] ?? 0;&#10;    int losses = trainerRes['losses'] ?? 0;&#10;    int xp = trainerRes['experience_points'] ?? 0;&#10;    int level = trainerRes['level'] ?? 1;&#10;    int gainedXp = isWin ? 250 : 100;&#10;    // Use battle context scaler (1.1) and base (100)&#10;    final trainerXpResult = calculateXpAndLevel(&#10;      currentXp: xp,&#10;      currentLevel: level,&#10;      xpChange: gainedXp,&#10;      scaler: 1.1,&#10;      base: 100,&#10;    );&#10;    xp = trainerXpResult.newXp;&#10;    level = trainerXpResult.newLevel;&#10;    bool trainerLeveledUp = trainerXpResult.levelsGained &gt; 0;&#10;    if (isWin) wins += 1;&#10;    if (isLoss) losses += 1;&#10;    await supabase&#10;      .from('trainer_table')&#10;      .update({&#10;        'wins': wins,&#10;        'losses': losses,&#10;        'experience_points': xp,&#10;        'level': level,&#10;      })&#10;      .eq('trainer_id', widget.trainerId);&#10;    List&lt;String&gt; pokemonLevelUps = [];&#10;    List&lt;Future&lt;void&gt;&gt; abilityDialogs = [];&#10;    Set&lt;String&gt; slotPokeIds = {};&#10;    for (int i = 1; i &lt;= 6; i++) {&#10;      final slotKey = 'pokemon_slot_$i';&#10;      final pokeId = trainerRes[slotKey];&#10;      if (pokeId == null) continue;&#10;      slotPokeIds.add(pokeId.toString());&#10;      final pokeRes = await supabase&#10;        .from('pokemon_table')&#10;        .select()&#10;        .eq('pokemon_id', pokeId)&#10;        .maybeSingle();&#10;      if (pokeRes == null) continue;&#10;      int pokeXp = pokeRes['experience_points'] ?? 0;&#10;      int pokeLevel = pokeRes['level'] ?? 1;&#10;      final pokeXpResult = calculateXpAndLevel(&#10;        currentXp: pokeXp,&#10;        currentLevel: pokeLevel,&#10;        xpChange: gainedXp,&#10;        scaler: 1.1,&#10;        base: 100,&#10;      );&#10;      if (pokeXpResult.levelsGained &gt; 0) {&#10;        var tempPoke = Pokemon_mcts(&#10;          pokemonName: pokeRes['pokemon_name'],&#10;          nickname: pokeRes['nickname'],&#10;          type: pokeRes['type'],&#10;          level: pokeLevel,&#10;          attack: pokeRes['attack'],&#10;          maxHealth: pokeRes['health'],&#10;          abilities: [],&#10;        );&#10;        for (int lvl = 0; lvl &lt; pokeXpResult.levelsGained; lvl++) {&#10;          tempPoke = tempPoke.levelUp();&#10;        }&#10;        String pokeName = pokeRes['nickname'] ?? pokeRes['pokemon_name'] ?? 'Pokmon';&#10;        pokemonLevelUps.add('$pokeName (Lv${pokeLevel}  ${pokeXpResult.newLevel})');&#10;        await supabase&#10;          .from('pokemon_table')&#10;          .update({&#10;            'experience_points': pokeXpResult.newXp,&#10;            'level': pokeXpResult.newLevel,&#10;            'health': tempPoke.maxHealth,&#10;            'attack': tempPoke.attack,&#10;          })&#10;          .eq('pokemon_id', pokeId);&#10;      } else {&#10;        await supabase&#10;          .from('pokemon_table')&#10;          .update({&#10;            'experience_points': pokeXpResult.newXp,&#10;            'level': pokeXpResult.newLevel,&#10;          })&#10;          .eq('pokemon_id', pokeId);&#10;      }&#10;      // Always fetch the latest ability IDs after level up&#10;      if (pokeXpResult.levelsGained &gt; 0 &amp;&amp; pokeXpResult.newLevel % 5 == 0) {&#10;        final updatedPokeRes = await supabase&#10;          .from('pokemon_table')&#10;          .select()&#10;          .eq('pokemon_id', pokeId)&#10;          .maybeSingle();&#10;        List&lt;String&gt; currentAbilityIds = [];&#10;        if (updatedPokeRes != null) {&#10;          for (int j = 1; j &lt;= 4; j++) {&#10;            final abId = updatedPokeRes['ability$j'];&#10;            if (abId != null) {&#10;              currentAbilityIds.add(abId.toString());&#10;            }&#10;          }&#10;        }&#10;        final newAbility = await fetchRandomAbilityExcluding(currentAbilityIds);&#10;        if (newAbility != null &amp;&amp; mounted) {&#10;          abilityDialogs.add(Future(() async {&#10;            await Future.delayed(const Duration(seconds: 2));&#10;            await offerAbilityDialog(&#10;              context: context,&#10;              ability: newAbility,&#10;              pokeId: pokeId,&#10;              currentAbilityIds: currentAbilityIds,&#10;            );&#10;          }));&#10;        }&#10;      }&#10;    }&#10;    // --- Favorite Pokmon XP logic ---&#10;    final favoritePokeId = trainerRes['favorite_pokemon'];&#10;    if (favoritePokeId != null) {&#10;      int totalXpChange = slotPokeIds.contains(favoritePokeId.toString()) ? gainedXp * 2 : gainedXp;&#10;      final pokeRes = await supabase&#10;        .from('pokemon_table')&#10;        .select()&#10;        .eq('pokemon_id', favoritePokeId)&#10;        .maybeSingle();&#10;      if (pokeRes != null) {&#10;        int pokeXp = pokeRes['experience_points'] ?? 0;&#10;        int pokeLevel = pokeRes['level'] ?? 1;&#10;        final pokeXpResult = calculateXpAndLevel(&#10;          currentXp: pokeXp,&#10;          currentLevel: pokeLevel,&#10;          xpChange: totalXpChange,&#10;          scaler: 1.1,&#10;          base: 100,&#10;        );&#10;        await supabase&#10;          .from('pokemon_table')&#10;          .update({&#10;            'experience_points': pokeXpResult.newXp,&#10;            'level': pokeXpResult.newLevel,&#10;          })&#10;          .eq('pokemon_id', favoritePokeId);&#10;      }&#10;    }&#10;    String msg = '';&#10;    if (trainerLeveledUp) {&#10;      msg += 'Trainer ${playerName ?? 'You'} leveled up!\n';&#10;      // Add a random Pokmon to the trainer's team and show dialog&#10;      final newPokeId = await addRandomPokemonToTrainer(widget.trainerId);&#10;      if (newPokeId != null) {&#10;        final pokeRes = await supabase&#10;          .from('pokemon_table')&#10;          .select()&#10;          .eq('pokemon_id', newPokeId)&#10;          .maybeSingle();&#10;        if (pokeRes != null &amp;&amp; mounted) {&#10;          await showNewPokemonDialog(context, pokeRes['pokemon_name'], pokeRes['type']);&#10;        }&#10;      }&#10;    }&#10;    if (pokemonLevelUps.isNotEmpty) {&#10;      msg += 'Pokmon leveled up: ${pokemonLevelUps.join(&quot;, &quot;)}!';&#10;    }&#10;    if (!mounted) return;&#10;    setState(() {&#10;      narration = &quot;${winnerTrainerName ?? 'Trainer'} wins!\n&quot; + msg;&#10;    });&#10;    if (pokemonLevelUps.isNotEmpty &amp;&amp; mounted) {&#10;      await showDialog(&#10;        context: context,&#10;        builder: (context) =&gt; AlertDialog(&#10;          title: const Text('Pokmon Leveled Up!'),&#10;          content: Text(pokemonLevelUps.join('\n')),&#10;          actions: [&#10;            TextButton(&#10;              onPressed: () =&gt; Navigator.of(context).pop(),&#10;              child: const Text('OK'),&#10;            ),&#10;          ],&#10;        ),&#10;      );&#10;    }&#10;    // Show ability dialogs (sequentially)&#10;    for (final dialog in abilityDialogs) {&#10;      await dialog;&#10;    }&#10;    await Future.delayed(const Duration(seconds: 2));&#10;    if (!mounted) return;&#10;    if (Navigator.canPop(context)) {&#10;      Navigator.of(context).pop('refresh');&#10;    }&#10;  }&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    if (isLoading || controller == null) {&#10;      return Scaffold(&#10;        appBar: AppBar(title: const Text(&quot;Pokmon Battle&quot;)),&#10;        body: Center(child: narration.isNotEmpty ? Text(narration, style: TextStyle(fontSize: 18, color: Colors.red)) : const CircularProgressIndicator()),&#10;      );&#10;    }&#10;    final activePlayer = controller!.state.getActive(true);&#10;    final activeOpponent = controller!.state.getActive(false);&#10;    if (controller!.isBattleOver) {&#10;      _handleBattleEnd();&#10;    }&#10;    return Scaffold(&#10;      appBar: AppBar(title: const Text(&quot;Pokmon Battle&quot;)),&#10;      backgroundColor: Colors.redAccent,&#10;      body: Container(&#10;        decoration: const BoxDecoration(&#10;          color: Colors.redAccent,&#10;        ),&#10;        child: controller!.isBattleOver&#10;            ? Center(&#10;                child: Text(&#10;                  // Show winnerTrainerName instead of &quot;You win!&quot;&#10;                  controller!.getWinner() == 1&#10;                      ? &quot;${winnerTrainerName ?? 'Trainer'} wins!&quot;&#10;                      : controller!.getWinner() == -1&#10;                          ? &quot;You lose!&quot;&#10;                          : &quot;Draw&quot;,&#10;                  style: const TextStyle(fontSize: 24),&#10;                ),&#10;              )&#10;            : Padding(&#10;                padding: const EdgeInsets.all(12.0),&#10;                child: SingleChildScrollView(&#10;                  child: Column(&#10;                    children: [&#10;                      Container(&#10;                        decoration: BoxDecoration(&#10;                          image: DecorationImage(&#10;                            image: AssetImage('assets/background/' + selectedArena + '-battle-background.jpg'),&#10;                            fit: BoxFit.cover,&#10;                          ),&#10;                          borderRadius: BorderRadius.circular(12),&#10;                        ),&#10;                        child: Column(&#10;                          children: [&#10;                            Container(&#10;                              child: Column(&#10;                                  children: [&#10;                                  Stack(&#10;                                    children:[&#10;                                      _buildPokemonCard(activeOpponent, isOpponent: true),&#10;                                      Row(&#10;                                        mainAxisAlignment: MainAxisAlignment.end,&#10;                                        children: [&#10;                                          IconButton(&#10;                                            icon: Icon(isMusicPlaying ? Icons.music_note : Icons.music_off),&#10;                                            tooltip: isMusicPlaying ? 'Pause Music' : 'Play Music',&#10;                                            onPressed: toggleMusic,&#10;                                          ),&#10;                                        ],&#10;                                      ),&#10;                                    ]&#10;                                  ),&#10;                                  // OPPONENT STATS&#10;&#10;                                  const SizedBox(height: 16),&#10;&#10;                                  // BATTLE ARENA&#10;                                  Stack(&#10;                                    children: [&#10;                                      SizedBox(&#10;                                        height: 140, // Set a fixed height for the battle arena&#10;                                        child: Center(&#10;                                          child: Column(&#10;                                            children: [&#10;                                              if (lastAiAction != null &amp;&amp; lastAiAction!.startsWith(&quot;switch_&quot;))&#10;                                                Text(&#10;                                                  &quot;AI switched to &quot;+activeOpponent.nickname+&quot;!&quot;,&#10;                                                  style: const TextStyle(&#10;                                                    color: Colors.deepOrange,&#10;                                                    fontWeight: FontWeight.bold,&#10;                                                  ),&#10;                                                ),&#10;                                              const SizedBox(height: 8),&#10;                                              Row( //  FIGHTING SCREEN&#10;                                                mainAxisAlignment: MainAxisAlignment.spaceAround,&#10;                                                children: [&#10;                                                  Flexible(&#10;                                                    fit: FlexFit.loose,&#10;                                                    child: FittedBox(&#10;                                                      fit: BoxFit.scaleDown,&#10;                                                      child: _buildAnimatedSprite(activePlayer, shake: opponentJustAttacked),&#10;                                                    ),&#10;                                                  ),&#10;                                                  Flexible(&#10;                                                    fit: FlexFit.loose,&#10;                                                    child: FittedBox(&#10;                                                      fit: BoxFit.scaleDown,&#10;                                                      child: _buildAnimatedSprite(activeOpponent, shake: playerJustAttacked),&#10;                                                    ),&#10;                                                  ),&#10;                                                ],&#10;                                              ),&#10;                                            ],&#10;                                          ),&#10;                                        ),&#10;                                      ),&#10;                                      if (isAnimating)&#10;                                        Padding(&#10;                                          padding: const EdgeInsets.symmetric(vertical: 8.0),&#10;                                          child: Container(&#10;                                            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),&#10;                                            decoration: BoxDecoration(&#10;                                              color: Colors.black.withOpacity(0.6),&#10;                                              borderRadius: BorderRadius.circular(10),&#10;                                            ),&#10;                                            child: Row(&#10;                                              mainAxisSize: MainAxisSize.min,&#10;                                              mainAxisAlignment: MainAxisAlignment.center,&#10;                                              children: const [&#10;                                                SizedBox(&#10;                                                  width: 20,&#10;                                                  height: 20,&#10;                                                  child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white),&#10;                                                ),&#10;                                                SizedBox(width: 12),&#10;                                                Text(&#10;                                                  &quot;AI is thinking...&quot;,&#10;                                                  style: TextStyle(color: Colors.white),&#10;                                                ),&#10;                                              ],&#10;                                            ),&#10;                                          ),&#10;                                        ),&#10;                                    ]&#10;                                  ),&#10;                                  // PLAYER STATS&#10;                                  _buildPokemonCard(activePlayer, isOpponent: false),&#10;&#10;                                ]&#10;                              )&#10;                            ), // battle space&#10;                          ],&#10;                        ),&#10;                      ),&#10;                      Container(&#10;                        color: Colors.redAccent,&#10;                        child: Column(&#10;                          children: [&#10;                            //MOVES AND OTHER STUFF&#10;                            const SizedBox(height: 8),&#10;&#10;                            const SizedBox(height: 8),&#10;                            Padding(&#10;                              padding: const EdgeInsets.symmetric(horizontal: 12.0),&#10;                              // NARRATION&#10;                              child: Container(&#10;                                width: double.infinity,&#10;                                padding: const EdgeInsets.all(12),&#10;                                decoration: BoxDecoration(&#10;                                  color: Colors.cyanAccent,&#10;                                  borderRadius: BorderRadius.circular(8),&#10;                                  border: Border.all(color: Colors.black54, width: 2),&#10;                                ),&#10;                                child: AnimatedTextKit(&#10;                                  key: ValueKey(narration), // ensures animation restarts on narration change&#10;                                  animatedTexts: [&#10;                                    TyperAnimatedText(&#10;                                      narration,&#10;                                      textStyle: const TextStyle(color: Colors.black54, fontSize: 16),&#10;                                      speed: const Duration(milliseconds: 35),&#10;                                    ),&#10;                                  ],&#10;                                  totalRepeatCount: 1,&#10;                                  pause: Duration.zero,&#10;                                  displayFullTextOnTap: true,&#10;                                  stopPauseOnTap: true,&#10;                                ),&#10;                              ),&#10;                            ),&#10;                            const SizedBox(height: 18),&#10;                            // ACTIONS&#10;                            Column(&#10;                              crossAxisAlignment: CrossAxisAlignment.stretch,&#10;                              children: [&#10;                                ExpansionTile(&#10;                                  title: const Text(&quot;Moves&quot;, style: TextStyle(fontWeight: FontWeight.bold)),&#10;                                  initiallyExpanded: movesExpanded,&#10;                                  children: [&#10;                                    Container(&#10;                                      margin: const EdgeInsets.only(bottom: 8),&#10;                                      padding: const EdgeInsets.all(8),&#10;                                      decoration: BoxDecoration(&#10;                                        border: Border.all(color: Colors.black26, width: 1),&#10;                                        borderRadius: BorderRadius.circular(8),&#10;                                      ),&#10;                                      child: Wrap(&#10;                                        spacing: 8,&#10;                                        runSpacing: 8,&#10;                                        children: controller!.getValidActions().where((action) =&gt; action.startsWith(&quot;move_&quot;)).map((action) {&#10;                                          final label = _getActionLabel(action);&#10;                                          String usesInfo = &quot;&quot;;&#10;                                          final player = controller!.state.getActive(true);&#10;                                          final index = int.tryParse(action.split(&quot;_&quot;)[1]) ?? 0;&#10;                                          if (index &gt;= 0 &amp;&amp; index &lt; player.abilities.length) {&#10;                                            final ability = player.abilities[index];&#10;                                            usesInfo = &quot; (${ability.remainingUses}/${ability.maxUses})&quot;;&#10;                                          }&#10;                                          return ElevatedButton(&#10;                                            onPressed: () =&gt; onPlayerAction(action),&#10;                                            child: Text(label + usesInfo),&#10;                                          );&#10;                                        }).toList(),&#10;                                      ),&#10;                                    ),&#10;                                  ],&#10;                                ),&#10;                                ExpansionTile(&#10;                                  title: const Text(&quot;Switch&quot;, style: TextStyle(fontWeight: FontWeight.bold)),&#10;                                  children: [&#10;                                    Container(&#10;                                      padding: const EdgeInsets.all(8),&#10;                                      decoration: BoxDecoration(&#10;                                        border: Border.all(color: Colors.black26, width: 1),&#10;                                        borderRadius: BorderRadius.circular(8),&#10;                                      ),&#10;                                      child: GridView.count(&#10;                                        crossAxisCount: 2,&#10;                                        shrinkWrap: true,&#10;                                        physics: const NeverScrollableScrollPhysics(),&#10;                                        childAspectRatio: 2.8,&#10;                                        mainAxisSpacing: 8,&#10;                                        crossAxisSpacing: 8,&#10;                                        children: controller!.getValidActions().where((action) =&gt; action.startsWith(&quot;switch_&quot;)).map((action) {&#10;                                          final label = _getActionLabel(action);&#10;                                          final team = controller!.state.playerTeam;&#10;                                          final index = int.tryParse(action.split(&quot;_&quot;)[1]) ?? 0;&#10;                                          String hpInfo = &quot;&quot;;&#10;                                          if (index &gt;= 0 &amp;&amp; index &lt; team.length) {&#10;                                            final poke = team[index];&#10;                                            hpInfo = &quot;  HP: ${poke.currentHealth}/${poke.maxHealth}&quot;;&#10;                                          }&#10;                                          return ElevatedButton(&#10;                                            onPressed: () =&gt; onPlayerAction(action),&#10;                                            child: Text(label + hpInfo),&#10;                                          );&#10;                                        }).toList(),&#10;                                      ),&#10;                                    ),&#10;                                  ],&#10;                                ),&#10;                              ],&#10;                            ),&#10;&#10;&#10;                            const SizedBox(height: 16),&#10;                          ]&#10;                        )&#10;                      ),&#10;                    ],&#10;                  ),&#10;                ),&#10;              ),&#10;            ),&#10;    );&#10;  }&#10;  String _getActionLabel(String action) {&#10;    final player = controller!.state.getActive(true);&#10;    final team = controller!.state.playerTeam;&#10;&#10;    if (action.startsWith(&quot;move_&quot;)) {&#10;      final index = int.tryParse(action.split(&quot;_&quot;)[1]) ?? 0;&#10;      if (index &gt;= 0 &amp;&amp; index &lt; player.abilities.length) {&#10;        return player.abilities[index].name;&#10;      } else {&#10;        return &quot;Unknown Move&quot;;&#10;      }&#10;    } else if (action.startsWith(&quot;switch_&quot;)) {&#10;      final index = int.tryParse(action.split(&quot;_&quot;)[1]) ?? 0;&#10;      if (index &gt;= 0 &amp;&amp; index &lt; team.length) {&#10;        return team[index].nickname;&#10;      } else {&#10;        return &quot;Unknown Switch&quot;;&#10;      }&#10;    }&#10;&#10;    return action;&#10;  }&#10;&#10;&#10;  Widget _buildPokemonCard(Pokemon_mcts p, {required bool isOpponent}) {&#10;    return Card(&#10;      elevation: 2,&#10;      color: p.isFainted ? Colors.grey[200] : (isOpponent ? Colors.red[100] : Colors.blue[100]),&#10;      child: Padding(&#10;        padding: const EdgeInsets.all(12.0),&#10;        child: Column(&#10;          crossAxisAlignment: CrossAxisAlignment.start,&#10;          children: [&#10;            Text(&quot;${p.nickname} (${p.pokemonName})&quot;,&#10;                style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),&#10;            const SizedBox(height: 4),&#10;            Row(&#10;              children: [&#10;                Text(&quot;HP: ${p.currentHealth}/${p.maxHealth}&quot;),&#10;                const SizedBox(width: 16),&#10;                Text(&quot;Type: ${p.type}&quot;),&#10;              ],&#10;            ),&#10;            const SizedBox(height: 4),&#10;            AnimatedHPBar(current: p.currentHealth, max: p.maxHealth),&#10;          ],&#10;        ),&#10;      ),&#10;      );&#10;  }&#10;&#10;  Widget _buildAnimatedSprite(Pokemon_mcts p, {bool shake = false}) {&#10;    final spritePath = 'assets/sprites/${p.pokemonName.toLowerCase()}.png';&#10;&#10;    return TweenAnimationBuilder&lt;Offset&gt;(&#10;      key: ValueKey(p.nickname + p.currentHealth.toString()),&#10;      tween: Tween&lt;Offset&gt;(&#10;        begin: Offset.zero,&#10;        end: shake ? const Offset(0.05, 0) : Offset.zero,&#10;      ),&#10;      duration: const Duration(milliseconds: 150),&#10;      curve: Curves.elasticIn,&#10;      builder: (context, value, _) {&#10;        return Transform.translate(&#10;          offset: Offset(value.dx * 10, 0),&#10;          child: Stack(&#10;            children: [&#10;              Image.asset(&#10;                spritePath,&#10;                width: 96,&#10;                height: 96,&#10;                errorBuilder: (context, error, stack) =&gt; const Icon(Icons.error),&#10;              ),&#10;              if (shake)&#10;                Positioned.fill(&#10;                  child: ColoredBox(&#10;                    color: Colors.white.withOpacity(0.5),&#10;                  ),&#10;                ),&#10;            ],&#10;          ),&#10;        );&#10;      },&#10;    );&#10;  }&#10;&#10;&#10;  String getAbilityName(String action, bool isPlayer) {&#10;    if (!action.startsWith(&quot;move_&quot;)) return &quot;&quot;;&#10;    final index = int.parse(action.split(&quot;_&quot;)[1]);&#10;    final p = controller!.state.getActive(isPlayer);&#10;    return p.abilities[index].name;&#10;  }&#10;&#10;&#10;  Future&lt;void&gt; playTurnAnimationSequence(String playerAction) async {&#10;    setState(() {&#10;      playerJustAttacked = playerAction.startsWith(&quot;move_&quot;);&#10;      opponentJustAttacked = false;&#10;      narration = &quot;You used ${getAbilityName(playerAction, true)}!&quot;;&#10;      isAnimating = true;&#10;    });&#10;&#10;    // Pause to show player attack + shake&#10;    await Future.delayed(const Duration(milliseconds: 500));&#10;&#10;    setState(() {&#10;      controller!.applyPlayerAction(playerAction);&#10;      // After controller.applyPlayerAction(playerAction);&#10;      final effectiveness = controller!.lastEffectiveness;&#10;      final feedback = getEffectivenessText(effectiveness);&#10;&#10;      setState(() {&#10;        narration += &quot;\n$feedback&quot;;&#10;      });&#10;&#10;    });&#10;&#10;    if (!controller!.isBattleOver) {&#10;      final aiAction = runMCTS(controller!.state, 100);&#10;      final isSwitch = aiAction.startsWith(&quot;switch_&quot;);&#10;      final aiUsed = isSwitch&#10;          ? &quot;AI switched to ${controller!.state.getActive(false).nickname}!&quot;&#10;          : &quot;Enemy used ${getAbilityName(aiAction, false)}!&quot;;&#10;&#10;      await Future.delayed(const Duration(milliseconds: 300));&#10;&#10;      setState(() {&#10;        narration = aiUsed;&#10;        opponentJustAttacked = !isSwitch;&#10;      });&#10;&#10;      await Future.delayed(const Duration(milliseconds: 500));&#10;&#10;      setState(() {&#10;        controller!.state.applyAction(aiAction);&#10;        isAnimating = false;&#10;      });&#10;    } else {&#10;      setState(() {&#10;        isAnimating = false;&#10;      });&#10;    }&#10;  }&#10;&#10;  void playBattleMusic() {&#10;    MusicService().playMusic('music/battle_music.mp3');&#10;  }&#10;&#10;  void toggleMusic() {&#10;    setState(() {&#10;      isMusicPlaying = !isMusicPlaying;&#10;      if (isMusicPlaying) {&#10;        MusicService().playMusic('music/battle_music.mp3');&#10;      } else {&#10;        MusicService().stopMusic();&#10;      }&#10;    });&#10;  }&#10;&#10;  void onPlayerAction(String action) {&#10;    playTurnAnimationSequence(action);&#10;  }&#10;&#10;&#10;  @override&#10;  void dispose() {&#10;    // Stop battle music and resume menu music when leaving the page&#10;    MusicService().stopMusic(); // Stop battle music&#10;    MusicService().playMusic('music/menu_music.mp3'); // Resume menu music&#10;    super.dispose();&#10;  }&#10;}&#10;class AnimatedHPBar extends StatelessWidget {&#10;  final int current;&#10;  final int max;&#10;&#10;  const AnimatedHPBar({super.key, required this.current, required this.max});&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    final ratio = current / max;&#10;    final color = ratio &gt; 0.5&#10;        ? Colors.green&#10;        : ratio &gt; 0.2&#10;        ? Colors.orange&#10;        : Colors.red;&#10;&#10;    return TweenAnimationBuilder&lt;double&gt;(&#10;      tween: Tween&lt;double&gt;(begin: 0, end: ratio),&#10;      duration: const Duration(milliseconds: 500),&#10;      builder: (context, value, _) {&#10;        return SizedBox(&#10;          width: 170, // or MediaQuery.of(context).size.width * 0.4 for responsive&#10;          child: ClipRRect(&#10;            borderRadius: BorderRadius.circular(6),&#10;            child: LinearProgressIndicator(&#10;              value: value,&#10;              backgroundColor: Colors.grey[300],&#10;              color: color,&#10;              minHeight: 12,&#10;            ),&#10;          ),&#10;        );&#10;      },&#10;    );&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import 'package:flutter/material.dart';&#10;import '../mcts/pokebattle_controller.dart';&#10;import '../models/battle_game_state.dart';&#10;import '../models/pokemon_mcts.dart';&#10;import '../models/ability_mcts.dart';&#10;import '../mcts/mcts_search.dart'; // For direct MCTS call&#10;import 'package:animated_text_kit/animated_text_kit.dart';&#10;import '../services/music_service.dart';&#10;import '../services/xp_utils.dart';&#10;import '../services/ability_utils.dart';&#10;import 'package:supabase_flutter/supabase_flutter.dart';&#10;&#10;&#10;class PokeBattlePage extends StatefulWidget {&#10;  final String trainerId;&#10;  const PokeBattlePage({super.key, required this.trainerId});&#10;&#10;  @override&#10;  State&lt;PokeBattlePage&gt; createState() =&gt; _PokeBattlePageState();&#10;}&#10;&#10;class _PokeBattlePageState extends State&lt;PokeBattlePage&gt; {&#10;  late PokeBattleController? controller;&#10;  String? lastAiAction;&#10;  bool playerJustAttacked = false;&#10;  bool opponentJustAttacked = false;&#10;&#10;  String narration = &quot;&quot;;&#10;  bool isAnimating = false;&#10;&#10;  bool isMusicPlaying = true;&#10;&#10;  String selectedArena = &quot;&quot;;&#10;  String selectedArenaText = &quot;&quot;;&#10;  final List&lt;String&gt; arenaTypes = [&#10;    'desert', 'water', 'snow', 'hills', 'cave', 'beach', 'grass'&#10;  ];&#10;&#10;  final bool movesExpanded = true;&#10;&#10;  bool isLoading = true;&#10;&#10;  String? winnerTrainerName;&#10;&#10;  bool hasHandledBattleEnd = false;&#10;&#10;  String? playerTrainerName;&#10;  String? opponentTrainerName;&#10;  String? playerName;&#10;  String? opponentName;&#10;&#10;  @override&#10;  void initState() {&#10;    super.initState();&#10;    // Stop menu music before starting battle music&#10;    MusicService().stopMusic();&#10;    playBattleMusic();&#10;    isMusicPlaying = true;&#10;    controller = null;&#10;    _initTeams();&#10;  }&#10;&#10;  Future&lt;void&gt; _initTeams() async {&#10;    setState(() { isLoading = true; });&#10;    final supabase = Supabase.instance.client;&#10;    // Fetch player trainer row&#10;    final trainerRes = await supabase&#10;      .from('trainer_table')&#10;      .select()&#10;      .eq('trainer_id', widget.trainerId)&#10;      .maybeSingle(); // safer than .single()&#10;    if (trainerRes == null) {&#10;      setState(() { narration = &quot;Trainer not found.&quot;; isLoading = false; });&#10;      return;&#10;    }&#10;    playerTrainerName = trainerRes['username'] ?? 'You';&#10;    playerName = playerTrainerName;&#10;    // Get player team&#10;    final playerTeam = await _fetchTeamFromTrainerRow(trainerRes);&#10;    if (playerTeam.isEmpty) {&#10;      setState(() {&#10;        narration = &quot;You have no Pokmon in your team. Please add Pokmon before battling.&quot;;&#10;        isLoading = false;&#10;      });&#10;      return;&#10;    }&#10;    // Get random opponent trainer&#10;    final trainers = await supabase&#10;      .from('trainer_table')&#10;      .select('trainer_id,username');&#10;    final opponentIds = trainers.where((t) =&gt; t['trainer_id'] != widget.trainerId).toList();&#10;    opponentIds.shuffle();&#10;    final opponentId = opponentIds.isNotEmpty ? opponentIds.first['trainer_id'] : widget.trainerId;&#10;    final opponentRes = await supabase&#10;      .from('trainer_table')&#10;      .select()&#10;      .eq('trainer_id', opponentId)&#10;      .maybeSingle(); // safer than .single()&#10;    opponentTrainerName = opponentRes?['username'] ?? 'Opponent';&#10;    opponentName = opponentTrainerName;&#10;    final opponentTeam = await _fetchTeamFromTrainerRow(opponentRes ?? {});&#10;    if (opponentTeam.isEmpty) {&#10;      setState(() {&#10;        narration = &quot;Opponent has no Pokmon. Try again later.&quot;;&#10;        isLoading = false;&#10;      });&#10;      return;&#10;    }&#10;    // Setup battle state&#10;    final state = BattleGameState(&#10;      playerTeam: playerTeam,&#10;      opponentTeam: opponentTeam,&#10;    );&#10;    setState(() {&#10;      controller = PokeBattleController(gameState: state);&#10;      // Randomly select an arena type&#10;      final rand = arenaTypes..shuffle();&#10;      selectedArena = rand.first;&#10;      selectedArenaText = selectedArena[0].toUpperCase() + selectedArena.substring(1);&#10;      isLoading = false;&#10;    });&#10;  }&#10;&#10;  Future&lt;List&lt;Pokemon_mcts&gt;&gt; _fetchTeamFromTrainerRow(Map trainerRow) async {&#10;    final supabase = Supabase.instance.client;&#10;    List&lt;Pokemon_mcts&gt; team = [];&#10;    for (int i = 1; i &lt;= 6; i++) {&#10;      final slotKey = 'pokemon_slot_$i';&#10;      final pokeId = trainerRow[slotKey];&#10;      if (pokeId == null) continue;&#10;      final pokeRes = await supabase&#10;        .from('pokemon_table')&#10;        .select()&#10;        .eq('pokemon_id', pokeId)&#10;        .maybeSingle(); // safer than .single()&#10;      if (pokeRes == null) continue;&#10;      // Fetch abilities&#10;      List&lt;Ability_mcts&gt; abilities = [];&#10;      for (int j = 1; j &lt;= 4; j++) {&#10;        final abKey = 'ability$j';&#10;        final abId = pokeRes[abKey];&#10;        if (abId == null) continue;&#10;        final abRes = await supabase&#10;          .from('abilities_table')&#10;          .select()&#10;          .eq('ability_id', abId)&#10;          .maybeSingle(); // safer than .single()&#10;        if (abRes == null) continue;&#10;        abilities.add(Ability_mcts(&#10;          name: abRes['ability_name'],&#10;          type: abRes['type'],&#10;          maxUses: abRes['uses'],&#10;          hitRate: abRes['hitrate'],&#10;          value: abRes['value'],&#10;        ));&#10;      }&#10;      team.add(Pokemon_mcts(&#10;        pokemonName: pokeRes['pokemon_name'],&#10;        nickname: pokeRes['nickname'],&#10;        type: pokeRes['type'],&#10;        level: pokeRes['level'],&#10;        attack: pokeRes['attack'],&#10;        maxHealth: pokeRes['health'],&#10;        abilities: abilities,&#10;      ));&#10;    }&#10;    return team;&#10;  }&#10;&#10;  String getEffectivenessText(double multiplier) {&#10;    if (multiplier &gt;= 2.0) return &quot;It's super effective!&quot;;&#10;    if (multiplier &gt;= 1.1) return &quot;It's effective!&quot;;&#10;    if (multiplier &lt;= 0.5) return &quot;It's not very effective...&quot;;&#10;    return &quot;&quot;;&#10;  }&#10;&#10;&#10;&#10;  Future&lt;void&gt; _handleBattleEnd() async {&#10;    if (hasHandledBattleEnd) return;&#10;    hasHandledBattleEnd = true;&#10;    final supabase = Supabase.instance.client;&#10;    final isWin = controller!.getWinner() == 1;&#10;    final isLoss = controller!.getWinner() == -1;&#10;    if (!isWin &amp;&amp; !isLoss) return;&#10;    final trainerRes = await supabase&#10;      .from('trainer_table')&#10;      .select()&#10;      .eq('trainer_id', widget.trainerId)&#10;      .maybeSingle();&#10;    if (trainerRes == null) return;&#10;    // Always set username before using it&#10;    playerTrainerName = trainerRes['username'] ?? 'You';&#10;    playerName = playerTrainerName;&#10;    winnerTrainerName = isWin ? (playerName ?? 'You') : (opponentName ?? 'Opponent');&#10;    int wins = trainerRes['wins'] ?? 0;&#10;    int losses = trainerRes['losses'] ?? 0;&#10;    int xp = trainerRes['experience_points'] ?? 0;&#10;    int level = trainerRes['level'] ?? 1;&#10;    int gainedXp = isWin ? 250 : 100;&#10;    // Use battle context scaler (1.1) and base (100)&#10;    final trainerXpResult = calculateXpAndLevel(&#10;      currentXp: xp,&#10;      currentLevel: level,&#10;      xpChange: gainedXp,&#10;      scaler: 1.1,&#10;      base: 100,&#10;    );&#10;    xp = trainerXpResult.newXp;&#10;    level = trainerXpResult.newLevel;&#10;    bool trainerLeveledUp = trainerXpResult.levelsGained &gt; 0;&#10;    if (isWin) wins += 1;&#10;    if (isLoss) losses += 1;&#10;    await supabase&#10;      .from('trainer_table')&#10;      .update({&#10;        'wins': wins,&#10;        'losses': losses,&#10;        'experience_points': xp,&#10;        'level': level,&#10;      })&#10;      .eq('trainer_id', widget.trainerId);&#10;    List&lt;String&gt; pokemonLevelUps = [];&#10;    List&lt;Future&lt;void&gt;&gt; abilityDialogs = [];&#10;    Set&lt;String&gt; slotPokeIds = {};&#10;    for (int i = 1; i &lt;= 6; i++) {&#10;      final slotKey = 'pokemon_slot_$i';&#10;      final pokeId = trainerRes[slotKey];&#10;      if (pokeId == null) continue;&#10;      slotPokeIds.add(pokeId.toString());&#10;      final pokeRes = await supabase&#10;        .from('pokemon_table')&#10;        .select()&#10;        .eq('pokemon_id', pokeId)&#10;        .maybeSingle();&#10;      if (pokeRes == null) continue;&#10;      int pokeXp = pokeRes['experience_points'] ?? 0;&#10;      int pokeLevel = pokeRes['level'] ?? 1;&#10;      final pokeXpResult = calculateXpAndLevel(&#10;        currentXp: pokeXp,&#10;        currentLevel: pokeLevel,&#10;        xpChange: gainedXp,&#10;        scaler: 1.1,&#10;        base: 100,&#10;      );&#10;      if (pokeXpResult.levelsGained &gt; 0) {&#10;        var tempPoke = Pokemon_mcts(&#10;          pokemonName: pokeRes['pokemon_name'],&#10;          nickname: pokeRes['nickname'],&#10;          type: pokeRes['type'],&#10;          level: pokeLevel,&#10;          attack: pokeRes['attack'],&#10;          maxHealth: pokeRes['health'],&#10;          abilities: [],&#10;        );&#10;        for (int lvl = 0; lvl &lt; pokeXpResult.levelsGained; lvl++) {&#10;          tempPoke = tempPoke.levelUp();&#10;        }&#10;        String pokeName = pokeRes['nickname'] ?? pokeRes['pokemon_name'] ?? 'Pokmon';&#10;        pokemonLevelUps.add('$pokeName (Lv${pokeLevel}  ${pokeXpResult.newLevel})');&#10;        await supabase&#10;          .from('pokemon_table')&#10;          .update({&#10;            'experience_points': pokeXpResult.newXp,&#10;            'level': pokeXpResult.newLevel,&#10;            'health': tempPoke.maxHealth,&#10;            'attack': tempPoke.attack,&#10;          })&#10;          .eq('pokemon_id', pokeId);&#10;      } else {&#10;        await supabase&#10;          .from('pokemon_table')&#10;          .update({&#10;            'experience_points': pokeXpResult.newXp,&#10;            'level': pokeXpResult.newLevel,&#10;          })&#10;          .eq('pokemon_id', pokeId);&#10;      }&#10;      // Always fetch the latest ability IDs after level up&#10;      if (pokeXpResult.levelsGained &gt; 0 &amp;&amp; pokeXpResult.newLevel % 5 == 0) {&#10;        final updatedPokeRes = await supabase&#10;          .from('pokemon_table')&#10;          .select()&#10;          .eq('pokemon_id', pokeId)&#10;          .maybeSingle();&#10;        List&lt;String&gt; currentAbilityIds = [];&#10;        if (updatedPokeRes != null) {&#10;          for (int j = 1; j &lt;= 4; j++) {&#10;            final abId = updatedPokeRes['ability$j'];&#10;            if (abId != null) {&#10;              currentAbilityIds.add(abId.toString());&#10;            }&#10;          }&#10;        }&#10;        final newAbility = await fetchRandomAbilityExcluding(currentAbilityIds);&#10;        if (newAbility != null &amp;&amp; mounted) {&#10;          // Show ability dialog and wait for user action before continuing&#10;          await offerAbilityDialog(&#10;            context: context,&#10;            ability: newAbility,&#10;            pokeId: pokeId,&#10;            currentAbilityIds: currentAbilityIds,&#10;          );&#10;        }&#10;      }&#10;    }&#10;    // --- Favorite Pokmon XP logic ---&#10;    final favoritePokeId = trainerRes['favorite_pokemon'];&#10;    if (favoritePokeId != null) {&#10;      int totalXpChange = slotPokeIds.contains(favoritePokeId.toString()) ? gainedXp * 2 : gainedXp;&#10;      final pokeRes = await supabase&#10;        .from('pokemon_table')&#10;        .select()&#10;        .eq('pokemon_id', favoritePokeId)&#10;        .maybeSingle();&#10;      if (pokeRes != null) {&#10;        int pokeXp = pokeRes['experience_points'] ?? 0;&#10;        int pokeLevel = pokeRes['level'] ?? 1;&#10;        final pokeXpResult = calculateXpAndLevel(&#10;          currentXp: pokeXp,&#10;          currentLevel: pokeLevel,&#10;          xpChange: totalXpChange,&#10;          scaler: 1.1,&#10;          base: 100,&#10;        );&#10;        await supabase&#10;          .from('pokemon_table')&#10;          .update({&#10;            'experience_points': pokeXpResult.newXp,&#10;            'level': pokeXpResult.newLevel,&#10;          })&#10;          .eq('pokemon_id', favoritePokeId);&#10;        // --- Offer ability if favorite leveled up to a multiple of 5 ---&#10;        if (pokeXpResult.levelsGained &gt; 0 &amp;&amp; pokeXpResult.newLevel % 5 == 0) {&#10;          List&lt;String&gt; currentAbilityIds = [];&#10;          for (int j = 1; j &lt;= 4; j++) {&#10;            final abId = pokeRes['ability$j'];&#10;            if (abId != null) currentAbilityIds.add(abId.toString());&#10;          }&#10;          final newAbility = await fetchRandomAbilityExcluding(currentAbilityIds);&#10;          if (newAbility != null &amp;&amp; mounted) {&#10;            await Future.delayed(const Duration(seconds: 2));&#10;            await offerAbilityDialog(&#10;              context: context,&#10;              ability: newAbility,&#10;              pokeId: favoritePokeId.toString(),&#10;              currentAbilityIds: currentAbilityIds,&#10;            );&#10;          }&#10;        }&#10;      }&#10;    }&#10;    String msg = '';&#10;    if (trainerLeveledUp) {&#10;      msg += 'Trainer ${playerName ?? 'You'} leveled up!\n';&#10;      // Add a random Pokmon to the trainer's team and show dialog&#10;      final newPokeId = await addRandomPokemonToTrainer(widget.trainerId);&#10;      if (newPokeId != null) {&#10;        final pokeRes = await supabase&#10;          .from('pokemon_table')&#10;          .select()&#10;          .eq('pokemon_id', newPokeId)&#10;          .maybeSingle();&#10;        if (pokeRes != null &amp;&amp; mounted) {&#10;          await showNewPokemonDialog(context, pokeRes['pokemon_name'], pokeRes['type']);&#10;        }&#10;      }&#10;    }&#10;    if (pokemonLevelUps.isNotEmpty) {&#10;      msg += 'Pokmon leveled up: ${pokemonLevelUps.join(&quot;, &quot;)}!';&#10;    }&#10;    if (!mounted) return;&#10;    setState(() {&#10;      narration = &quot;${winnerTrainerName ?? 'Trainer'} wins!\n&quot; + msg;&#10;    });&#10;    if (pokemonLevelUps.isNotEmpty &amp;&amp; mounted) {&#10;      await showDialog(&#10;        context: context,&#10;        builder: (context) =&gt; AlertDialog(&#10;          title: const Text('Pokmon Leveled Up!'),&#10;          content: Text(pokemonLevelUps.join('\n')),&#10;          actions: [&#10;            TextButton(&#10;              onPressed: () =&gt; Navigator.of(context).pop(),&#10;              child: const Text('OK'),&#10;            ),&#10;          ],&#10;        ),&#10;      );&#10;    }&#10;    await Future.delayed(const Duration(seconds: 2));&#10;    if (!mounted) return;&#10;    if (Navigator.canPop(context)) {&#10;      Navigator.of(context).pop('refresh');&#10;    }&#10;  }&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    if (isLoading || controller == null) {&#10;      return Scaffold(&#10;        appBar: AppBar(title: const Text(&quot;Pokmon Battle&quot;)),&#10;        body: Center(child: narration.isNotEmpty ? Text(narration, style: TextStyle(fontSize: 18, color: Colors.red)) : const CircularProgressIndicator()),&#10;      );&#10;    }&#10;    final activePlayer = controller!.state.getActive(true);&#10;    final activeOpponent = controller!.state.getActive(false);&#10;    if (controller!.isBattleOver) {&#10;      _handleBattleEnd();&#10;    }&#10;    return Scaffold(&#10;      appBar: AppBar(title: const Text(&quot;Pokmon Battle&quot;)),&#10;      backgroundColor: Colors.redAccent,&#10;      body: Container(&#10;        decoration: const BoxDecoration(&#10;          color: Colors.redAccent,&#10;        ),&#10;        child: controller!.isBattleOver&#10;            ? Center(&#10;                child: Text(&#10;                  // Show winnerTrainerName instead of &quot;You win!&quot;&#10;                  controller!.getWinner() == 1&#10;                      ? &quot;${winnerTrainerName ?? 'Trainer'} wins!&quot;&#10;                      : controller!.getWinner() == -1&#10;                          ? &quot;You lose!&quot;&#10;                          : &quot;Draw&quot;,&#10;                  style: const TextStyle(fontSize: 24),&#10;                ),&#10;              )&#10;            : Padding(&#10;                padding: const EdgeInsets.all(12.0),&#10;                child: SingleChildScrollView(&#10;                  child: Column(&#10;                    children: [&#10;                      Container(&#10;                        decoration: BoxDecoration(&#10;                          image: DecorationImage(&#10;                            image: AssetImage('assets/background/' + selectedArena + '-battle-background.jpg'),&#10;                            fit: BoxFit.cover,&#10;                          ),&#10;                          borderRadius: BorderRadius.circular(12),&#10;                        ),&#10;                        child: Column(&#10;                          children: [&#10;                            Container(&#10;                              child: Column(&#10;                                  children: [&#10;                                  Stack(&#10;                                    children:[&#10;                                      _buildPokemonCard(activeOpponent, isOpponent: true),&#10;                                      Row(&#10;                                        mainAxisAlignment: MainAxisAlignment.end,&#10;                                        children: [&#10;                                          IconButton(&#10;                                            icon: Icon(isMusicPlaying ? Icons.music_note : Icons.music_off),&#10;                                            tooltip: isMusicPlaying ? 'Pause Music' : 'Play Music',&#10;                                            onPressed: toggleMusic,&#10;                                          ),&#10;                                        ],&#10;                                      ),&#10;                                    ]&#10;                                  ),&#10;                                  // OPPONENT STATS&#10;&#10;                                  const SizedBox(height: 16),&#10;&#10;                                  // BATTLE ARENA&#10;                                  Stack(&#10;                                    children: [&#10;                                      SizedBox(&#10;                                        height: 140, // Set a fixed height for the battle arena&#10;                                        child: Center(&#10;                                          child: Column(&#10;                                            children: [&#10;                                              if (lastAiAction != null &amp;&amp; lastAiAction!.startsWith(&quot;switch_&quot;))&#10;                                                Text(&#10;                                                  &quot;AI switched to &quot;+activeOpponent.nickname+&quot;!&quot;,&#10;                                                  style: const TextStyle(&#10;                                                    color: Colors.deepOrange,&#10;                                                    fontWeight: FontWeight.bold,&#10;                                                  ),&#10;                                                ),&#10;                                              const SizedBox(height: 8),&#10;                                              Row( //  FIGHTING SCREEN&#10;                                                mainAxisAlignment: MainAxisAlignment.spaceAround,&#10;                                                children: [&#10;                                                  Flexible(&#10;                                                    fit: FlexFit.loose,&#10;                                                    child: FittedBox(&#10;                                                      fit: BoxFit.scaleDown,&#10;                                                      child: _buildAnimatedSprite(activePlayer, shake: opponentJustAttacked),&#10;                                                    ),&#10;                                                  ),&#10;                                                  Flexible(&#10;                                                    fit: FlexFit.loose,&#10;                                                    child: FittedBox(&#10;                                                      fit: BoxFit.scaleDown,&#10;                                                      child: _buildAnimatedSprite(activeOpponent, shake: playerJustAttacked),&#10;                                                    ),&#10;                                                  ),&#10;                                                ],&#10;                                              ),&#10;                                            ],&#10;                                          ),&#10;                                        ),&#10;                                      ),&#10;                                      if (isAnimating)&#10;                                        Padding(&#10;                                          padding: const EdgeInsets.symmetric(vertical: 8.0),&#10;                                          child: Container(&#10;                                            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),&#10;                                            decoration: BoxDecoration(&#10;                                              color: Colors.black.withOpacity(0.6),&#10;                                              borderRadius: BorderRadius.circular(10),&#10;                                            ),&#10;                                            child: Row(&#10;                                              mainAxisSize: MainAxisSize.min,&#10;                                              mainAxisAlignment: MainAxisAlignment.center,&#10;                                              children: const [&#10;                                                SizedBox(&#10;                                                  width: 20,&#10;                                                  height: 20,&#10;                                                  child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white),&#10;                                                ),&#10;                                                SizedBox(width: 12),&#10;                                                Text(&#10;                                                  &quot;AI is thinking...&quot;,&#10;                                                  style: TextStyle(color: Colors.white),&#10;                                                ),&#10;                                              ],&#10;                                            ),&#10;                                          ),&#10;                                        ),&#10;                                    ]&#10;                                  ),&#10;                                  // PLAYER STATS&#10;                                  _buildPokemonCard(activePlayer, isOpponent: false),&#10;&#10;                                ]&#10;                              )&#10;                            ), // battle space&#10;                          ],&#10;                        ),&#10;                      ),&#10;                      Container(&#10;                        color: Colors.redAccent,&#10;                        child: Column(&#10;                          children: [&#10;                            //MOVES AND OTHER STUFF&#10;                            const SizedBox(height: 8),&#10;&#10;                            const SizedBox(height: 8),&#10;                            Padding(&#10;                              padding: const EdgeInsets.symmetric(horizontal: 12.0),&#10;                              // NARRATION&#10;                              child: Container(&#10;                                width: double.infinity,&#10;                                padding: const EdgeInsets.all(12),&#10;                                decoration: BoxDecoration(&#10;                                  color: Colors.cyanAccent,&#10;                                  borderRadius: BorderRadius.circular(8),&#10;                                  border: Border.all(color: Colors.black54, width: 2),&#10;                                ),&#10;                                child: AnimatedTextKit(&#10;                                  key: ValueKey(narration), // ensures animation restarts on narration change&#10;                                  animatedTexts: [&#10;                                    TyperAnimatedText(&#10;                                      narration,&#10;                                      textStyle: const TextStyle(color: Colors.black54, fontSize: 16),&#10;                                      speed: const Duration(milliseconds: 35),&#10;                                    ),&#10;                                  ],&#10;                                  totalRepeatCount: 1,&#10;                                  pause: Duration.zero,&#10;                                  displayFullTextOnTap: true,&#10;                                  stopPauseOnTap: true,&#10;                                ),&#10;                              ),&#10;                            ),&#10;                            const SizedBox(height: 18),&#10;                            // ACTIONS&#10;                            Column(&#10;                              crossAxisAlignment: CrossAxisAlignment.stretch,&#10;                              children: [&#10;                                ExpansionTile(&#10;                                  title: const Text(&quot;Moves&quot;, style: TextStyle(fontWeight: FontWeight.bold)),&#10;                                  initiallyExpanded: movesExpanded,&#10;                                  children: [&#10;                                    Container(&#10;                                      margin: const EdgeInsets.only(bottom: 8),&#10;                                      padding: const EdgeInsets.all(8),&#10;                                      decoration: BoxDecoration(&#10;                                        border: Border.all(color: Colors.black26, width: 1),&#10;                                        borderRadius: BorderRadius.circular(8),&#10;                                      ),&#10;                                      child: Wrap(&#10;                                        spacing: 8,&#10;                                        runSpacing: 8,&#10;                                        children: controller!.getValidActions().where((action) =&gt; action.startsWith(&quot;move_&quot;)).map((action) {&#10;                                          final label = _getActionLabel(action);&#10;                                          String usesInfo = &quot;&quot;;&#10;                                          final player = controller!.state.getActive(true);&#10;                                          final index = int.tryParse(action.split(&quot;_&quot;)[1]) ?? 0;&#10;                                          if (index &gt;= 0 &amp;&amp; index &lt; player.abilities.length) {&#10;                                            final ability = player.abilities[index];&#10;                                            usesInfo = &quot; (${ability.remainingUses}/${ability.maxUses})&quot;;&#10;                                          }&#10;                                          return ElevatedButton(&#10;                                            onPressed: () =&gt; onPlayerAction(action),&#10;                                            child: Text(label + usesInfo),&#10;                                          );&#10;                                        }).toList(),&#10;                                      ),&#10;                                    ),&#10;                                  ],&#10;                                ),&#10;                                ExpansionTile(&#10;                                  title: const Text(&quot;Switch&quot;, style: TextStyle(fontWeight: FontWeight.bold)),&#10;                                  children: [&#10;                                    Container(&#10;                                      padding: const EdgeInsets.all(8),&#10;                                      decoration: BoxDecoration(&#10;                                        border: Border.all(color: Colors.black26, width: 1),&#10;                                        borderRadius: BorderRadius.circular(8),&#10;                                      ),&#10;                                      child: GridView.count(&#10;                                        crossAxisCount: 2,&#10;                                        shrinkWrap: true,&#10;                                        physics: const NeverScrollableScrollPhysics(),&#10;                                        childAspectRatio: 2.8,&#10;                                        mainAxisSpacing: 8,&#10;                                        crossAxisSpacing: 8,&#10;                                        children: controller!.getValidActions().where((action) =&gt; action.startsWith(&quot;switch_&quot;)).map((action) {&#10;                                          final label = _getActionLabel(action);&#10;                                          final team = controller!.state.playerTeam;&#10;                                          final index = int.tryParse(action.split(&quot;_&quot;)[1]) ?? 0;&#10;                                          String hpInfo = &quot;&quot;;&#10;                                          if (index &gt;= 0 &amp;&amp; index &lt; team.length) {&#10;                                            final poke = team[index];&#10;                                            hpInfo = &quot;  HP: ${poke.currentHealth}/${poke.maxHealth}&quot;;&#10;                                          }&#10;                                          return ElevatedButton(&#10;                                            onPressed: () =&gt; onPlayerAction(action),&#10;                                            child: Text(label + hpInfo),&#10;                                          );&#10;                                        }).toList(),&#10;                                      ),&#10;                                    ),&#10;                                  ],&#10;                                ),&#10;                              ],&#10;                            ),&#10;&#10;&#10;                            const SizedBox(height: 16),&#10;                          ]&#10;                        )&#10;                      ),&#10;                    ],&#10;                  ),&#10;                ),&#10;              ),&#10;            ),&#10;    );&#10;  }&#10;  String _getActionLabel(String action) {&#10;    final player = controller!.state.getActive(true);&#10;    final team = controller!.state.playerTeam;&#10;&#10;    if (action.startsWith(&quot;move_&quot;)) {&#10;      final index = int.tryParse(action.split(&quot;_&quot;)[1]) ?? 0;&#10;      if (index &gt;= 0 &amp;&amp; index &lt; player.abilities.length) {&#10;        return player.abilities[index].name;&#10;      } else {&#10;        return &quot;Unknown Move&quot;;&#10;      }&#10;    } else if (action.startsWith(&quot;switch_&quot;)) {&#10;      final index = int.tryParse(action.split(&quot;_&quot;)[1]) ?? 0;&#10;      if (index &gt;= 0 &amp;&amp; index &lt; team.length) {&#10;        return team[index].nickname;&#10;      } else {&#10;        return &quot;Unknown Switch&quot;;&#10;      }&#10;    }&#10;&#10;    return action;&#10;  }&#10;&#10;&#10;  Widget _buildPokemonCard(Pokemon_mcts p, {required bool isOpponent}) {&#10;    return Card(&#10;      elevation: 2,&#10;      color: p.isFainted ? Colors.grey[200] : (isOpponent ? Colors.red[100] : Colors.blue[100]),&#10;      child: Padding(&#10;        padding: const EdgeInsets.all(12.0),&#10;        child: Column(&#10;          crossAxisAlignment: CrossAxisAlignment.start,&#10;          children: [&#10;            Text(&quot;${p.nickname} (${p.pokemonName})&quot;,&#10;                style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),&#10;            const SizedBox(height: 4),&#10;            Row(&#10;              children: [&#10;                Text(&quot;HP: ${p.currentHealth}/${p.maxHealth}&quot;),&#10;                const SizedBox(width: 16),&#10;                Text(&quot;Type: ${p.type}&quot;),&#10;              ],&#10;            ),&#10;            const SizedBox(height: 4),&#10;            AnimatedHPBar(current: p.currentHealth, max: p.maxHealth),&#10;          ],&#10;        ),&#10;      ),&#10;      );&#10;  }&#10;&#10;  Widget _buildAnimatedSprite(Pokemon_mcts p, {bool shake = false}) {&#10;    final spritePath = 'assets/sprites/${p.pokemonName.toLowerCase()}.png';&#10;&#10;    return TweenAnimationBuilder&lt;Offset&gt;(&#10;      key: ValueKey(p.nickname + p.currentHealth.toString()),&#10;      tween: Tween&lt;Offset&gt;(&#10;        begin: Offset.zero,&#10;        end: shake ? const Offset(0.05, 0) : Offset.zero,&#10;      ),&#10;      duration: const Duration(milliseconds: 150),&#10;      curve: Curves.elasticIn,&#10;      builder: (context, value, _) {&#10;        return Transform.translate(&#10;          offset: Offset(value.dx * 10, 0),&#10;          child: Stack(&#10;            children: [&#10;              Image.asset(&#10;                spritePath,&#10;                width: 96,&#10;                height: 96,&#10;                errorBuilder: (context, error, stack) =&gt; const Icon(Icons.error),&#10;              ),&#10;              if (shake)&#10;                Positioned.fill(&#10;                  child: ColoredBox(&#10;                    color: Colors.white.withOpacity(0.5),&#10;                  ),&#10;                ),&#10;            ],&#10;          ),&#10;        );&#10;      },&#10;    );&#10;  }&#10;&#10;&#10;  String getAbilityName(String action, bool isPlayer) {&#10;    if (!action.startsWith(&quot;move_&quot;)) return &quot;&quot;;&#10;    final index = int.parse(action.split(&quot;_&quot;)[1]);&#10;    final p = controller!.state.getActive(isPlayer);&#10;    return p.abilities[index].name;&#10;  }&#10;&#10;&#10;  Future&lt;void&gt; playTurnAnimationSequence(String playerAction) async {&#10;    setState(() {&#10;      playerJustAttacked = playerAction.startsWith(&quot;move_&quot;);&#10;      opponentJustAttacked = false;&#10;      narration = &quot;You used ${getAbilityName(playerAction, true)}!&quot;;&#10;      isAnimating = true;&#10;    });&#10;&#10;    // Pause to show player attack + shake&#10;    await Future.delayed(const Duration(milliseconds: 500));&#10;&#10;    setState(() {&#10;      controller!.applyPlayerAction(playerAction);&#10;      // After controller.applyPlayerAction(playerAction);&#10;      final effectiveness = controller!.lastEffectiveness;&#10;      final feedback = getEffectivenessText(effectiveness);&#10;&#10;      setState(() {&#10;        narration += &quot;\n$feedback&quot;;&#10;      });&#10;&#10;    });&#10;&#10;    if (!controller!.isBattleOver) {&#10;      final aiAction = runMCTS(controller!.state, 100);&#10;      final isSwitch = aiAction.startsWith(&quot;switch_&quot;);&#10;      final aiUsed = isSwitch&#10;          ? &quot;AI switched to ${controller!.state.getActive(false).nickname}!&quot;&#10;          : &quot;Enemy used ${getAbilityName(aiAction, false)}!&quot;;&#10;&#10;      await Future.delayed(const Duration(milliseconds: 300));&#10;&#10;      setState(() {&#10;        narration = aiUsed;&#10;        opponentJustAttacked = !isSwitch;&#10;      });&#10;&#10;      await Future.delayed(const Duration(milliseconds: 500));&#10;&#10;      setState(() {&#10;        controller!.state.applyAction(aiAction);&#10;        isAnimating = false;&#10;      });&#10;    } else {&#10;      setState(() {&#10;        isAnimating = false;&#10;      });&#10;    }&#10;  }&#10;&#10;  void playBattleMusic() {&#10;    MusicService().playMusic('music/battle_music.mp3');&#10;  }&#10;&#10;  void toggleMusic() {&#10;    setState(() {&#10;      isMusicPlaying = !isMusicPlaying;&#10;      if (isMusicPlaying) {&#10;        MusicService().playMusic('music/battle_music.mp3');&#10;      } else {&#10;        MusicService().stopMusic();&#10;      }&#10;    });&#10;  }&#10;&#10;  void onPlayerAction(String action) {&#10;    playTurnAnimationSequence(action);&#10;  }&#10;&#10;&#10;  @override&#10;  void dispose() {&#10;    // Stop battle music and resume menu music when leaving the page&#10;    MusicService().stopMusic(); // Stop battle music&#10;    MusicService().playMusic('music/menu_music.mp3'); // Resume menu music&#10;    super.dispose();&#10;  }&#10;}&#10;class AnimatedHPBar extends StatelessWidget {&#10;  final int current;&#10;  final int max;&#10;&#10;  const AnimatedHPBar({super.key, required this.current, required this.max});&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    final ratio = current / max;&#10;    final color = ratio &gt; 0.5&#10;        ? Colors.green&#10;        : ratio &gt; 0.2&#10;        ? Colors.orange&#10;        : Colors.red;&#10;&#10;    return TweenAnimationBuilder&lt;double&gt;(&#10;      tween: Tween&lt;double&gt;(begin: 0, end: ratio),&#10;      duration: const Duration(milliseconds: 500),&#10;      builder: (context, value, _) {&#10;        return SizedBox(&#10;          width: 170, // or MediaQuery.of(context).size.width * 0.4 for responsive&#10;          child: ClipRRect(&#10;            borderRadius: BorderRadius.circular(6),&#10;            child: LinearProgressIndicator(&#10;              value: value,&#10;              backgroundColor: Colors.grey[300],&#10;              color: color,&#10;              minHeight: 12,&#10;            ),&#10;          ),&#10;        );&#10;      },&#10;    );&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lib/pages/taskspage.dart">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lib/pages/taskspage.dart" />
              <option name="originalContent" value="import 'package:flutter/material.dart';&#10;import 'homepage.dart';&#10;import '../services/my_scaffold.dart';&#10;import 'threads_page.dart';&#10;&#10;class TasksPage extends StatelessWidget {&#10;  final String trainerId;&#10;  const TasksPage({super.key, required this.trainerId});&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    int totalTasksCompleted = 0; // This will eventually come from the database&#10;    return Container(&#10;      color: Colors.grey[200],&#10;      child: MyScaffold(&#10;        selectedIndex: 1, // Tasks tab index is 1&#10;        trainerId: trainerId,&#10;        child: Container(// Background color behind everything&#10;          child: Center(&#10;            child: Column(&#10;              mainAxisAlignment: MainAxisAlignment.center,&#10;              children: [&#10;                Expanded(&#10;                  child: Container(&#10;                    child: Column(&#10;                      mainAxisAlignment: MainAxisAlignment.center,&#10;                      children: [&#10;                        Icon(&#10;                          Icons.earbuds_rounded,&#10;                          size: 100,&#10;                          color: Colors.redAccent,&#10;                        ),&#10;                        SizedBox(height: 20),&#10;                        ElevatedButton(&#10;                          onPressed: () {&#10;                            Navigator.pushNamed(&#10;                              context,&#10;                              '/threads',&#10;                              arguments: {'trainer_id': trainerId},&#10;                            );&#10;                          },&#10;                          child: Text('Go to Threads'),&#10;                        ),&#10;                      ],&#10;                    ),&#10;                  ),&#10;                  flex: 1,&#10;                ),&#10;                Container(&#10;                  color: Colors.yellow[700],&#10;                  width: double.infinity,&#10;                  padding: EdgeInsets.symmetric(vertical: 8),&#10;                  child: Center(&#10;                    child: Text(&#10;                      'Total Tasks Completed: $totalTasksCompleted',&#10;                      style: TextStyle(&#10;                        fontSize: 16,&#10;                        fontWeight: FontWeight.w500,&#10;                        color: Color(0xFF333333), // Dark text color&#10;                        letterSpacing: 1.2,&#10;                      ),&#10;                    ),&#10;                  ),&#10;                ),&#10;                Expanded(&#10;                  child: Container(&#10;                    child: Column(&#10;                      mainAxisAlignment: MainAxisAlignment.center,&#10;                      children: [&#10;                        Icon(&#10;                          Icons.folder,&#10;                          size: 100,&#10;                          color: Colors.redAccent,&#10;                        ),&#10;                        SizedBox(height: 20),&#10;                        ElevatedButton(&#10;                          onPressed: () {&#10;                            Navigator.pushNamed(&#10;                              context,&#10;                              '/folders',&#10;                              arguments: {'trainer_id': trainerId},&#10;                            );&#10;                          },&#10;                          child: Text('Go to Folders'),&#10;                        ),&#10;                      ],&#10;                    ),&#10;                  ),&#10;                  flex: 1,&#10;                ),&#10;              ],&#10;            ),&#10;&#10;          ),&#10;        ), // Background color behind everything&#10;      )&#10;    );&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import 'package:flutter/material.dart';&#10;import 'homepage.dart';&#10;import '../services/my_scaffold.dart';&#10;import 'threads_page.dart';&#10;import 'package:supabase_flutter/supabase_flutter.dart';&#10;&#10;class TasksPage extends StatefulWidget {&#10;  final String trainerId;&#10;  const TasksPage({super.key, required this.trainerId});&#10;&#10;  @override&#10;  State&lt;TasksPage&gt; createState() =&gt; _TasksPageState();&#10;}&#10;&#10;class _TasksPageState extends State&lt;TasksPage&gt; {&#10;  int totalTasksCompleted = 0;&#10;  bool isLoading = true;&#10;&#10;  @override&#10;  void initState() {&#10;    super.initState();&#10;    fetchCompletedTasks();&#10;  }&#10;&#10;  Future&lt;void&gt; fetchCompletedTasks() async {&#10;    final supabase = Supabase.instance.client;&#10;    final response = await supabase&#10;        .from('trainer_table')&#10;        .select('completed_tasks')&#10;        .eq('trainer_id', widget.trainerId)&#10;        .maybeSingle();&#10;    setState(() {&#10;      totalTasksCompleted = response != null &amp;&amp; response['completed_tasks'] != null&#10;          ? response['completed_tasks'] as int&#10;          : 0;&#10;      isLoading = false;&#10;    });&#10;  }&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    return Container(&#10;      color: Colors.grey[200],&#10;      child: MyScaffold(&#10;        selectedIndex: 1, // Tasks tab index is 1&#10;        trainerId: widget.trainerId,&#10;        child: Container(// Background color behind everything&#10;          child: Center(&#10;            child: Column(&#10;              mainAxisAlignment: MainAxisAlignment.center,&#10;              children: [&#10;                Expanded(&#10;                  child: Container(&#10;                    child: Column(&#10;                      mainAxisAlignment: MainAxisAlignment.center,&#10;                      children: [&#10;                        Icon(&#10;                          Icons.earbuds_rounded,&#10;                          size: 100,&#10;                          color: Colors.redAccent,&#10;                        ),&#10;                        SizedBox(height: 20),&#10;                        ElevatedButton(&#10;                          onPressed: () {&#10;                            Navigator.pushNamed(&#10;                              context,&#10;                              '/threads',&#10;                              arguments: {'trainer_id': widget.trainerId},&#10;                            );&#10;                          },&#10;                          child: Text('Go to Threads'),&#10;                        ),&#10;                        SizedBox(height: 20),&#10;                        isLoading&#10;                            ? CircularProgressIndicator()&#10;                            : Text('Total Tasks Completed: $totalTasksCompleted',&#10;                                style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),&#10;                      ],&#10;                    ),&#10;                  ),&#10;                  flex: 1,&#10;                ),&#10;                Container(&#10;                  color: Colors.yellow[700],&#10;                  width: double.infinity,&#10;                  padding: EdgeInsets.symmetric(vertical: 8),&#10;                  child: Center(&#10;                    child: Text(&#10;                      'Total Tasks Completed: $totalTasksCompleted',&#10;                      style: TextStyle(&#10;                        fontSize: 16,&#10;                        fontWeight: FontWeight.w500,&#10;                        color: Color(0xFF333333), // Dark text color&#10;                        letterSpacing: 1.2,&#10;                      ),&#10;                    ),&#10;                  ),&#10;                ),&#10;                Expanded(&#10;                  child: Container(&#10;                    child: Column(&#10;                      mainAxisAlignment: MainAxisAlignment.center,&#10;                      children: [&#10;                        Icon(&#10;                          Icons.folder,&#10;                          size: 100,&#10;                          color: Colors.redAccent,&#10;                        ),&#10;                        SizedBox(height: 20),&#10;                        ElevatedButton(&#10;                          onPressed: () {&#10;                            Navigator.pushNamed(&#10;                              context,&#10;                              '/folders',&#10;                              arguments: {'trainer_id': widget.trainerId},&#10;                            );&#10;                          },&#10;                          child: Text('Go to Folders'),&#10;                        ),&#10;                      ],&#10;                    ),&#10;                  ),&#10;                  flex: 1,&#10;                ),&#10;              ],&#10;            ),&#10;&#10;          ),&#10;        ), // Background color behind everything&#10;      )&#10;    );&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lib/services/task_details_card.dart">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lib/services/task_details_card.dart" />
              <option name="originalContent" value="import 'package:flutter/material.dart';&#10;import 'package:poketask/services/xp_utils.dart';&#10;import 'package:poketask/services/ability_utils.dart';&#10;import 'package:supabase_flutter/supabase_flutter.dart';&#10;import '../../models/task.dart';&#10;import '../models/pokemon_mcts.dart';&#10;&#10;class TaskDetailsCard extends StatefulWidget {&#10;  final Task task;&#10;  const TaskDetailsCard({super.key, required this.task});&#10;&#10;  @override&#10;  State&lt;TaskDetailsCard&gt; createState() =&gt; _TaskDetailsCardState();&#10;}&#10;&#10;class _TaskDetailsCardState extends State&lt;TaskDetailsCard&gt; {&#10;  late bool isCompleted;&#10;  late String notes;&#10;  final TextEditingController _notesController = TextEditingController();&#10;&#10;  @override&#10;  void initState() {&#10;    super.initState();&#10;    isCompleted = widget.task.isCompleted;&#10;    notes = widget.task.taskNotes;&#10;    _notesController.text = notes;&#10;  }&#10;&#10;  @override&#10;  void dispose() {&#10;    _notesController.dispose();&#10;    super.dispose();&#10;  }&#10;&#10;  Future&lt;void&gt; updateTaskCompleted(bool completed) async {&#10;    final supabase = Supabase.instance.client;&#10;    final now = DateTime.now();&#10;    await supabase&#10;        .from('task_table')&#10;        .update({&#10;          'is_completed': completed,&#10;          'date_completed': completed ? now.toIso8601String() : null,&#10;        })&#10;        .eq('task_id', widget.task.taskId);&#10;&#10;    final trainerId = widget.task.trainerId;&#10;    if (trainerId != null &amp;&amp; trainerId.isNotEmpty) {&#10;      final trainerResponse = await supabase&#10;        .from('trainer_table')&#10;        .select()&#10;        .eq('trainer_id', trainerId)&#10;        .maybeSingle();&#10;      int completedTasks = (trainerResponse != null &amp;&amp; trainerResponse['completed_tasks'] != null)&#10;        ? trainerResponse['completed_tasks'] as int&#10;        : 0;&#10;      final newCompletedTasks = completed&#10;        ? completedTasks + 1&#10;        : (completedTasks &gt; 0 ? completedTasks - 1 : 0);&#10;      int trainerXp = trainerResponse?['experience_points'] ?? 0;&#10;      int trainerLevel = trainerResponse?['level'] ?? 1;&#10;      // --- XP Scaling ---&#10;      int xpChange = 0;&#10;      if (completed) {&#10;        if (widget.task.highPriority == true) {&#10;          xpChange = 75;&#10;        } else {&#10;          xpChange = 50;&#10;        }&#10;        if (widget.task.endDate.isAfter(now)) {&#10;          xpChange += 25;&#10;        }&#10;      } else {&#10;        xpChange = -50; // If un-completing, revert base XP&#10;      }&#10;      final trainerXpResult = calculateXpAndLevel(&#10;        currentXp: trainerXp,&#10;        currentLevel: trainerLevel,&#10;        xpChange: xpChange,&#10;        scaler: 1.1,&#10;        base: 100,&#10;      );&#10;      trainerXp = trainerXpResult.newXp;&#10;      trainerLevel = trainerXpResult.newLevel;&#10;      bool trainerLeveledUp = trainerXpResult.levelsGained &gt; 0;&#10;      await supabase&#10;        .from('trainer_table')&#10;        .update({&#10;          'completed_tasks': newCompletedTasks,&#10;          'experience_points': trainerXp,&#10;          'level': trainerLevel,&#10;        })&#10;        .eq('trainer_id', trainerId);&#10;      // --- Trainer level up: add random Pokmon and show dialog ---&#10;      if (trainerLeveledUp) {&#10;        final newPokeId = await addRandomPokemonToTrainer(trainerId);&#10;        if (newPokeId != null) {&#10;          final pokeRes = await supabase&#10;            .from('pokemon_table')&#10;            .select()&#10;            .eq('pokemon_id', newPokeId)&#10;            .maybeSingle();&#10;          if (pokeRes != null &amp;&amp; context.mounted) {&#10;            await showNewPokemonDialog(context, pokeRes['pokemon_name'], pokeRes['type']);&#10;          }&#10;        }&#10;      }&#10;      // --- Pokmon XP/Level/Ability logic ---&#10;      List&lt;String&gt; pokemonLevelUps = [];&#10;      List&lt;Future&lt;void&gt;&gt; abilityDialogs = [];&#10;      // Collect slot Pokmon IDs&#10;      Set&lt;String&gt; slotPokeIds = {};&#10;      for (int i = 1; i &lt;= 6; i++) {&#10;        final slotKey = 'pokemon_slot_$i';&#10;        final pokeId = trainerResponse?[slotKey];&#10;        if (pokeId == null) continue;&#10;        slotPokeIds.add(pokeId.toString());&#10;        final pokeRes = await supabase&#10;          .from('pokemon_table')&#10;          .select()&#10;          .eq('pokemon_id', pokeId)&#10;          .maybeSingle();&#10;        if (pokeRes == null) continue;&#10;        int pokeXp = pokeRes['experience_points'] ?? 0;&#10;        int pokeLevel = pokeRes['level'] ?? 1;&#10;        final pokeXpResult = calculateXpAndLevel(&#10;          currentXp: pokeXp,&#10;          currentLevel: pokeLevel,&#10;          xpChange: xpChange,&#10;          scaler: 1.1,&#10;          base: 100,&#10;        );&#10;        if (pokeXpResult.levelsGained &gt; 0) {&#10;          var tempPoke = Pokemon_mcts(&#10;            pokemonName: pokeRes['pokemon_name'],&#10;            nickname: pokeRes['nickname'],&#10;            type: pokeRes['type'],&#10;            level: pokeLevel,&#10;            attack: pokeRes['attack'],&#10;            maxHealth: pokeRes['health'],&#10;            abilities: [],&#10;          );&#10;          for (int lvl = 0; lvl &lt; pokeXpResult.levelsGained; lvl++) {&#10;            tempPoke = tempPoke.levelUp();&#10;          }&#10;          String pokeName = pokeRes['nickname'] ?? pokeRes['pokemon_name'] ?? 'Pokmon';&#10;          pokemonLevelUps.add('$pokeName (Lv ${pokeLevel}  ${pokeXpResult.newLevel})');&#10;          await supabase&#10;            .from('pokemon_table')&#10;            .update({&#10;              'experience_points': pokeXpResult.newXp,&#10;              'level': pokeXpResult.newLevel,&#10;              'health': tempPoke.maxHealth,&#10;              'attack': tempPoke.attack,&#10;            })&#10;            .eq('pokemon_id', pokeId);&#10;        } else {&#10;          await supabase&#10;            .from('pokemon_table')&#10;            .update({&#10;              'experience_points': pokeXpResult.newXp,&#10;              'level': pokeXpResult.newLevel,&#10;            })&#10;            .eq('pokemon_id', pokeId);&#10;        }&#10;        if (pokeXpResult.levelsGained &gt; 0 &amp;&amp; pokeXpResult.newLevel % 5 == 0) {&#10;          List&lt;String&gt; currentAbilityIds = [];&#10;          for (int j = 1; j &lt;= 4; j++) {&#10;            final abId = pokeRes['ability$j'];&#10;            if (abId != null) currentAbilityIds.add(abId.toString());&#10;          }&#10;          final newAbility = await fetchRandomAbilityExcluding(currentAbilityIds);&#10;          if (newAbility != null &amp;&amp; context.mounted) {&#10;            abilityDialogs.add(Future(() async {&#10;              await Future.delayed(const Duration(seconds: 2));&#10;              await offerAbilityDialog(&#10;                context: context,&#10;                ability: newAbility,&#10;                pokeId: pokeId.toString(),&#10;                currentAbilityIds: currentAbilityIds,&#10;              );&#10;            }));&#10;          }&#10;        }&#10;      }&#10;      // --- Favorite Pokmon XP logic ---&#10;      final favoritePokeId = trainerResponse?['favorite_pokemon'];&#10;      if (favoritePokeId != null) {&#10;        // If favorite is also in a slot, it gets double XP&#10;        int favoriteXpChange = slotPokeIds.contains(favoritePokeId.toString()) ? xpChange : xpChange;&#10;        // If in slot, it will get XP again below, so add again for double&#10;        if (slotPokeIds.contains(favoritePokeId.toString())) {&#10;          favoriteXpChange = xpChange; // Already applied above, so add again&#10;        }&#10;        final pokeRes = await supabase&#10;          .from('pokemon_table')&#10;          .select()&#10;          .eq('pokemon_id', favoritePokeId)&#10;          .maybeSingle();&#10;        if (pokeRes != null) {&#10;          int pokeXp = pokeRes['experience_points'] ?? 0;&#10;          int pokeLevel = pokeRes['level'] ?? 1;&#10;          // If in slot, add XP again for double&#10;          int totalXpChange = slotPokeIds.contains(favoritePokeId.toString()) ? xpChange : xpChange;&#10;          if (slotPokeIds.contains(favoritePokeId.toString())) {&#10;            totalXpChange += xpChange;&#10;          }&#10;          final pokeXpResult = calculateXpAndLevel(&#10;            currentXp: pokeXp,&#10;            currentLevel: pokeLevel,&#10;            xpChange: totalXpChange,&#10;            scaler: 1.1,&#10;            base: 100,&#10;          );&#10;          await supabase&#10;            .from('pokemon_table')&#10;            .update({&#10;              'experience_points': pokeXpResult.newXp,&#10;              'level': pokeXpResult.newLevel,&#10;            })&#10;            .eq('pokemon_id', favoritePokeId);&#10;        }&#10;      }&#10;      // Show level-up notification if any&#10;      if (pokemonLevelUps.isNotEmpty &amp;&amp; context.mounted) {&#10;        await showDialog(&#10;          context: context,&#10;          builder: (context) =&gt; AlertDialog(&#10;            title: const Text('Pokmon Leveled Up!'),&#10;            content: Text(pokemonLevelUps.join('\n')),&#10;            actions: [&#10;              TextButton(&#10;                onPressed: () =&gt; Navigator.of(context).pop(),&#10;                child: const Text('OK'),&#10;              ),&#10;            ],&#10;          ),&#10;        );&#10;      }&#10;      // Show ability dialogs (sequentially)&#10;      for (final dialog in abilityDialogs) {&#10;        await dialog;&#10;      }&#10;    }&#10;    if (!mounted) return;&#10;    setState(() {&#10;      isCompleted = completed;&#10;      widget.task.isCompleted = completed;&#10;      widget.task.dateCompleted = completed ? now : DateTime(2100);&#10;    });&#10;    // Do not close the dialog here&#10;  }&#10;&#10;  Future&lt;void&gt; updateTaskNotes(String notes) async {&#10;    final supabase = Supabase.instance.client;&#10;    await supabase&#10;        .from('task_table')&#10;        .update({'task_notes': notes})&#10;        .eq('task_id', widget.task.taskId);&#10;  }&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    return AlertDialog(&#10;      titlePadding: EdgeInsets.zero,&#10;      title: Column(&#10;        crossAxisAlignment: CrossAxisAlignment.stretch,&#10;        children: [&#10;          if (widget.task.highPriority == true)&#10;            Container(&#10;              color: Colors.red[700],&#10;              padding: EdgeInsets.symmetric(vertical: 8, horizontal: 16),&#10;              child: Row(&#10;                children: [&#10;                  Icon(Icons.priority_high, color: Colors.white, size: 22),&#10;                  SizedBox(width: 8),&#10;                  Text(&#10;                    'High Priority',&#10;                    style: TextStyle(&#10;                      color: Colors.white,&#10;                      fontWeight: FontWeight.bold,&#10;                      fontSize: 16,&#10;                      letterSpacing: 1.1,&#10;                    ),&#10;                  ),&#10;                ],&#10;              ),&#10;            ),&#10;          if (widget.task.endDate.isBefore(DateTime.now()))&#10;            Container(&#10;              color: Colors.orange[800],&#10;              padding: EdgeInsets.symmetric(vertical: 8, horizontal: 16),&#10;              child: Row(&#10;                children: [&#10;                  Icon(Icons.warning_amber_rounded, color: Colors.white, size: 22),&#10;                  SizedBox(width: 8),&#10;                  Text(&#10;                    'Past Deadline',&#10;                    style: TextStyle(&#10;                      color: Colors.white,&#10;                      fontWeight: FontWeight.bold,&#10;                      fontSize: 16,&#10;                      letterSpacing: 1.1,&#10;                    ),&#10;                  ),&#10;                ],&#10;              ),&#10;            ),&#10;          Padding(&#10;            padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 8.0),&#10;            child: Row(&#10;              children: [&#10;                Expanded(child: Text(widget.task.taskText)),&#10;                IconButton(&#10;                  icon: Icon(&#10;                    isCompleted ? Icons.check_circle : Icons.radio_button_unchecked,&#10;                    color: isCompleted ? Colors.green : Colors.grey,&#10;                  ),&#10;                  tooltip: isCompleted ? 'Completed' : 'Mark as complete',&#10;                  onPressed: () async {&#10;                    await updateTaskCompleted(!isCompleted);&#10;                  },&#10;                ),&#10;              ],&#10;            ),&#10;          ),&#10;        ],&#10;      ),&#10;      content: SingleChildScrollView(&#10;        child: Column(&#10;          mainAxisSize: MainAxisSize.min,&#10;          crossAxisAlignment: CrossAxisAlignment.start,&#10;          children: [&#10;            Text('Notes:'),&#10;            TextField(&#10;              controller: _notesController,&#10;              maxLines: 2,&#10;              decoration: InputDecoration(&#10;                hintText: 'Add notes...',&#10;                border: OutlineInputBorder(),&#10;                suffixIcon: IconButton(&#10;                  icon: Icon(Icons.save),&#10;                  tooltip: 'Save Notes',&#10;                  onPressed: () async {&#10;                    setState(() {&#10;                      notes = _notesController.text;&#10;                      widget.task.taskNotes = notes;&#10;                    });&#10;                    await updateTaskNotes(notes);&#10;                  },&#10;                ),&#10;              ),&#10;            ),&#10;            SizedBox(height: 8),&#10;            Text('Start: '&#10;                '${widget.task.startDate.year}-${widget.task.startDate.month.toString().padLeft(2, '0')}-${widget.task.startDate.day.toString().padLeft(2, '0')} '&#10;                '${widget.task.startDate.hour.toString().padLeft(2, '0')}:${widget.task.startDate.minute.toString().padLeft(2, '0')}'),&#10;            Text('End: '&#10;                '${widget.task.endDate.year}-${widget.task.endDate.month.toString().padLeft(2, '0')}-${widget.task.endDate.day.toString().padLeft(2, '0')} '&#10;                '${widget.task.endDate.hour.toString().padLeft(2, '0')}:${widget.task.endDate.minute.toString().padLeft(2, '0')}'),&#10;            SizedBox(height: 8),&#10;            Text('Completed: ${isCompleted ? &quot;Yes&quot; : &quot;No&quot;}'),&#10;          ],&#10;        ),&#10;      ),&#10;      actions: [&#10;        TextButton(&#10;          onPressed: () =&gt; Navigator.of(context).pop(isCompleted),&#10;          child: Text('Close'),&#10;        ),&#10;        TextButton(&#10;          onPressed: () async {&#10;            final supabase = Supabase.instance.client;&#10;            await supabase&#10;                .from('task_table')&#10;                .delete()&#10;                .eq('task_id', widget.task.taskId);&#10;            Navigator.of(context).pop('delete');&#10;          },&#10;          child: Text('Delete', style: TextStyle(color: Colors.red)),&#10;        ),&#10;      ],&#10;    );&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import 'package:flutter/material.dart';&#10;import 'package:poketask/services/xp_utils.dart';&#10;import 'package:poketask/services/ability_utils.dart';&#10;import 'package:supabase_flutter/supabase_flutter.dart';&#10;import '../../models/task.dart';&#10;import '../models/pokemon_mcts.dart';&#10;&#10;class TaskDetailsCard extends StatefulWidget {&#10;  final Task task;&#10;  const TaskDetailsCard({super.key, required this.task});&#10;&#10;  @override&#10;  State&lt;TaskDetailsCard&gt; createState() =&gt; _TaskDetailsCardState();&#10;}&#10;&#10;class _TaskDetailsCardState extends State&lt;TaskDetailsCard&gt; {&#10;  late bool isCompleted;&#10;  late String notes;&#10;  final TextEditingController _notesController = TextEditingController();&#10;&#10;  @override&#10;  void initState() {&#10;    super.initState();&#10;    isCompleted = widget.task.isCompleted;&#10;    notes = widget.task.taskNotes;&#10;    _notesController.text = notes;&#10;  }&#10;&#10;  @override&#10;  void dispose() {&#10;    _notesController.dispose();&#10;    super.dispose();&#10;  }&#10;&#10;  Future&lt;void&gt; updateTaskCompleted(bool completed) async {&#10;    final supabase = Supabase.instance.client;&#10;    final now = DateTime.now();&#10;    await supabase&#10;        .from('task_table')&#10;        .update({&#10;          'is_completed': completed,&#10;          'date_completed': completed ? now.toIso8601String() : null,&#10;        })&#10;        .eq('task_id', widget.task.taskId);&#10;&#10;    final trainerId = widget.task.trainerId;&#10;    if (trainerId != null &amp;&amp; trainerId.isNotEmpty) {&#10;      final trainerResponse = await supabase&#10;        .from('trainer_table')&#10;        .select()&#10;        .eq('trainer_id', trainerId)&#10;        .maybeSingle();&#10;      int completedTasks = (trainerResponse != null &amp;&amp; trainerResponse['completed_tasks'] != null)&#10;        ? trainerResponse['completed_tasks'] as int&#10;        : 0;&#10;      final newCompletedTasks = completed&#10;        ? completedTasks + 1&#10;        : (completedTasks &gt; 0 ? completedTasks - 1 : 0);&#10;      int trainerXp = trainerResponse?['experience_points'] ?? 0;&#10;      int trainerLevel = trainerResponse?['level'] ?? 1;&#10;      // --- XP Scaling ---&#10;      int xpChange = 0;&#10;      if (completed) {&#10;        if (widget.task.highPriority == true) {&#10;          xpChange = 75;&#10;        } else {&#10;          xpChange = 50;&#10;        }&#10;        if (widget.task.endDate.isAfter(now)) {&#10;          xpChange += 25;&#10;        }&#10;      } else {&#10;        xpChange = -50; // If un-completing, revert base XP&#10;      }&#10;      final trainerXpResult = calculateXpAndLevel(&#10;        currentXp: trainerXp,&#10;        currentLevel: trainerLevel,&#10;        xpChange: xpChange,&#10;        scaler: 1.1,&#10;        base: 100,&#10;      );&#10;      trainerXp = trainerXpResult.newXp;&#10;      trainerLevel = trainerXpResult.newLevel;&#10;      bool trainerLeveledUp = trainerXpResult.levelsGained &gt; 0;&#10;      await supabase&#10;        .from('trainer_table')&#10;        .update({&#10;          'completed_tasks': newCompletedTasks,&#10;          'experience_points': trainerXp,&#10;          'level': trainerLevel,&#10;        })&#10;        .eq('trainer_id', trainerId);&#10;      // --- Trainer level up: add random Pokmon and show dialog ---&#10;      if (trainerLeveledUp) {&#10;        final newPokeId = await addRandomPokemonToTrainer(trainerId);&#10;        if (newPokeId != null) {&#10;          final pokeRes = await supabase&#10;            .from('pokemon_table')&#10;            .select()&#10;            .eq('pokemon_id', newPokeId)&#10;            .maybeSingle();&#10;          if (pokeRes != null &amp;&amp; context.mounted) {&#10;            await showNewPokemonDialog(context, pokeRes['pokemon_name'], pokeRes['type']);&#10;          }&#10;        }&#10;      }&#10;      // --- Pokmon XP/Level/Ability logic ---&#10;      List&lt;String&gt; pokemonLevelUps = [];&#10;      List&lt;Future&lt;void&gt;&gt; abilityDialogs = [];&#10;      // Collect slot Pokmon IDs&#10;      Set&lt;String&gt; slotPokeIds = {};&#10;      for (int i = 1; i &lt;= 6; i++) {&#10;        final slotKey = 'pokemon_slot_$i';&#10;        final pokeId = trainerResponse?[slotKey];&#10;        if (pokeId == null) continue;&#10;        slotPokeIds.add(pokeId.toString());&#10;        final pokeRes = await supabase&#10;          .from('pokemon_table')&#10;          .select()&#10;          .eq('pokemon_id', pokeId)&#10;          .maybeSingle();&#10;        if (pokeRes == null) continue;&#10;        int pokeXp = pokeRes['experience_points'] ?? 0;&#10;        int pokeLevel = pokeRes['level'] ?? 1;&#10;        final pokeXpResult = calculateXpAndLevel(&#10;          currentXp: pokeXp,&#10;          currentLevel: pokeLevel,&#10;          xpChange: xpChange,&#10;          scaler: 1.1,&#10;          base: 100,&#10;        );&#10;        if (pokeXpResult.levelsGained &gt; 0) {&#10;          var tempPoke = Pokemon_mcts(&#10;            pokemonName: pokeRes['pokemon_name'],&#10;            nickname: pokeRes['nickname'],&#10;            type: pokeRes['type'],&#10;            level: pokeLevel,&#10;            attack: pokeRes['attack'],&#10;            maxHealth: pokeRes['health'],&#10;            abilities: [],&#10;          );&#10;          for (int lvl = 0; lvl &lt; pokeXpResult.levelsGained; lvl++) {&#10;            tempPoke = tempPoke.levelUp();&#10;          }&#10;          String pokeName = pokeRes['nickname'] ?? pokeRes['pokemon_name'] ?? 'Pokmon';&#10;          pokemonLevelUps.add('$pokeName (Lv ${pokeLevel}  ${pokeXpResult.newLevel})');&#10;          await supabase&#10;            .from('pokemon_table')&#10;            .update({&#10;              'experience_points': pokeXpResult.newXp,&#10;              'level': pokeXpResult.newLevel,&#10;              'health': tempPoke.maxHealth,&#10;              'attack': tempPoke.attack,&#10;            })&#10;            .eq('pokemon_id', pokeId);&#10;        } else {&#10;          await supabase&#10;            .from('pokemon_table')&#10;            .update({&#10;              'experience_points': pokeXpResult.newXp,&#10;              'level': pokeXpResult.newLevel,&#10;            })&#10;            .eq('pokemon_id', pokeId);&#10;        }&#10;        if (pokeXpResult.levelsGained &gt; 0 &amp;&amp; pokeXpResult.newLevel % 5 == 0) {&#10;          List&lt;String&gt; currentAbilityIds = [];&#10;          for (int j = 1; j &lt;= 4; j++) {&#10;            final abId = pokeRes['ability$j'];&#10;            if (abId != null) currentAbilityIds.add(abId.toString());&#10;          }&#10;          final newAbility = await fetchRandomAbilityExcluding(currentAbilityIds);&#10;          if (newAbility != null &amp;&amp; context.mounted) {&#10;            abilityDialogs.add(Future(() async {&#10;              await Future.delayed(const Duration(seconds: 2));&#10;              await offerAbilityDialog(&#10;                context: context,&#10;                ability: newAbility,&#10;                pokeId: pokeId.toString(),&#10;                currentAbilityIds: currentAbilityIds,&#10;              );&#10;            }));&#10;          }&#10;        }&#10;      }&#10;      // --- Favorite Pokmon XP logic ---&#10;      final favoritePokeId = trainerResponse?['favorite_pokemon'];&#10;      if (favoritePokeId != null) {&#10;        // If favorite is also in a slot, it gets double XP&#10;        int totalXpChange = slotPokeIds.contains(favoritePokeId.toString()) ? xpChange * 2 : xpChange;&#10;        final pokeRes = await supabase&#10;          .from('pokemon_table')&#10;          .select()&#10;          .eq('pokemon_id', favoritePokeId)&#10;          .maybeSingle();&#10;        if (pokeRes != null) {&#10;          int pokeXp = pokeRes['experience_points'] ?? 0;&#10;          int pokeLevel = pokeRes['level'] ?? 1;&#10;          final pokeXpResult = calculateXpAndLevel(&#10;            currentXp: pokeXp,&#10;            currentLevel: pokeLevel,&#10;            xpChange: totalXpChange,&#10;            scaler: 1.1,&#10;            base: 100,&#10;          );&#10;          await supabase&#10;            .from('pokemon_table')&#10;            .update({&#10;              'experience_points': pokeXpResult.newXp,&#10;              'level': pokeXpResult.newLevel,&#10;            })&#10;            .eq('pokemon_id', favoritePokeId);&#10;          // --- Offer ability if favorite leveled up to a multiple of 5 ---&#10;          if (pokeXpResult.levelsGained &gt; 0 &amp;&amp; pokeXpResult.newLevel % 5 == 0) {&#10;            List&lt;String&gt; currentAbilityIds = [];&#10;            for (int j = 1; j &lt;= 4; j++) {&#10;              final abId = pokeRes['ability$j'];&#10;              if (abId != null) currentAbilityIds.add(abId.toString());&#10;            }&#10;            final newAbility = await fetchRandomAbilityExcluding(currentAbilityIds);&#10;            if (newAbility != null &amp;&amp; context.mounted) {&#10;              await Future.delayed(const Duration(seconds: 2));&#10;              await offerAbilityDialog(&#10;                context: context,&#10;                ability: newAbility,&#10;                pokeId: favoritePokeId.toString(),&#10;                currentAbilityIds: currentAbilityIds,&#10;              );&#10;            }&#10;          }&#10;        }&#10;      }&#10;      // Show level-up notification if any&#10;      if (pokemonLevelUps.isNotEmpty &amp;&amp; context.mounted) {&#10;        await showDialog(&#10;          context: context,&#10;          builder: (context) =&gt; AlertDialog(&#10;            title: const Text('Pokmon Leveled Up!'),&#10;            content: Text(pokemonLevelUps.join('\n')),&#10;            actions: [&#10;              TextButton(&#10;                onPressed: () =&gt; Navigator.of(context).pop(),&#10;                child: const Text('OK'),&#10;              ),&#10;            ],&#10;          ),&#10;        );&#10;      }&#10;      // Show ability dialogs (sequentially)&#10;      for (final dialog in abilityDialogs) {&#10;        await dialog;&#10;      }&#10;    }&#10;    if (!mounted) return;&#10;    setState(() {&#10;      isCompleted = completed;&#10;      widget.task.isCompleted = completed;&#10;      widget.task.dateCompleted = completed ? now : DateTime(2100);&#10;    });&#10;    // Do not close the dialog here&#10;  }&#10;&#10;  Future&lt;void&gt; updateTaskNotes(String notes) async {&#10;    final supabase = Supabase.instance.client;&#10;    await supabase&#10;        .from('task_table')&#10;        .update({'task_notes': notes})&#10;        .eq('task_id', widget.task.taskId);&#10;  }&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    return AlertDialog(&#10;      titlePadding: EdgeInsets.zero,&#10;      title: Column(&#10;        crossAxisAlignment: CrossAxisAlignment.stretch,&#10;        children: [&#10;          if (widget.task.highPriority == true)&#10;            Container(&#10;              color: Colors.red[700],&#10;              padding: EdgeInsets.symmetric(vertical: 8, horizontal: 16),&#10;              child: Row(&#10;                children: [&#10;                  Icon(Icons.priority_high, color: Colors.white, size: 22),&#10;                  SizedBox(width: 8),&#10;                  Text(&#10;                    'High Priority',&#10;                    style: TextStyle(&#10;                      color: Colors.white,&#10;                      fontWeight: FontWeight.bold,&#10;                      fontSize: 16,&#10;                      letterSpacing: 1.1,&#10;                    ),&#10;                  ),&#10;                ],&#10;              ),&#10;            ),&#10;          if (widget.task.endDate.isBefore(DateTime.now()))&#10;            Container(&#10;              color: Colors.orange[800],&#10;              padding: EdgeInsets.symmetric(vertical: 8, horizontal: 16),&#10;              child: Row(&#10;                children: [&#10;                  Icon(Icons.warning_amber_rounded, color: Colors.white, size: 22),&#10;                  SizedBox(width: 8),&#10;                  Text(&#10;                    'Past Deadline',&#10;                    style: TextStyle(&#10;                      color: Colors.white,&#10;                      fontWeight: FontWeight.bold,&#10;                      fontSize: 16,&#10;                      letterSpacing: 1.1,&#10;                    ),&#10;                  ),&#10;                ],&#10;              ),&#10;            ),&#10;          Padding(&#10;            padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 8.0),&#10;            child: Row(&#10;              children: [&#10;                Expanded(child: Text(widget.task.taskText)),&#10;                IconButton(&#10;                  icon: Icon(&#10;                    isCompleted ? Icons.check_circle : Icons.radio_button_unchecked,&#10;                    color: isCompleted ? Colors.green : Colors.grey,&#10;                  ),&#10;                  tooltip: isCompleted ? 'Completed' : 'Mark as complete',&#10;                  onPressed: () async {&#10;                    await updateTaskCompleted(!isCompleted);&#10;                  },&#10;                ),&#10;              ],&#10;            ),&#10;          ),&#10;        ],&#10;      ),&#10;      content: SingleChildScrollView(&#10;        child: Column(&#10;          mainAxisSize: MainAxisSize.min,&#10;          crossAxisAlignment: CrossAxisAlignment.start,&#10;          children: [&#10;            Text('Notes:'),&#10;            TextField(&#10;              controller: _notesController,&#10;              maxLines: 2,&#10;              decoration: InputDecoration(&#10;                hintText: 'Add notes...',&#10;                border: OutlineInputBorder(),&#10;                suffixIcon: IconButton(&#10;                  icon: Icon(Icons.save),&#10;                  tooltip: 'Save Notes',&#10;                  onPressed: () async {&#10;                    setState(() {&#10;                      notes = _notesController.text;&#10;                      widget.task.taskNotes = notes;&#10;                    });&#10;                    await updateTaskNotes(notes);&#10;                  },&#10;                ),&#10;              ),&#10;            ),&#10;            SizedBox(height: 8),&#10;            Text('Start: '&#10;                '${widget.task.startDate.year}-${widget.task.startDate.month.toString().padLeft(2, '0')}-${widget.task.startDate.day.toString().padLeft(2, '0')} '&#10;                '${widget.task.startDate.hour.toString().padLeft(2, '0')}:${widget.task.startDate.minute.toString().padLeft(2, '0')}'),&#10;            Text('End: '&#10;                '${widget.task.endDate.year}-${widget.task.endDate.month.toString().padLeft(2, '0')}-${widget.task.endDate.day.toString().padLeft(2, '0')} '&#10;                '${widget.task.endDate.hour.toString().padLeft(2, '0')}:${widget.task.endDate.minute.toString().padLeft(2, '0')}'),&#10;            SizedBox(height: 8),&#10;            Text('Completed: ${isCompleted ? &quot;Yes&quot; : &quot;No&quot;}'),&#10;          ],&#10;        ),&#10;      ),&#10;      actions: [&#10;        TextButton(&#10;          onPressed: () =&gt; Navigator.of(context).pop(isCompleted),&#10;          child: Text('Close'),&#10;        ),&#10;        TextButton(&#10;          onPressed: () async {&#10;            final supabase = Supabase.instance.client;&#10;            await supabase&#10;                .from('task_table')&#10;                .delete()&#10;                .eq('task_id', widget.task.taskId);&#10;            Navigator.of(context).pop('delete');&#10;          },&#10;          child: Text('Delete', style: TextStyle(color: Colors.red)),&#10;        ),&#10;      ],&#10;    );&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>