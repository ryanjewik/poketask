<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/lib/pages/homepage.dart">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lib/pages/homepage.dart" />
              <option name="originalContent" value="import 'package:flutter/material.dart';&#10;import 'package:poketask/pages/fav_pokemon.dart';&#10;import 'package:supabase_flutter/supabase_flutter.dart';&#10;import '../models/task.dart';&#10;import '../services/my_scaffold.dart';&#10;import '../services/task_details_card.dart';&#10;import '../models/pokemon.dart';&#10;import '../models/trainer.dart';&#10;import '../services/music_service.dart';&#10;import 'package:auto_size_text/auto_size_text.dart';&#10;&#10;&#10;class MyHomePage extends StatefulWidget {&#10;  const MyHomePage({super.key, required this.title, required this.trainerId});&#10;  final String title;&#10;  final String trainerId;&#10;&#10;&#10;  @override&#10;  State&lt;MyHomePage&gt; createState() =&gt; _MyHomePageState();&#10;}&#10;&#10;class _MyHomePageState extends State&lt;MyHomePage&gt; with SingleTickerProviderStateMixin {&#10;&#10;&#10;  List&lt;int&gt; colorCodes = &lt;int&gt;[400, 500, 600, 700, 800];&#10;&#10;&#10;&#10;&#10;  // Remove the local Trainer instance and use the global trainerList&#10;&#10;  // State variables to hold fetched data&#10;  Trainer? trainer;&#10;  List&lt;Pokemon&gt; pokemonList = [];&#10;  List&lt;Task&gt; tasks = [];&#10;&#10;  late final String trainerId;&#10;&#10;&#10;&#10;  AnimationController? _controller;&#10;  Animation&lt;double&gt;? _animation;&#10;&#10;  bool isMusicPlaying = true;&#10;&#10;&#10;&#10;  @override&#10;  void initState() {&#10;    super.initState();&#10;    trainerId = widget.trainerId;&#10;    _controller = AnimationController(&#10;      vsync: this,&#10;      duration: const Duration(milliseconds: 1200),&#10;      lowerBound: 0.0,&#10;      upperBound: 1.0,&#10;    );&#10;    _animation = CurvedAnimation(parent: _controller!, curve: Curves.easeOutBack);&#10;    _controller?.forward();&#10;&#10;    fetchTrainerData();&#10;    fetchPokemonData();&#10;    fetchTaskData();&#10;    // Start menu music by default&#10;    MusicService().playMusic('music/menu_music.mp3');&#10;    isMusicPlaying = true;&#10;  }&#10;&#10;  void toggleMusic() async {&#10;    if (isMusicPlaying) {&#10;      await MusicService().stopMusic();&#10;    } else {&#10;      await MusicService().playMusic('music/menu_music.mp3');&#10;    }&#10;    setState(() {&#10;      isMusicPlaying = !isMusicPlaying;&#10;    });&#10;  }&#10;&#10;  Future&lt;void&gt; fetchTrainerData() async {&#10;    final supabase = Supabase.instance.client;&#10;    try {&#10;      final response = await supabase&#10;          .from('trainer_table')&#10;          .select()&#10;          .eq('trainer_id', trainerId)&#10;          .limit(1)&#10;          .single();&#10;      if (response != null) {&#10;        if (!mounted) return;&#10;        setState(() {&#10;          trainer = Trainer.fromJson(response);&#10;        });&#10;      }&#10;&#10;    } catch (e) {&#10;      debugPrint('❌ Failed to fetch trainer data: \\${e}');&#10;    }&#10;  }&#10;&#10;  Future&lt;void&gt; fetchPokemonData() async {&#10;    final supabase = Supabase.instance.client;&#10;    try {&#10;      final response = await supabase&#10;          .from('pokemon_table')&#10;          .select()&#10;          .eq('trainer_id', trainerId);&#10;      if (response != null) {&#10;        if (!mounted) return;&#10;        setState(() {&#10;          pokemonList = List&lt;Pokemon&gt;.from(&#10;            response.map((item) =&gt; Pokemon.fromJson(item)),&#10;          );&#10;        });&#10;      }&#10;      //debugPrint('✅ Pokemon data: \\${response}');&#10;    } catch (e) {&#10;      debugPrint('❌ Failed to fetch pokemon data: \\${e}');&#10;    }&#10;  }&#10;&#10;  Future&lt;void&gt; fetchTaskData() async {&#10;    final supabase = Supabase.instance.client;&#10;    try {&#10;      final response = await supabase&#10;          .from('task_table')&#10;          .select()&#10;          .eq('trainer_id', trainerId);&#10;      if (response != null) {&#10;        if (!mounted) return;&#10;        setState(() {&#10;          tasks = List&lt;Task&gt;.from(&#10;            response.map((item) =&gt; Task.fromJson(item)),&#10;          );&#10;        });&#10;      }&#10;      //debugPrint('✅ Task data: \\${response}');&#10;    } catch (e) {&#10;      debugPrint('❌ Failed to fetch task data: \\${e}');&#10;    }&#10;  }&#10;&#10;  Pokemon? get favoritedPokemon {&#10;    if (trainer == null) return null;&#10;    final favId = trainer!.favoritePokemon;&#10;    try {&#10;      // Only match pokemonId, not trainerId&#10;      return pokemonList.firstWhere((p) =&gt; p.pokemonId == favId);&#10;    } catch (e) {&#10;      return null;&#10;    }&#10;  }&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    // Filter tasks for only today's tasks&#10;    final today = DateTime.now();&#10;    final List&lt;Task&gt; onlyTodayTasks = tasks.where((task) =&gt;&#10;      task.startDate.year == today.year &amp;&amp;&#10;      task.startDate.month == today.month &amp;&amp;&#10;      task.startDate.day == today.day&#10;    ).toList();&#10;&#10;    final Pokemon? pokemon = favoritedPokemon ?? (() {&#10;      if (trainer == null) return null;&#10;      try {&#10;        return pokemonList.firstWhere((p) =&gt; p.pokemonId == trainer!.pokemonSlot1);&#10;      } catch (e) {&#10;        return null;&#10;      }&#10;    })();&#10;&#10;    return Stack(&#10;      children: [&#10;        // Add zigzag background only on the homepage&#10;        Positioned.fill(&#10;          child: Image.asset(&#10;            'assets/background/zigzag_background.jpg',&#10;            fit: BoxFit.cover,&#10;          ),&#10;        ),&#10;        MyScaffold(&#10;          selectedIndex: 2,&#10;          trainerId: trainerId,&#10;          child: Center(&#10;            child: Column(&#10;              children: &lt;Widget&gt;[&#10;                Expanded(&#10;                  flex: 2,&#10;                  child: Column(&#10;                    mainAxisAlignment: MainAxisAlignment.center,&#10;                    children: &lt;Widget&gt;[&#10;                      SizedBox(height: 32),&#10;                      Transform.translate(&#10;                        offset: Offset(0, -20),&#10;                        child: GestureDetector(&#10;                          onTap: () async {&#10;                            final result = await Navigator.push(&#10;                              context,&#10;                              MaterialPageRoute(builder: (context) =&gt; favPokemonPage(trainerId: trainerId)),&#10;                            );&#10;                            if (result == true) {&#10;                              await fetchTrainerData();&#10;                              await fetchPokemonData();&#10;                              setState(() {});&#10;                            }&#10;                          },&#10;                          child: ScaleTransition(&#10;                            scale: _animation ?? AlwaysStoppedAnimation(1.0),&#10;                            child: SizedBox(&#10;                              width: 250,&#10;                              height: 250,&#10;                              child: pokemon != null ? Image.asset(&#10;                                'assets/sprites/${pokemon.pokemonName.toLowerCase()}.png',&#10;                                fit: BoxFit.fill,&#10;                              ) : SizedBox.shrink(),&#10;                            ),&#10;                          ),&#10;                        ),&#10;                      ),&#10;                      Transform.translate(&#10;                        offset: Offset(0, 0),&#10;                        child: Column(&#10;                          children: [&#10;                            Text(&#10;                              pokemon?.nickname ?? '',&#10;                              style: TextStyle(&#10;                                fontSize: 24,&#10;                                color: Colors.white,&#10;                                fontWeight: FontWeight.bold,&#10;                              ),&#10;                            ),&#10;                            Text(&#10;                              pokemon != null ? 'Level: ${pokemon.level}' : '',&#10;                              style: TextStyle(&#10;                                fontSize: 18,&#10;                                color: Colors.white70,&#10;                                fontWeight: FontWeight.w600,&#10;                              ),&#10;                            ),&#10;                          ],&#10;                        ),&#10;                      ),&#10;                    ],&#10;                  ),&#10;                ),&#10;                Expanded(&#10;                  flex: 1,&#10;                  child: Align(&#10;                    alignment: Alignment.bottomCenter,&#10;                    child: Padding(&#10;                      padding: EdgeInsets.only(bottom: 4.0, left: 8.0, right: 8.0),&#10;                      child: SizedBox(&#10;                        height: 200,&#10;                        child: Theme(&#10;                          data: Theme.of(context).copyWith(&#10;                            scrollbarTheme: ScrollbarThemeData(&#10;                              thumbColor: WidgetStateProperty.all(Color(0xFF95EEFA)),&#10;                              trackColor: WidgetStateProperty.all(Colors.transparent),&#10;                            ),&#10;                          ),&#10;                          child: Column(&#10;                            crossAxisAlignment: CrossAxisAlignment.start,&#10;                            children: [&#10;                              Padding(&#10;                                padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 4.0),&#10;                                child: Row(&#10;                                  mainAxisAlignment: MainAxisAlignment.spaceBetween,&#10;                                  children: [&#10;                                    Text(&#10;                                      &quot;Today's tasks&quot;,&#10;                                      style: TextStyle(&#10;                                        fontSize: 18,&#10;                                        fontWeight: FontWeight.bold,&#10;                                        color: Colors.white,&#10;                                      ),&#10;                                    ),&#10;                                    Row(&#10;                                      children: [&#10;                                        FloatingActionButton(&#10;                                          mini: true,&#10;                                          onPressed: toggleMusic,&#10;                                          backgroundColor: Colors.blueAccent,&#10;                                          child: Icon(isMusicPlaying ? Icons.music_note : Icons.music_off),&#10;                                          tooltip: isMusicPlaying ? 'Pause Music' : 'Play Music',&#10;                                        ),&#10;                                        SizedBox(width: 8),&#10;                                        ElevatedButton(&#10;                                          style: ElevatedButton.styleFrom(&#10;                                            backgroundColor: Colors.blueAccent,&#10;                                            foregroundColor: Colors.white,&#10;                                            shape: RoundedRectangleBorder(&#10;                                              borderRadius: BorderRadius.circular(16),&#10;                                            ),&#10;                                            padding: EdgeInsets.symmetric(horizontal: 16, vertical: 10),&#10;                                            textStyle: TextStyle(fontWeight: FontWeight.bold, fontSize: 14),&#10;                                            elevation: 2,&#10;                                          ),&#10;                                          onPressed: () async {&#10;                                            await Supabase.instance.client.auth.signOut();&#10;                                            if (!mounted) return;&#10;                                            WidgetsBinding.instance.addPostFrameCallback((_) {&#10;                                              Navigator.of(context, rootNavigator: true).pushReplacementNamed('open');&#10;                                            });&#10;                                          },&#10;                                          child: Text('Logout'),&#10;                                        ),&#10;                                      ],&#10;                                    ),&#10;                                  ],&#10;                                ),&#10;                              ),&#10;                              Expanded(&#10;                                child: Scrollbar(&#10;                                  thumbVisibility: true,&#10;                                  trackVisibility: true,&#10;                                  interactive: true,&#10;                                  radius: Radius.circular(8),&#10;                                  thickness: 4,&#10;                                  scrollbarOrientation: ScrollbarOrientation.right,&#10;                                  child: Container(&#10;                                    decoration: BoxDecoration(&#10;                                      border: Border.all(color: Colors.white, width: 2),&#10;                                      borderRadius: BorderRadius.circular(8),&#10;                                    ),&#10;                                    child: ListView.builder(&#10;                                      itemCount: onlyTodayTasks.length,&#10;                                      itemBuilder: (BuildContext context, int index) {&#10;                                        final task = onlyTodayTasks[index];&#10;                                        return GestureDetector(&#10;                                          onTap: () async {&#10;                                            final result = await showDialog(&#10;                                              context: context,&#10;                                              builder: (context) =&gt; TaskDetailsCard(task: task),&#10;                                            );&#10;                                            if (result == 'delete') {&#10;                                              // Optionally handle delete&#10;                                            }&#10;                                            Future.microtask(() async {&#10;                                              await fetchTaskData();&#10;                                              if (mounted) setState(() {});&#10;                                            });&#10;                                          },&#10;                                          child: Container(&#10;                                            height: 50,&#10;                                            color: Colors.red[colorCodes[index % colorCodes.length]] ?? Colors.red[800],&#10;                                            child: Row(&#10;                                              mainAxisAlignment: MainAxisAlignment.center,&#10;                                              children: [&#10;                                                Text(task.eventName),&#10;                                                if (task.isCompleted)&#10;                                                  Padding(&#10;                                                    padding: const EdgeInsets.only(left: 8.0),&#10;                                                    child: Icon(Icons.check_circle, color: Colors.green, size: 20),&#10;                                                  ),&#10;                                              ],&#10;                                            ),&#10;                                          ),&#10;                                        );&#10;                                      },&#10;                                    ),&#10;                                  ),&#10;                                ),&#10;                              ),&#10;                            ],&#10;                          ),&#10;                        ),&#10;                      ),&#10;                    ),&#10;                  ),&#10;                )&#10;              ],&#10;            ),&#10;          ),&#10;        ),&#10;        Positioned(&#10;          top: 70, // negative value to bleed above the AppBar&#10;          right: 10,&#10;          child: SizedBox(&#10;            width: 140,&#10;            height: 70,&#10;            child: FittedBox(&#10;              fit: BoxFit.scaleDown,&#10;              alignment: Alignment.topRight,&#10;              child: Column(&#10;                crossAxisAlignment: CrossAxisAlignment.end,&#10;                mainAxisSize: MainAxisSize.min,&#10;                children: [&#10;                  AutoSizeText(&#10;                    trainer?.username ?? '',&#10;                    style: TextStyle(&#10;                      fontSize: 20,&#10;                      color: Colors.white,&#10;                      fontWeight: FontWeight.bold,&#10;                      decoration: TextDecoration.none, // Remove underline&#10;                      shadows: [Shadow(blurRadius: 4, color: Colors.black45, offset: Offset(1,1))],&#10;                    ),&#10;                    maxLines: 1,&#10;                    minFontSize: 10,&#10;                    overflow: TextOverflow.ellipsis,&#10;                  ),&#10;                  AutoSizeText(&#10;                    'Level: ${trainer?.level ?? ''}',&#10;                    style: TextStyle(&#10;                      fontSize: 16,&#10;                      color: Colors.white70,&#10;                      fontWeight: FontWeight.w600,&#10;                      decoration: TextDecoration.none,&#10;                      shadows: [Shadow(blurRadius: 4, color: Colors.black26, offset: Offset(1,1))],&#10;                    ),&#10;                    maxLines: 1,&#10;                    minFontSize: 8,&#10;                    overflow: TextOverflow.ellipsis,&#10;                  ),&#10;                  if (trainer != null)&#10;                    Padding(&#10;                      padding: const EdgeInsets.only(top: 4.0),&#10;                      child: Column(&#10;                        crossAxisAlignment: CrossAxisAlignment.end,&#10;                        children: [&#10;                          AutoSizeText(&#10;                            'XP: ${trainer!.experiencePoints} / ${(100 * trainer!.level * 1.1).toInt()}',&#10;                            style: TextStyle(&#10;                              color: Colors.lightGreenAccent,&#10;                              fontSize: 14,&#10;                              fontWeight: FontWeight.bold,&#10;                              decoration: TextDecoration.none,&#10;                            ),&#10;                            maxLines: 1,&#10;                            minFontSize: 8,&#10;                            overflow: TextOverflow.ellipsis,&#10;&#10;                          ),&#10;                          SizedBox(height: 4),&#10;                          SizedBox(&#10;                            width: 125,&#10;                            child: LinearProgressIndicator(&#10;                              value: trainer!.experiencePoints / (100 * trainer!.level * 1.1),&#10;                              minHeight: 7,&#10;                              backgroundColor: Colors.grey[800],&#10;                              valueColor: AlwaysStoppedAnimation&lt;Color&gt;(Colors.amber),&#10;                            ),&#10;                          ),&#10;                        ],&#10;                      ),&#10;                    ),&#10;                ],&#10;              ),&#10;            ),&#10;          ),&#10;        ),&#10;      ],&#10;    );&#10;  }&#10;&#10;  @override&#10;  void dispose() {&#10;    _controller?.dispose();&#10;    super.dispose();&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import 'package:flutter/material.dart';&#10;import 'package:poketask/pages/fav_pokemon.dart';&#10;import 'package:supabase_flutter/supabase_flutter.dart';&#10;import '../models/task.dart';&#10;import '../services/my_scaffold.dart';&#10;import '../services/task_details_card.dart';&#10;import '../models/pokemon.dart';&#10;import '../models/trainer.dart';&#10;import '../services/music_service.dart';&#10;import 'package:auto_size_text/auto_size_text.dart';&#10;import 'package:shared_preferences/shared_preferences.dart';&#10;&#10;&#10;class MyHomePage extends StatefulWidget {&#10;  const MyHomePage({super.key, required this.title, required this.trainerId});&#10;  final String title;&#10;  final String trainerId;&#10;&#10;&#10;  @override&#10;  State&lt;MyHomePage&gt; createState() =&gt; _MyHomePageState();&#10;}&#10;&#10;class _MyHomePageState extends State&lt;MyHomePage&gt; with SingleTickerProviderStateMixin {&#10;&#10;&#10;  List&lt;int&gt; colorCodes = &lt;int&gt;[400, 500, 600, 700, 800];&#10;&#10;&#10;&#10;&#10;  // Remove the local Trainer instance and use the global trainerList&#10;&#10;  // State variables to hold fetched data&#10;  Trainer? trainer;&#10;  List&lt;Pokemon&gt; pokemonList = [];&#10;  List&lt;Task&gt; tasks = [];&#10;&#10;  late final String trainerId;&#10;&#10;&#10;&#10;  AnimationController? _controller;&#10;  Animation&lt;double&gt;? _animation;&#10;&#10;  bool isMusicPlaying = true;&#10;&#10;&#10;&#10;  @override&#10;  void initState() {&#10;    super.initState();&#10;    trainerId = widget.trainerId;&#10;    _controller = AnimationController(&#10;      vsync: this,&#10;      duration: const Duration(milliseconds: 1200),&#10;      lowerBound: 0.0,&#10;      upperBound: 1.0,&#10;    );&#10;    _animation = CurvedAnimation(parent: _controller!, curve: Curves.easeOutBack);&#10;    _controller?.forward();&#10;&#10;    fetchTrainerData();&#10;    fetchPokemonData();&#10;    fetchTaskData();&#10;    _loadMusicPreference();&#10;  }&#10;&#10;  Future&lt;void&gt; _loadMusicPreference() async {&#10;    final prefs = await SharedPreferences.getInstance();&#10;    final musicOn = prefs.getBool('music_on') ?? true;&#10;    setState(() {&#10;      isMusicPlaying = musicOn;&#10;    });&#10;    await MusicService().setMute(!musicOn);&#10;    if (musicOn) {&#10;      await MusicService().playMusic('music/menu_music.mp3');&#10;    } else {&#10;      await MusicService().stopMusic();&#10;    }&#10;  }&#10;&#10;  void toggleMusic() async {&#10;    final prefs = await SharedPreferences.getInstance();&#10;    if (isMusicPlaying) {&#10;      await MusicService().stopMusic();&#10;      await MusicService().setMute(true);&#10;      await prefs.setBool('music_on', false);&#10;    } else {&#10;      await MusicService().setMute(false);&#10;      await MusicService().playMusic('music/menu_music.mp3');&#10;      await prefs.setBool('music_on', true);&#10;    }&#10;    setState(() {&#10;      isMusicPlaying = !isMusicPlaying;&#10;    });&#10;  }&#10;&#10;  Future&lt;void&gt; fetchTrainerData() async {&#10;    final supabase = Supabase.instance.client;&#10;    try {&#10;      final response = await supabase&#10;          .from('trainer_table')&#10;          .select()&#10;          .eq('trainer_id', trainerId)&#10;          .limit(1)&#10;          .single();&#10;      if (response != null) {&#10;        if (!mounted) return;&#10;        setState(() {&#10;          trainer = Trainer.fromJson(response);&#10;        });&#10;      }&#10;&#10;    } catch (e) {&#10;      debugPrint('❌ Failed to fetch trainer data: \\${e}');&#10;    }&#10;  }&#10;&#10;  Future&lt;void&gt; fetchPokemonData() async {&#10;    final supabase = Supabase.instance.client;&#10;    try {&#10;      final response = await supabase&#10;          .from('pokemon_table')&#10;          .select()&#10;          .eq('trainer_id', trainerId);&#10;      if (response != null) {&#10;        if (!mounted) return;&#10;        setState(() {&#10;          pokemonList = List&lt;Pokemon&gt;.from(&#10;            response.map((item) =&gt; Pokemon.fromJson(item)),&#10;          );&#10;        });&#10;      }&#10;      //debugPrint('✅ Pokemon data: \\${response}');&#10;    } catch (e) {&#10;      debugPrint('❌ Failed to fetch pokemon data: \\${e}');&#10;    }&#10;  }&#10;&#10;  Future&lt;void&gt; fetchTaskData() async {&#10;    final supabase = Supabase.instance.client;&#10;    try {&#10;      final response = await supabase&#10;          .from('task_table')&#10;          .select()&#10;          .eq('trainer_id', trainerId);&#10;      if (response != null) {&#10;        if (!mounted) return;&#10;        setState(() {&#10;          tasks = List&lt;Task&gt;.from(&#10;            response.map((item) =&gt; Task.fromJson(item)),&#10;          );&#10;        });&#10;      }&#10;      //debugPrint('✅ Task data: \\${response}');&#10;    } catch (e) {&#10;      debugPrint('❌ Failed to fetch task data: \\${e}');&#10;    }&#10;  }&#10;&#10;  Pokemon? get favoritedPokemon {&#10;    if (trainer == null) return null;&#10;    final favId = trainer!.favoritePokemon;&#10;    try {&#10;      // Only match pokemonId, not trainerId&#10;      return pokemonList.firstWhere((p) =&gt; p.pokemonId == favId);&#10;    } catch (e) {&#10;      return null;&#10;    }&#10;  }&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    // Filter tasks for only today's tasks&#10;    final today = DateTime.now();&#10;    final List&lt;Task&gt; onlyTodayTasks = tasks.where((task) =&gt;&#10;      task.startDate.year == today.year &amp;&amp;&#10;      task.startDate.month == today.month &amp;&amp;&#10;      task.startDate.day == today.day&#10;    ).toList();&#10;&#10;    final Pokemon? pokemon = favoritedPokemon ?? (() {&#10;      if (trainer == null) return null;&#10;      try {&#10;        return pokemonList.firstWhere((p) =&gt; p.pokemonId == trainer!.pokemonSlot1);&#10;      } catch (e) {&#10;        return null;&#10;      }&#10;    })();&#10;&#10;    return Stack(&#10;      children: [&#10;        // Add zigzag background only on the homepage&#10;        Positioned.fill(&#10;          child: Image.asset(&#10;            'assets/background/zigzag_background.jpg',&#10;            fit: BoxFit.cover,&#10;          ),&#10;        ),&#10;        MyScaffold(&#10;          selectedIndex: 2,&#10;          trainerId: trainerId,&#10;          child: Center(&#10;            child: Column(&#10;              children: &lt;Widget&gt;[&#10;                Expanded(&#10;                  flex: 2,&#10;                  child: Column(&#10;                    mainAxisAlignment: MainAxisAlignment.center,&#10;                    children: &lt;Widget&gt;[&#10;                      SizedBox(height: 32),&#10;                      Transform.translate(&#10;                        offset: Offset(0, -20),&#10;                        child: GestureDetector(&#10;                          onTap: () async {&#10;                            final result = await Navigator.push(&#10;                              context,&#10;                              MaterialPageRoute(builder: (context) =&gt; favPokemonPage(trainerId: trainerId)),&#10;                            );&#10;                            if (result == true) {&#10;                              await fetchTrainerData();&#10;                              await fetchPokemonData();&#10;                              setState(() {});&#10;                            }&#10;                          },&#10;                          child: ScaleTransition(&#10;                            scale: _animation ?? AlwaysStoppedAnimation(1.0),&#10;                            child: SizedBox(&#10;                              width: 250,&#10;                              height: 250,&#10;                              child: pokemon != null ? Image.asset(&#10;                                'assets/sprites/${pokemon.pokemonName.toLowerCase()}.png',&#10;                                fit: BoxFit.fill,&#10;                              ) : SizedBox.shrink(),&#10;                            ),&#10;                          ),&#10;                        ),&#10;                      ),&#10;                      Transform.translate(&#10;                        offset: Offset(0, 0),&#10;                        child: Column(&#10;                          children: [&#10;                            Text(&#10;                              pokemon?.nickname ?? '',&#10;                              style: TextStyle(&#10;                                fontSize: 24,&#10;                                color: Colors.white,&#10;                                fontWeight: FontWeight.bold,&#10;                              ),&#10;                            ),&#10;                            Text(&#10;                              pokemon != null ? 'Level: ${pokemon.level}' : '',&#10;                              style: TextStyle(&#10;                                fontSize: 18,&#10;                                color: Colors.white70,&#10;                                fontWeight: FontWeight.w600,&#10;                              ),&#10;                            ),&#10;                          ],&#10;                        ),&#10;                      ),&#10;                    ],&#10;                  ),&#10;                ),&#10;                Expanded(&#10;                  flex: 1,&#10;                  child: Align(&#10;                    alignment: Alignment.bottomCenter,&#10;                    child: Padding(&#10;                      padding: EdgeInsets.only(bottom: 4.0, left: 8.0, right: 8.0),&#10;                      child: SizedBox(&#10;                        height: 200,&#10;                        child: Theme(&#10;                          data: Theme.of(context).copyWith(&#10;                            scrollbarTheme: ScrollbarThemeData(&#10;                              thumbColor: WidgetStateProperty.all(Color(0xFF95EEFA)),&#10;                              trackColor: WidgetStateProperty.all(Colors.transparent),&#10;                            ),&#10;                          ),&#10;                          child: Column(&#10;                            crossAxisAlignment: CrossAxisAlignment.start,&#10;                            children: [&#10;                              Padding(&#10;                                padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 4.0),&#10;                                child: Row(&#10;                                  mainAxisAlignment: MainAxisAlignment.spaceBetween,&#10;                                  children: [&#10;                                    Text(&#10;                                      &quot;Today's tasks&quot;,&#10;                                      style: TextStyle(&#10;                                        fontSize: 18,&#10;                                        fontWeight: FontWeight.bold,&#10;                                        color: Colors.white,&#10;                                      ),&#10;                                    ),&#10;                                    Row(&#10;                                      children: [&#10;                                        FloatingActionButton(&#10;                                          mini: true,&#10;                                          onPressed: toggleMusic,&#10;                                          backgroundColor: Colors.blueAccent,&#10;                                          child: Icon(isMusicPlaying ? Icons.music_note : Icons.music_off),&#10;                                          tooltip: isMusicPlaying ? 'Pause Music' : 'Play Music',&#10;                                        ),&#10;                                        SizedBox(width: 8),&#10;                                        ElevatedButton(&#10;                                          style: ElevatedButton.styleFrom(&#10;                                            backgroundColor: Colors.blueAccent,&#10;                                            foregroundColor: Colors.white,&#10;                                            shape: RoundedRectangleBorder(&#10;                                              borderRadius: BorderRadius.circular(16),&#10;                                            ),&#10;                                            padding: EdgeInsets.symmetric(horizontal: 16, vertical: 10),&#10;                                            textStyle: TextStyle(fontWeight: FontWeight.bold, fontSize: 14),&#10;                                            elevation: 2,&#10;                                          ),&#10;                                          onPressed: () async {&#10;                                            await Supabase.instance.client.auth.signOut();&#10;                                            if (!mounted) return;&#10;                                            WidgetsBinding.instance.addPostFrameCallback((_) {&#10;                                              Navigator.of(context, rootNavigator: true).pushReplacementNamed('open');&#10;                                            });&#10;                                          },&#10;                                          child: Text('Logout'),&#10;                                        ),&#10;                                      ],&#10;                                    ),&#10;                                  ],&#10;                                ),&#10;                              ),&#10;                              Expanded(&#10;                                child: Scrollbar(&#10;                                  thumbVisibility: true,&#10;                                  trackVisibility: true,&#10;                                  interactive: true,&#10;                                  radius: Radius.circular(8),&#10;                                  thickness: 4,&#10;                                  scrollbarOrientation: ScrollbarOrientation.right,&#10;                                  child: Container(&#10;                                    decoration: BoxDecoration(&#10;                                      border: Border.all(color: Colors.white, width: 2),&#10;                                      borderRadius: BorderRadius.circular(8),&#10;                                    ),&#10;                                    child: ListView.builder(&#10;                                      itemCount: onlyTodayTasks.length,&#10;                                      itemBuilder: (BuildContext context, int index) {&#10;                                        final task = onlyTodayTasks[index];&#10;                                        return GestureDetector(&#10;                                          onTap: () async {&#10;                                            final result = await showDialog(&#10;                                              context: context,&#10;                                              builder: (context) =&gt; TaskDetailsCard(task: task),&#10;                                            );&#10;                                            if (result == 'delete') {&#10;                                              // Optionally handle delete&#10;                                            }&#10;                                            Future.microtask(() async {&#10;                                              await fetchTaskData();&#10;                                              if (mounted) setState(() {});&#10;                                            });&#10;                                          },&#10;                                          child: Container(&#10;                                            height: 50,&#10;                                            color: Colors.red[colorCodes[index % colorCodes.length]] ?? Colors.red[800],&#10;                                            child: Row(&#10;                                              mainAxisAlignment: MainAxisAlignment.center,&#10;                                              children: [&#10;                                                Text(task.eventName),&#10;                                                if (task.isCompleted)&#10;                                                  Padding(&#10;                                                    padding: const EdgeInsets.only(left: 8.0),&#10;                                                    child: Icon(Icons.check_circle, color: Colors.green, size: 20),&#10;                                                  ),&#10;                                              ],&#10;                                            ),&#10;                                          ),&#10;                                        );&#10;                                      },&#10;                                    ),&#10;                                  ),&#10;                                ),&#10;                              ),&#10;                            ],&#10;                          ),&#10;                        ),&#10;                      ),&#10;                    ),&#10;                  ),&#10;                )&#10;              ],&#10;            ),&#10;          ),&#10;        ),&#10;        Positioned(&#10;          top: 70, // negative value to bleed above the AppBar&#10;          right: 10,&#10;          child: SizedBox(&#10;            width: 140,&#10;            height: 70,&#10;            child: FittedBox(&#10;              fit: BoxFit.scaleDown,&#10;              alignment: Alignment.topRight,&#10;              child: Column(&#10;                crossAxisAlignment: CrossAxisAlignment.end,&#10;                mainAxisSize: MainAxisSize.min,&#10;                children: [&#10;                  AutoSizeText(&#10;                    trainer?.username ?? '',&#10;                    style: TextStyle(&#10;                      fontSize: 20,&#10;                      color: Colors.white,&#10;                      fontWeight: FontWeight.bold,&#10;                      decoration: TextDecoration.none, // Remove underline&#10;                      shadows: [Shadow(blurRadius: 4, color: Colors.black45, offset: Offset(1,1))],&#10;                    ),&#10;                    maxLines: 1,&#10;                    minFontSize: 10,&#10;                    overflow: TextOverflow.ellipsis,&#10;                  ),&#10;                  AutoSizeText(&#10;                    'Level: ${trainer?.level ?? ''}',&#10;                    style: TextStyle(&#10;                      fontSize: 16,&#10;                      color: Colors.white70,&#10;                      fontWeight: FontWeight.w600,&#10;                      decoration: TextDecoration.none,&#10;                      shadows: [Shadow(blurRadius: 4, color: Colors.black26, offset: Offset(1,1))],&#10;                    ),&#10;                    maxLines: 1,&#10;                    minFontSize: 8,&#10;                    overflow: TextOverflow.ellipsis,&#10;                  ),&#10;                  if (trainer != null)&#10;                    Padding(&#10;                      padding: const EdgeInsets.only(top: 4.0),&#10;                      child: Column(&#10;                        crossAxisAlignment: CrossAxisAlignment.end,&#10;                        children: [&#10;                          AutoSizeText(&#10;                            'XP: ${trainer!.experiencePoints} / ${(100 * trainer!.level * 1.1).toInt()}',&#10;                            style: TextStyle(&#10;                              color: Colors.lightGreenAccent,&#10;                              fontSize: 14,&#10;                              fontWeight: FontWeight.bold,&#10;                              decoration: TextDecoration.none,&#10;                            ),&#10;                            maxLines: 1,&#10;                            minFontSize: 8,&#10;                            overflow: TextOverflow.ellipsis,&#10;&#10;                          ),&#10;                          SizedBox(height: 4),&#10;                          SizedBox(&#10;                            width: 125,&#10;                            child: LinearProgressIndicator(&#10;                              value: trainer!.experiencePoints / (100 * trainer!.level * 1.1),&#10;                              minHeight: 7,&#10;                              backgroundColor: Colors.grey[800],&#10;                              valueColor: AlwaysStoppedAnimation&lt;Color&gt;(Colors.amber),&#10;                            ),&#10;                          ),&#10;                        ],&#10;                      ),&#10;                    ),&#10;                ],&#10;              ),&#10;            ),&#10;          ),&#10;        ),&#10;      ],&#10;    );&#10;  }&#10;&#10;  @override&#10;  void dispose() {&#10;    _controller?.dispose();&#10;    super.dispose();&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lib/pages/login_form.dart">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lib/pages/login_form.dart" />
              <option name="originalContent" value="import 'package:flutter/material.dart';&#10;import 'package:crypto/crypto.dart';&#10;import 'dart:convert';&#10;import 'package:supabase_flutter/supabase_flutter.dart';&#10;&#10;class LoginFormPage extends StatefulWidget {&#10;  const LoginFormPage({Key? key}) : super(key: key);&#10;&#10;  @override&#10;  State&lt;LoginFormPage&gt; createState() =&gt; _LoginFormPageState();&#10;}&#10;&#10;class _LoginFormPageState extends State&lt;LoginFormPage&gt; {&#10;  final _formKey = GlobalKey&lt;FormState&gt;();&#10;  String _email = '';&#10;  String _password = '';&#10;&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    return Scaffold(&#10;      appBar: AppBar(&#10;        title: const Text('Login'),&#10;        automaticallyImplyLeading: true,&#10;        leading: IconButton(&#10;          icon: const Icon(Icons.arrow_back),&#10;          onPressed: () {&#10;            Navigator.pop(context);&#10;          },&#10;        ),&#10;      ),&#10;      body: Stack(&#10;        children: [&#10;          Positioned.fill(&#10;            child: Image.asset(&#10;              'assets/background/mobile_grid_background_2.jpg',&#10;              fit: BoxFit.cover,&#10;              color: Colors.white.withOpacity(0.85),&#10;              colorBlendMode: BlendMode.lighten,&#10;            ),&#10;          ),&#10;          Center(&#10;            child: Card(&#10;              elevation: 12,&#10;              shape: RoundedRectangleBorder(&#10;                borderRadius: BorderRadius.circular(24),&#10;                side: BorderSide(color: Colors.redAccent, width: 4),&#10;              ),&#10;              color: Colors.white.withOpacity(0.95),&#10;              child: Padding(&#10;                padding: const EdgeInsets.symmetric(horizontal: 32, vertical: 32),&#10;                child: Form(&#10;                  key: _formKey,&#10;                  child: Column(&#10;                    mainAxisSize: MainAxisSize.min,&#10;                    children: [&#10;                      Icon(Icons.catching_pokemon, size: 64, color: Colors.redAccent),&#10;                      const SizedBox(height: 12),&#10;                      Text(&#10;                        'Login',&#10;                        style: TextStyle(&#10;                          fontSize: 24,&#10;                          fontWeight: FontWeight.bold,&#10;                          color: Colors.redAccent,&#10;                          fontFamily: 'PressStart2P',&#10;                          letterSpacing: 1.5,&#10;                        ),&#10;                        textAlign: TextAlign.center,&#10;                      ),&#10;                      const SizedBox(height: 24),&#10;                      TextFormField(&#10;                        decoration: const InputDecoration(labelText: 'Email'),&#10;                        onChanged: (value) =&gt; _email = value,&#10;                        validator: (value) =&gt; value == null || value.isEmpty ? 'Enter your email' : null,&#10;                      ),&#10;                      const SizedBox(height: 16),&#10;                      TextFormField(&#10;                        decoration: const InputDecoration(labelText: 'Password'),&#10;                        obscureText: true,&#10;                        onChanged: (value) =&gt; _password = value,&#10;                        validator: (value) =&gt; value == null || value.isEmpty ? 'Enter your password' : null,&#10;                      ),&#10;                      const SizedBox(height: 24),&#10;                      SizedBox(&#10;                        width: 200,&#10;                        child: ElevatedButton(&#10;                          style: ElevatedButton.styleFrom(&#10;                            backgroundColor: Colors.redAccent,&#10;                            foregroundColor: Colors.white,&#10;                            shape: RoundedRectangleBorder(&#10;                              borderRadius: BorderRadius.circular(12),&#10;                            ),&#10;                            textStyle: const TextStyle(&#10;                              fontWeight: FontWeight.bold,&#10;                              fontFamily: 'Fredoka',&#10;                            ),&#10;                          ),&#10;                          onPressed: () async {&#10;                            if (_formKey.currentState!.validate()) {&#10;                              final client = Supabase.instance.client;&#10;                              try {&#10;                                final user = await client.auth.signInWithPassword(&#10;                                  email: _email,&#10;                                  password: _password,&#10;                                );&#10;                                // Login successful&#10;                                if (user.user != null) {&#10;                                  if (!mounted) return;&#10;                                  print('✅ Welcome \\${user.user!.email}');&#10;                                  final userId = client.auth.currentUser?.id;&#10;                                  if (trainer == null) {&#10;                                    // Prompt for username and gender&#10;                                    final result = await showDialog&lt;Map&lt;String, String&gt;&gt;(&#10;                                      context: context,&#10;                                      barrierDismissible: false,&#10;                                      builder: (context) {&#10;                                        String username = '';&#10;                                        String gender = 'Male';&#10;                                        return AlertDialog(&#10;                                          title: const Text('Complete Your Profile'),&#10;                                          content: Column(&#10;                                            mainAxisSize: MainAxisSize.min,&#10;                                            children: [&#10;                                              TextFormField(&#10;                                                decoration: const InputDecoration(labelText: 'Username'),&#10;                                                onChanged: (value) =&gt; username = value,&#10;                                              ),&#10;                                              DropdownButtonFormField&lt;String&gt;(&#10;                                                value: gender,&#10;                                                decoration: const InputDecoration(labelText: 'Gender'),&#10;                                                items: const [&#10;                                                  DropdownMenuItem(value: 'Male', child: Text('Male')),&#10;                                                  DropdownMenuItem(value: 'Female', child: Text('Female')),&#10;                                                  DropdownMenuItem(value: 'Other', child: Text('Other')),&#10;                                                ],&#10;                                                onChanged: (value) {&#10;                                                  if (value != null) gender = value;&#10;                                                },&#10;                                              ),&#10;                                            ],&#10;                                          ),&#10;                                          actions: [&#10;                                            TextButton(&#10;                                              onPressed: () {&#10;                                                if (username.isNotEmpty) {&#10;                                                  Navigator.of(context).pop({'username': username, 'gender': gender});&#10;                                                }&#10;                                              },&#10;                                              child: const Text('Continue'),&#10;                                            ),&#10;                                          ],&#10;                                        );&#10;                                      },&#10;                                    );&#10;                                    if (result != null &amp;&amp; result['username'] != null) {&#10;                                      await client.from('trainer_table').insert({&#10;                                        'trainer_id': userId,&#10;                                        'username': result['username'],&#10;                                        'sex': result['gender'],&#10;                                        'created_at': DateTime.now().toIso8601String(),&#10;                                        'wins': 0,&#10;                                        'losses': 0,&#10;                                        'completed_tasks': 0,&#10;                                        'level': 1,&#10;                                        'experience_points': 0,&#10;                                      });&#10;                                      ScaffoldMessenger.of(context).showSnackBar(&#10;                                        const SnackBar(content: Text('Profile created!')),&#10;                                      );&#10;                                      Navigator.pushReplacementNamed(&#10;                                        context,&#10;                                        '/starter_select',&#10;                                        arguments: {'trainer_id': userId},&#10;                                      );&#10;                                    }&#10;                                  } else {&#10;                                    ScaffoldMessenger.of(context).showSnackBar(&#10;                                      const SnackBar(content: Text('Login successful!')),&#10;                                    );&#10;                                    Navigator.pushReplacementNamed(&#10;                                      context,&#10;                                      'home',&#10;                                      arguments: {'trainer_id': userId},&#10;                                    );&#10;                                  }&#10;                                }&#10;                              } on AuthException catch (e) {&#10;                                if (!mounted) return;&#10;                                print('❌ Login error: \\${e.message}');&#10;                                ScaffoldMessenger.of(context).showSnackBar(&#10;                                  SnackBar(content: Text('Invalid email or password. Please try again.')),&#10;                                );&#10;                              } catch (e) {&#10;                                if (!mounted) return;&#10;                                print('❌ Login error: \\${e.toString()}');&#10;                                ScaffoldMessenger.of(context).showSnackBar(&#10;                                  SnackBar(content: Text('An unexpected error occurred. Please try again.')),&#10;                                );&#10;                              }&#10;                            }&#10;                          },&#10;                          child: const Text('Login'),&#10;                        ),&#10;                      ),&#10;                    ],&#10;                  ),&#10;                ),&#10;              ),&#10;            ),&#10;          ),&#10;        ],&#10;      ),&#10;    );&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import 'package:flutter/material.dart';&#10;import 'package:crypto/crypto.dart';&#10;import 'dart:convert';&#10;import 'package:supabase_flutter/supabase_flutter.dart';&#10;&#10;class LoginFormPage extends StatefulWidget {&#10;  const LoginFormPage({Key? key}) : super(key: key);&#10;&#10;  @override&#10;  State&lt;LoginFormPage&gt; createState() =&gt; _LoginFormPageState();&#10;}&#10;&#10;class _LoginFormPageState extends State&lt;LoginFormPage&gt; {&#10;  final _formKey = GlobalKey&lt;FormState&gt;();&#10;  String _email = '';&#10;  String _password = '';&#10;&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    return Scaffold(&#10;      appBar: AppBar(&#10;        title: const Text('Login'),&#10;        automaticallyImplyLeading: true,&#10;        leading: IconButton(&#10;          icon: const Icon(Icons.arrow_back),&#10;          onPressed: () {&#10;            Navigator.pop(context);&#10;          },&#10;        ),&#10;      ),&#10;      body: Stack(&#10;        children: [&#10;          Positioned.fill(&#10;            child: Image.asset(&#10;              'assets/background/mobile_grid_background_2.jpg',&#10;              fit: BoxFit.cover,&#10;              color: Colors.white.withOpacity(0.85),&#10;              colorBlendMode: BlendMode.lighten,&#10;            ),&#10;          ),&#10;          Center(&#10;            child: Card(&#10;              elevation: 12,&#10;              shape: RoundedRectangleBorder(&#10;                borderRadius: BorderRadius.circular(24),&#10;                side: BorderSide(color: Colors.redAccent, width: 4),&#10;              ),&#10;              color: Colors.white.withOpacity(0.95),&#10;              child: Padding(&#10;                padding: const EdgeInsets.symmetric(horizontal: 32, vertical: 32),&#10;                child: Form(&#10;                  key: _formKey,&#10;                  child: Column(&#10;                    mainAxisSize: MainAxisSize.min,&#10;                    children: [&#10;                      Icon(Icons.catching_pokemon, size: 64, color: Colors.redAccent),&#10;                      const SizedBox(height: 12),&#10;                      Text(&#10;                        'Login',&#10;                        style: TextStyle(&#10;                          fontSize: 24,&#10;                          fontWeight: FontWeight.bold,&#10;                          color: Colors.redAccent,&#10;                          fontFamily: 'PressStart2P',&#10;                          letterSpacing: 1.5,&#10;                        ),&#10;                        textAlign: TextAlign.center,&#10;                      ),&#10;                      const SizedBox(height: 24),&#10;                      TextFormField(&#10;                        decoration: const InputDecoration(labelText: 'Email'),&#10;                        onChanged: (value) =&gt; _email = value,&#10;                        validator: (value) =&gt; value == null || value.isEmpty ? 'Enter your email' : null,&#10;                      ),&#10;                      const SizedBox(height: 16),&#10;                      TextFormField(&#10;                        decoration: const InputDecoration(labelText: 'Password'),&#10;                        obscureText: true,&#10;                        onChanged: (value) =&gt; _password = value,&#10;                        validator: (value) =&gt; value == null || value.isEmpty ? 'Enter your password' : null,&#10;                      ),&#10;                      const SizedBox(height: 24),&#10;                      SizedBox(&#10;                        width: 200,&#10;                        child: ElevatedButton(&#10;                          style: ElevatedButton.styleFrom(&#10;                            backgroundColor: Colors.redAccent,&#10;                            foregroundColor: Colors.white,&#10;                            shape: RoundedRectangleBorder(&#10;                              borderRadius: BorderRadius.circular(12),&#10;                            ),&#10;                            textStyle: const TextStyle(&#10;                              fontWeight: FontWeight.bold,&#10;                              fontFamily: 'Fredoka',&#10;                            ),&#10;                          ),&#10;                          onPressed: () async {&#10;                            if (_formKey.currentState!.validate()) {&#10;                              final client = Supabase.instance.client;&#10;                              try {&#10;                                final user = await client.auth.signInWithPassword(&#10;                                  email: _email,&#10;                                  password: _password,&#10;                                );&#10;                                // Login successful&#10;                                if (user.user != null) {&#10;                                  if (!mounted) return;&#10;                                  print('✅ Welcome \\${user.user!.email}');&#10;                                  final userId = client.auth.currentUser?.id;&#10;                                  if (userId == null) {&#10;                                    ScaffoldMessenger.of(context).showSnackBar(&#10;                                      const SnackBar(content: Text('Login failed: No user ID found. Please try again.')),&#10;                                    );&#10;                                    return;&#10;                                  }&#10;                                  // Check if trainer record exists&#10;                                  final trainer = await client&#10;                                      .from('trainer_table')&#10;                                      .select('trainer_id')&#10;                                      .eq('trainer_id', userId)&#10;                                      .maybeSingle();&#10;                                  if (trainer == null) {&#10;                                    // Prompt for username and gender&#10;                                    final result = await showDialog&lt;Map&lt;String, String&gt;&gt;(&#10;                                      context: context,&#10;                                      barrierDismissible: false,&#10;                                      builder: (context) {&#10;                                        String username = '';&#10;                                        String gender = 'Male';&#10;                                        return AlertDialog(&#10;                                          title: const Text('Complete Your Profile'),&#10;                                          content: Column(&#10;                                            mainAxisSize: MainAxisSize.min,&#10;                                            children: [&#10;                                              TextFormField(&#10;                                                decoration: const InputDecoration(labelText: 'Username'),&#10;                                                onChanged: (value) =&gt; username = value,&#10;                                              ),&#10;                                              DropdownButtonFormField&lt;String&gt;(&#10;                                                value: gender,&#10;                                                decoration: const InputDecoration(labelText: 'Gender'),&#10;                                                items: const [&#10;                                                  DropdownMenuItem(value: 'Male', child: Text('Male')),&#10;                                                  DropdownMenuItem(value: 'Female', child: Text('Female')),&#10;                                                  DropdownMenuItem(value: 'Other', child: Text('Other')),&#10;                                                ],&#10;                                                onChanged: (value) {&#10;                                                  if (value != null) gender = value;&#10;                                                },&#10;                                              ),&#10;                                            ],&#10;                                          ),&#10;                                          actions: [&#10;                                            TextButton(&#10;                                              onPressed: () {&#10;                                                if (username.isNotEmpty) {&#10;                                                  Navigator.of(context).pop({'username': username, 'gender': gender});&#10;                                                }&#10;                                              },&#10;                                              child: const Text('Continue'),&#10;                                            ),&#10;                                          ],&#10;                                        );&#10;                                      },&#10;                                    );&#10;                                    if (result != null &amp;&amp; result['username'] != null) {&#10;                                      await client.from('trainer_table').insert({&#10;                                        'trainer_id': userId,&#10;                                        'username': result['username'],&#10;                                        'sex': result['gender'],&#10;                                        'created_at': DateTime.now().toIso8601String(),&#10;                                        'wins': 0,&#10;                                        'losses': 0,&#10;                                        'completed_tasks': 0,&#10;                                        'level': 1,&#10;                                        'experience_points': 0,&#10;                                      });&#10;                                      ScaffoldMessenger.of(context).showSnackBar(&#10;                                        const SnackBar(content: Text('Profile created!')),&#10;                                      );&#10;                                      Navigator.pushReplacementNamed(&#10;                                        context,&#10;                                        '/starter_select',&#10;                                        arguments: {'trainer_id': userId},&#10;                                      );&#10;                                    }&#10;                                  } else {&#10;                                    ScaffoldMessenger.of(context).showSnackBar(&#10;                                      const SnackBar(content: Text('Login successful!')),&#10;                                    );&#10;                                    Navigator.pushReplacementNamed(&#10;                                      context,&#10;                                      'home',&#10;                                      arguments: {'trainer_id': userId},&#10;                                    );&#10;                                  }&#10;                                }&#10;                              } on AuthException catch (e) {&#10;                                if (!mounted) return;&#10;                                print('❌ Login error: \\${e.message}');&#10;                                ScaffoldMessenger.of(context).showSnackBar(&#10;                                  SnackBar(content: Text('Invalid email or password. Please try again.')),&#10;                                );&#10;                              } catch (e) {&#10;                                if (!mounted) return;&#10;                                print('❌ Login error: \\${e.toString()}');&#10;                                ScaffoldMessenger.of(context).showSnackBar(&#10;                                  SnackBar(content: Text('An unexpected error occurred. Please try again.')),&#10;                                );&#10;                              }&#10;                            }&#10;                          },&#10;                          child: const Text('Login'),&#10;                        ),&#10;                      ),&#10;                    ],&#10;                  ),&#10;                ),&#10;              ),&#10;            ),&#10;          ),&#10;        ],&#10;      ),&#10;    );&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lib/pages/open.dart">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lib/pages/open.dart" />
              <option name="originalContent" value="//login or signup options&#10;import 'package:flutter/material.dart';&#10;import 'package:flutter_dotenv/flutter_dotenv.dart';&#10;import '../services/music_service.dart';&#10;&#10;final supabaseUrl = dotenv.env['SUPABASE_URL'];&#10;class OpenPage extends StatefulWidget {&#10;  const OpenPage({super.key});&#10;&#10;  @override&#10;  State&lt;OpenPage&gt; createState() =&gt; _OpenPageState();&#10;}&#10;&#10;class _OpenPageState extends State&lt;OpenPage&gt; {&#10;  bool _isMuted = MusicService().isMuted;&#10;&#10;  void _toggleMute() async {&#10;    await MusicService().setMute(!_isMuted);&#10;    setState(() {&#10;      _isMuted = !_isMuted;&#10;    });&#10;  }&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    return Scaffold(&#10;      appBar: AppBar(&#10;        title: const Text('Welcome to Poketask!'),&#10;        actions: [&#10;          IconButton(&#10;            icon: Icon(_isMuted ? Icons.volume_off : Icons.volume_up),&#10;            tooltip: _isMuted ? 'Unmute Music' : 'Mute Music',&#10;            onPressed: _toggleMute,&#10;          ),&#10;        ],&#10;      ),&#10;      body: Stack(&#10;        children: [&#10;          Positioned.fill(&#10;            child: Image.asset(&#10;              'assets/background/mobile_grid_background_2.jpg',&#10;              fit: BoxFit.cover,&#10;              color: Colors.white.withOpacity(0.85),&#10;              colorBlendMode: BlendMode.lighten,&#10;            ),&#10;          ),&#10;          Center(&#10;            child: Card(&#10;              elevation: 12,&#10;              shape: RoundedRectangleBorder(&#10;                borderRadius: BorderRadius.circular(24),&#10;                side: BorderSide(color: Colors.redAccent, width: 4),&#10;              ),&#10;              color: Colors.white.withOpacity(0.95),&#10;              child: Padding(&#10;                padding: const EdgeInsets.symmetric(horizontal: 32, vertical: 32),&#10;                child: Column(&#10;                  mainAxisSize: MainAxisSize.min,&#10;                  children: &lt;Widget&gt;[&#10;                    Icon(Icons.catching_pokemon, size: 64, color: Colors.redAccent),&#10;                    const SizedBox(height: 12),&#10;                    Text(&#10;                      'Welcome to Poketask!',&#10;                      style: TextStyle(&#10;                        fontSize: 24,&#10;                        fontWeight: FontWeight.bold,&#10;                        color: Colors.redAccent,&#10;                        fontFamily: 'PressStart2P',&#10;                        letterSpacing: 1.5,&#10;                      ),&#10;                      textAlign: TextAlign.center,&#10;                    ),&#10;                    const SizedBox(height: 24),&#10;                    SizedBox(&#10;                      width: 200,&#10;                      child: ElevatedButton(&#10;                        style: ElevatedButton.styleFrom(&#10;                          backgroundColor: Colors.redAccent,&#10;                          foregroundColor: Colors.white,&#10;                          shape: RoundedRectangleBorder(&#10;                            borderRadius: BorderRadius.circular(12),&#10;                          ),&#10;                          textStyle: const TextStyle(&#10;                            fontWeight: FontWeight.bold,&#10;                            fontFamily: 'Fredoka',&#10;                          ),&#10;                        ),&#10;                        onPressed: () {&#10;                          Navigator.pushNamed(context, '/login');&#10;                        },&#10;                        child: const Text('Login'),&#10;                      ),&#10;                    ),&#10;                    const SizedBox(height: 10),&#10;                    SizedBox(&#10;                      width: 200,&#10;                      child: ElevatedButton(&#10;                        style: ElevatedButton.styleFrom(&#10;                          backgroundColor: Colors.black,&#10;                          foregroundColor: Colors.white,&#10;                          shape: RoundedRectangleBorder(&#10;                            borderRadius: BorderRadius.circular(12),&#10;                          ),&#10;                          textStyle: const TextStyle(&#10;                            fontWeight: FontWeight.bold,&#10;                            fontFamily: 'Fredoka',&#10;                          ),&#10;                        ),&#10;                        onPressed: () {&#10;                          Navigator.pushNamed(context, '/signup');&#10;                        },&#10;                        child: const Text('Sign Up'),&#10;                      ),&#10;                    ),&#10;                    const SizedBox(height: 6),&#10;                    GestureDetector(&#10;                      onTap: () {&#10;                        Navigator.pushNamed(context, '/reset-password');&#10;                      },&#10;                      child:&#10;                        Text(&quot;reset password&quot;,&#10;                          style: TextStyle(&#10;                            color: Colors.blueAccent,&#10;                            decoration: TextDecoration.underline,&#10;                            decorationColor: Colors.blueAccent,&#10;                          ),&#10;                    )&#10;                    )&#10;                  ],&#10;                ),&#10;              ),&#10;            ),&#10;          ),&#10;        ],&#10;      ),&#10;    );&#10;  }&#10;}" />
              <option name="updatedContent" value="//login or signup options&#10;import 'package:flutter/material.dart';&#10;import 'package:flutter_dotenv/flutter_dotenv.dart';&#10;import '../services/music_service.dart';&#10;&#10;final supabaseUrl = dotenv.env['SUPABASE_URL'];&#10;class OpenPage extends StatefulWidget {&#10;  const OpenPage({super.key});&#10;&#10;  @override&#10;  State&lt;OpenPage&gt; createState() =&gt; _OpenPageState();&#10;}&#10;&#10;class _OpenPageState extends State&lt;OpenPage&gt; {&#10;  bool _isMuted = MusicService().isMuted;&#10;&#10;  void _toggleMute() async {&#10;    await MusicService().setMute(!_isMuted);&#10;    setState(() {&#10;      _isMuted = !_isMuted;&#10;    });&#10;  }&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    return Scaffold(&#10;      appBar: AppBar(&#10;        title: const Text('Welcome to Poketask!'),&#10;        actions: [&#10;          IconButton(&#10;            icon: Icon(_isMuted ? Icons.volume_off : Icons.volume_up),&#10;            tooltip: _isMuted ? 'Unmute Music' : 'Mute Music',&#10;            onPressed: _toggleMute,&#10;          ),&#10;        ],&#10;      ),&#10;      body: Stack(&#10;        children: [&#10;          Positioned.fill(&#10;            child: Image.asset(&#10;              'assets/background/mobile_grid_background_2.jpg',&#10;              fit: BoxFit.cover,&#10;              color: Colors.white.withOpacity(0.85),&#10;              colorBlendMode: BlendMode.lighten,&#10;            ),&#10;          ),&#10;          Center(&#10;            child: Card(&#10;              elevation: 12,&#10;              shape: RoundedRectangleBorder(&#10;                borderRadius: BorderRadius.circular(24),&#10;                side: BorderSide(color: Colors.redAccent, width: 4),&#10;              ),&#10;              color: Colors.white.withOpacity(0.95),&#10;              child: Padding(&#10;                padding: const EdgeInsets.symmetric(horizontal: 32, vertical: 32),&#10;                child: Column(&#10;                  mainAxisSize: MainAxisSize.min,&#10;                  children: &lt;Widget&gt;[&#10;                    Icon(Icons.catching_pokemon, size: 64, color: Colors.redAccent),&#10;                    const SizedBox(height: 12),&#10;                    Text(&#10;                      'Welcome to Poketask!',&#10;                      style: TextStyle(&#10;                        fontSize: 24,&#10;                        fontWeight: FontWeight.bold,&#10;                        color: Colors.redAccent,&#10;                        fontFamily: 'PressStart2P',&#10;                        letterSpacing: 1.5,&#10;                      ),&#10;                      textAlign: TextAlign.center,&#10;                    ),&#10;                    const SizedBox(height: 24),&#10;                    SizedBox(&#10;                      width: 200,&#10;                      child: ElevatedButton(&#10;                        style: ElevatedButton.styleFrom(&#10;                          backgroundColor: Colors.redAccent,&#10;                          foregroundColor: Colors.white,&#10;                          shape: RoundedRectangleBorder(&#10;                            borderRadius: BorderRadius.circular(12),&#10;                          ),&#10;                          textStyle: const TextStyle(&#10;                            fontWeight: FontWeight.bold,&#10;                            fontFamily: 'Fredoka',&#10;                          ),&#10;                        ),&#10;                        onPressed: () {&#10;                          Navigator.pushNamed(context, '/login');&#10;                        },&#10;                        child: const Text('Login'),&#10;                      ),&#10;                    ),&#10;                    const SizedBox(height: 10),&#10;                    SizedBox(&#10;                      width: 200,&#10;                      child: ElevatedButton(&#10;                        style: ElevatedButton.styleFrom(&#10;                          backgroundColor: Colors.black,&#10;                          foregroundColor: Colors.white,&#10;                          shape: RoundedRectangleBorder(&#10;                            borderRadius: BorderRadius.circular(12),&#10;                          ),&#10;                          textStyle: const TextStyle(&#10;                            fontWeight: FontWeight.bold,&#10;                            fontFamily: 'Fredoka',&#10;                          ),&#10;                        ),&#10;                        onPressed: () {&#10;                          Navigator.pushNamed(context, '/signup');&#10;                        },&#10;                        child: const Text('Sign Up'),&#10;                      ),&#10;                    ),&#10;                    const SizedBox(height: 6),&#10;                    GestureDetector(&#10;                      onTap: () {&#10;                        Navigator.pushNamed(context, '/reset_password');&#10;                      },&#10;                      child:&#10;                        Text(&quot;reset password&quot;,&#10;                          style: TextStyle(&#10;                            color: Colors.blueAccent,&#10;                            decoration: TextDecoration.underline,&#10;                            decorationColor: Colors.blueAccent,&#10;                          ),&#10;                    )&#10;                    )&#10;                  ],&#10;                ),&#10;              ),&#10;            ),&#10;          ),&#10;        ],&#10;      ),&#10;    );&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lib/pages/pokebattle_page.dart">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lib/pages/pokebattle_page.dart" />
              <option name="originalContent" value="import 'package:flutter/material.dart';&#10;import '../mcts/pokebattle_controller.dart';&#10;import '../models/battle_game_state.dart';&#10;import '../models/pokemon_mcts.dart';&#10;import '../models/ability_mcts.dart';&#10;import '../mcts/mcts_search.dart'; // For direct MCTS call&#10;import 'package:animated_text_kit/animated_text_kit.dart';&#10;import '../services/music_service.dart';&#10;import '../services/xp_utils.dart';&#10;import '../services/ability_utils.dart';&#10;import 'package:supabase_flutter/supabase_flutter.dart';&#10;&#10;&#10;class PokeBattlePage extends StatefulWidget {&#10;  final String trainerId;&#10;  const PokeBattlePage({super.key, required this.trainerId});&#10;&#10;  @override&#10;  State&lt;PokeBattlePage&gt; createState() =&gt; _PokeBattlePageState();&#10;}&#10;&#10;class _PokeBattlePageState extends State&lt;PokeBattlePage&gt; {&#10;  late PokeBattleController? controller;&#10;  String? lastAiAction;&#10;  bool playerJustAttacked = false;&#10;  bool opponentJustAttacked = false;&#10;&#10;  String narration = &quot;&quot;;&#10;  bool isAnimating = false;&#10;&#10;  bool isMusicPlaying = true;&#10;&#10;  String selectedArena = &quot;&quot;;&#10;  String selectedArenaText = &quot;&quot;;&#10;  final List&lt;String&gt; arenaTypes = [&#10;    'desert', 'water', 'snow', 'hills', 'cave', 'beach', 'grass'&#10;  ];&#10;&#10;  final bool movesExpanded = true;&#10;&#10;  bool isLoading = true;&#10;&#10;  String? winnerTrainerName;&#10;&#10;  bool hasHandledBattleEnd = false;&#10;&#10;  String? playerTrainerName;&#10;  String? opponentTrainerName;&#10;  String? playerName;&#10;  String? opponentName;&#10;&#10;  @override&#10;  void initState() {&#10;    super.initState();&#10;    // Stop menu music before starting battle music&#10;    MusicService().stopMusic();&#10;    playBattleMusic();&#10;    isMusicPlaying = true;&#10;    controller = null;&#10;    _initTeams();&#10;  }&#10;&#10;  Future&lt;void&gt; _initTeams() async {&#10;    setState(() { isLoading = true; });&#10;    final supabase = Supabase.instance.client;&#10;    // Fetch player trainer row&#10;    final trainerRes = await supabase&#10;      .from('trainer_table')&#10;      .select()&#10;      .eq('trainer_id', widget.trainerId)&#10;      .maybeSingle(); // safer than .single()&#10;    if (trainerRes == null) {&#10;      setState(() { narration = &quot;Trainer not found.&quot;; isLoading = false; });&#10;      return;&#10;    }&#10;    playerTrainerName = trainerRes['username'] ?? 'You';&#10;    playerName = playerTrainerName;&#10;    // Get player team&#10;    final playerTeam = await _fetchTeamFromTrainerRow(trainerRes);&#10;    if (playerTeam.isEmpty) {&#10;      setState(() {&#10;        narration = &quot;You have no Pokémon in your team. Please add Pokémon before battling.&quot;;&#10;        isLoading = false;&#10;      });&#10;      return;&#10;    }&#10;    // Get random opponent trainer&#10;    final trainers = await supabase&#10;      .from('trainer_table')&#10;      .select('trainer_id,username');&#10;    final opponentIds = trainers.where((t) =&gt; t['trainer_id'] != widget.trainerId).toList();&#10;    opponentIds.shuffle();&#10;    final opponentId = opponentIds.isNotEmpty ? opponentIds.first['trainer_id'] : widget.trainerId;&#10;    final opponentRes = await supabase&#10;      .from('trainer_table')&#10;      .select()&#10;      .eq('trainer_id', opponentId)&#10;      .maybeSingle(); // safer than .single()&#10;    opponentTrainerName = opponentRes?['username'] ?? 'Opponent';&#10;    opponentName = opponentTrainerName;&#10;    final opponentTeam = await _fetchTeamFromTrainerRow(opponentRes ?? {});&#10;    if (opponentTeam.isEmpty) {&#10;      setState(() {&#10;        narration = &quot;Opponent has no Pokémon. Try again later.&quot;;&#10;        isLoading = false;&#10;      });&#10;      return;&#10;    }&#10;    // Setup battle state&#10;    final state = BattleGameState(&#10;      playerTeam: playerTeam,&#10;      opponentTeam: opponentTeam,&#10;    );&#10;    setState(() {&#10;      controller = PokeBattleController(gameState: state);&#10;      // Randomly select an arena type&#10;      final rand = arenaTypes..shuffle();&#10;      selectedArena = rand.first;&#10;      selectedArenaText = selectedArena[0].toUpperCase() + selectedArena.substring(1);&#10;      isLoading = false;&#10;    });&#10;  }&#10;&#10;  Future&lt;List&lt;Pokemon_mcts&gt;&gt; _fetchTeamFromTrainerRow(Map trainerRow) async {&#10;    final supabase = Supabase.instance.client;&#10;    List&lt;Pokemon_mcts&gt; team = [];&#10;    for (int i = 1; i &lt;= 6; i++) {&#10;      final slotKey = 'pokemon_slot_$i';&#10;      final pokeId = trainerRow[slotKey];&#10;      if (pokeId == null) continue;&#10;      final pokeRes = await supabase&#10;        .from('pokemon_table')&#10;        .select()&#10;        .eq('pokemon_id', pokeId)&#10;        .maybeSingle(); // safer than .single()&#10;      if (pokeRes == null) continue;&#10;      // Fetch abilities&#10;      List&lt;Ability_mcts&gt; abilities = [];&#10;      for (int j = 1; j &lt;= 4; j++) {&#10;        final abKey = 'ability$j';&#10;        final abId = pokeRes[abKey];&#10;        if (abId == null) continue;&#10;        final abRes = await supabase&#10;          .from('abilities_table')&#10;          .select()&#10;          .eq('ability_id', abId)&#10;          .maybeSingle(); // safer than .single()&#10;        if (abRes == null) continue;&#10;        abilities.add(Ability_mcts(&#10;          name: abRes['ability_name'],&#10;          type: abRes['type'],&#10;          maxUses: abRes['uses'],&#10;          hitRate: abRes['hitrate'],&#10;          value: abRes['value'],&#10;        ));&#10;      }&#10;      team.add(Pokemon_mcts(&#10;        pokemonName: pokeRes['pokemon_name'],&#10;        nickname: pokeRes['nickname'],&#10;        type: pokeRes['type'],&#10;        level: pokeRes['level'],&#10;        attack: pokeRes['attack'],&#10;        maxHealth: pokeRes['health'],&#10;        abilities: abilities,&#10;      ));&#10;    }&#10;    return team;&#10;  }&#10;&#10;  String getEffectivenessText(double multiplier) {&#10;    if (multiplier &gt;= 2.0) return &quot;It's super effective!&quot;;&#10;    if (multiplier &gt;= 1.1) return &quot;It's effective!&quot;;&#10;    if (multiplier &lt;= 0.5) return &quot;It's not very effective...&quot;;&#10;    return &quot;&quot;;&#10;  }&#10;&#10;&#10;&#10;  Future&lt;void&gt; _handleBattleEnd() async {&#10;    if (hasHandledBattleEnd) return;&#10;    hasHandledBattleEnd = true;&#10;    final supabase = Supabase.instance.client;&#10;    final isWin = controller!.getWinner() == 1;&#10;    final isLoss = controller!.getWinner() == -1;&#10;    if (!isWin &amp;&amp; !isLoss) return;&#10;    final trainerRes = await supabase&#10;      .from('trainer_table')&#10;      .select()&#10;      .eq('trainer_id', widget.trainerId)&#10;      .maybeSingle();&#10;    if (trainerRes == null) return;&#10;    // Always set username before using it&#10;    playerTrainerName = trainerRes['username'] ?? 'You';&#10;    playerName = playerTrainerName;&#10;    winnerTrainerName = isWin ? (playerName ?? 'You') : (opponentName ?? 'Opponent');&#10;    int wins = trainerRes['wins'] ?? 0;&#10;    int losses = trainerRes['losses'] ?? 0;&#10;    int xp = trainerRes['experience_points'] ?? 0;&#10;    int level = trainerRes['level'] ?? 1;&#10;    int gainedXp = isWin ? 250 : 100;&#10;    // Use battle context scaler (1.1) and base (100)&#10;    final trainerXpResult = calculateXpAndLevel(&#10;      currentXp: xp,&#10;      currentLevel: level,&#10;      xpChange: gainedXp,&#10;      scaler: 1.1,&#10;      base: 100,&#10;    );&#10;    xp = trainerXpResult.newXp;&#10;    level = trainerXpResult.newLevel;&#10;    bool trainerLeveledUp = trainerXpResult.levelsGained &gt; 0;&#10;    if (isWin) wins += 1;&#10;    if (isLoss) losses += 1;&#10;    await supabase&#10;      .from('trainer_table')&#10;      .update({&#10;        'wins': wins,&#10;        'losses': losses,&#10;        'experience_points': xp,&#10;        'level': level,&#10;      })&#10;      .eq('trainer_id', widget.trainerId);&#10;    List&lt;String&gt; pokemonLevelUps = [];&#10;    List&lt;Future&lt;void&gt;&gt; abilityDialogs = [];&#10;    Set&lt;String&gt; slotPokeIds = {};&#10;    for (int i = 1; i &lt;= 6; i++) {&#10;      final slotKey = 'pokemon_slot_$i';&#10;      final pokeId = trainerRes[slotKey];&#10;      if (pokeId == null) continue;&#10;      slotPokeIds.add(pokeId.toString());&#10;      final pokeRes = await supabase&#10;        .from('pokemon_table')&#10;        .select()&#10;        .eq('pokemon_id', pokeId)&#10;        .maybeSingle();&#10;      if (pokeRes == null) continue;&#10;      int pokeXp = pokeRes['experience_points'] ?? 0;&#10;      int pokeLevel = pokeRes['level'] ?? 1;&#10;      final pokeXpResult = calculateXpAndLevel(&#10;        currentXp: pokeXp,&#10;        currentLevel: pokeLevel,&#10;        xpChange: gainedXp,&#10;        scaler: 1.1,&#10;        base: 100,&#10;      );&#10;      if (pokeXpResult.levelsGained &gt; 0) {&#10;        var tempPoke = Pokemon_mcts(&#10;          pokemonName: pokeRes['pokemon_name'],&#10;          nickname: pokeRes['nickname'],&#10;          type: pokeRes['type'],&#10;          level: pokeLevel,&#10;          attack: pokeRes['attack'],&#10;          maxHealth: pokeRes['health'],&#10;          abilities: [],&#10;        );&#10;        for (int lvl = 0; lvl &lt; pokeXpResult.levelsGained; lvl++) {&#10;          tempPoke = tempPoke.levelUp();&#10;        }&#10;        String pokeName = pokeRes['nickname'] ?? pokeRes['pokemon_name'] ?? 'Pokémon';&#10;        pokemonLevelUps.add('$pokeName (Lv${pokeLevel} → ${pokeXpResult.newLevel})');&#10;        await supabase&#10;          .from('pokemon_table')&#10;          .update({&#10;            'experience_points': pokeXpResult.newXp,&#10;            'level': pokeXpResult.newLevel,&#10;            'health': tempPoke.maxHealth,&#10;            'attack': tempPoke.attack,&#10;          })&#10;          .eq('pokemon_id', pokeId);&#10;      } else {&#10;        await supabase&#10;          .from('pokemon_table')&#10;          .update({&#10;            'experience_points': pokeXpResult.newXp,&#10;            'level': pokeXpResult.newLevel,&#10;          })&#10;          .eq('pokemon_id', pokeId);&#10;      }&#10;      // Always fetch the latest ability IDs after level up&#10;      if (pokeXpResult.levelsGained &gt; 0 &amp;&amp; pokeXpResult.newLevel % 5 == 0) {&#10;        final updatedPokeRes = await supabase&#10;          .from('pokemon_table')&#10;          .select()&#10;          .eq('pokemon_id', pokeId)&#10;          .maybeSingle();&#10;        List&lt;String&gt; currentAbilityIds = [];&#10;        if (updatedPokeRes != null) {&#10;          for (int j = 1; j &lt;= 4; j++) {&#10;            final abId = updatedPokeRes['ability$j'];&#10;            if (abId != null) {&#10;              currentAbilityIds.add(abId.toString());&#10;            }&#10;          }&#10;        }&#10;        final newAbility = await fetchRandomAbilityExcluding(currentAbilityIds);&#10;        if (newAbility != null &amp;&amp; mounted) {&#10;          // Show ability dialog and wait for user action before continuing&#10;          await offerAbilityDialog(&#10;            context: context,&#10;            ability: newAbility,&#10;            pokeId: pokeId,&#10;            currentAbilityIds: currentAbilityIds,&#10;          );&#10;        }&#10;      }&#10;    }&#10;    // --- Favorite Pokémon XP logic ---&#10;    final favoritePokeId = trainerRes['favorite_pokemon'];&#10;    if (favoritePokeId != null) {&#10;      int totalXpChange = slotPokeIds.contains(favoritePokeId.toString()) ? gainedXp * 2 : gainedXp;&#10;      final pokeRes = await supabase&#10;        .from('pokemon_table')&#10;        .select()&#10;        .eq('pokemon_id', favoritePokeId)&#10;        .maybeSingle();&#10;      if (pokeRes != null) {&#10;        int pokeXp = pokeRes['experience_points'] ?? 0;&#10;        int pokeLevel = pokeRes['level'] ?? 1;&#10;        final pokeXpResult = calculateXpAndLevel(&#10;          currentXp: pokeXp,&#10;          currentLevel: pokeLevel,&#10;          xpChange: totalXpChange,&#10;          scaler: 1.1,&#10;          base: 100,&#10;        );&#10;        await supabase&#10;          .from('pokemon_table')&#10;          .update({&#10;            'experience_points': pokeXpResult.newXp,&#10;            'level': pokeXpResult.newLevel,&#10;          })&#10;          .eq('pokemon_id', favoritePokeId);&#10;        // --- Offer ability if favorite leveled up to a multiple of 5 ---&#10;        if (pokeXpResult.levelsGained &gt; 0 &amp;&amp; pokeXpResult.newLevel % 5 == 0) {&#10;          List&lt;String&gt; currentAbilityIds = [];&#10;          for (int j = 1; j &lt;= 4; j++) {&#10;            final abId = pokeRes['ability$j'];&#10;            if (abId != null) currentAbilityIds.add(abId.toString());&#10;          }&#10;          final newAbility = await fetchRandomAbilityExcluding(currentAbilityIds);&#10;          if (newAbility != null &amp;&amp; mounted) {&#10;            await Future.delayed(const Duration(seconds: 2));&#10;            await offerAbilityDialog(&#10;              context: context,&#10;              ability: newAbility,&#10;              pokeId: favoritePokeId.toString(),&#10;              currentAbilityIds: currentAbilityIds,&#10;            );&#10;          }&#10;        }&#10;      }&#10;    }&#10;    String msg = '';&#10;    if (trainerLeveledUp) {&#10;      msg += 'Trainer ${playerName ?? 'You'} leveled up!\n';&#10;      // Add a random Pokémon to the trainer's team and show dialog&#10;      final newPokeId = await addRandomPokemonToTrainer(widget.trainerId);&#10;      if (newPokeId != null) {&#10;        final pokeRes = await supabase&#10;          .from('pokemon_table')&#10;          .select()&#10;          .eq('pokemon_id', newPokeId)&#10;          .maybeSingle();&#10;        if (pokeRes != null &amp;&amp; mounted) {&#10;          await showNewPokemonDialog(context, pokeRes['pokemon_name'], pokeRes['type']);&#10;        }&#10;      }&#10;    }&#10;    if (pokemonLevelUps.isNotEmpty) {&#10;      msg += 'Pokémon leveled up: ${pokemonLevelUps.join(&quot;, &quot;)}!';&#10;    }&#10;    if (!mounted) return;&#10;    setState(() {&#10;      narration = &quot;${winnerTrainerName ?? 'Trainer'} wins!\n&quot; + msg;&#10;    });&#10;    if (pokemonLevelUps.isNotEmpty &amp;&amp; mounted) {&#10;      await showDialog(&#10;        context: context,&#10;        builder: (context) =&gt; AlertDialog(&#10;          title: const Text('Pokémon Leveled Up!'),&#10;          content: Text(pokemonLevelUps.join('\n')),&#10;          actions: [&#10;            TextButton(&#10;              onPressed: () =&gt; Navigator.of(context).pop(),&#10;              child: const Text('OK'),&#10;            ),&#10;          ],&#10;        ),&#10;      );&#10;    }&#10;    await Future.delayed(const Duration(seconds: 2));&#10;    if (!mounted) return;&#10;    if (Navigator.canPop(context)) {&#10;      Navigator.of(context).pop('refresh');&#10;    }&#10;  }&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    if (isLoading || controller == null) {&#10;      return Scaffold(&#10;        appBar: AppBar(title: const Text(&quot;Pokémon Battle&quot;)),&#10;        body: Center(child: narration.isNotEmpty ? Text(narration, style: TextStyle(fontSize: 18, color: Colors.red)) : const CircularProgressIndicator()),&#10;      );&#10;    }&#10;    final activePlayer = controller!.state.getActive(true);&#10;    final activeOpponent = controller!.state.getActive(false);&#10;    if (controller!.isBattleOver) {&#10;      _handleBattleEnd();&#10;    }&#10;    return Scaffold(&#10;      appBar: AppBar(title: const Text(&quot;Pokémon Battle&quot;)),&#10;      backgroundColor: Colors.redAccent,&#10;      body: Container(&#10;        decoration: const BoxDecoration(&#10;          color: Colors.redAccent,&#10;        ),&#10;        child: controller!.isBattleOver&#10;            ? Center(&#10;                child: Text(&#10;                  // Show winnerTrainerName instead of &quot;You win!&quot;&#10;                  controller!.getWinner() == 1&#10;                      ? &quot;${winnerTrainerName ?? 'Trainer'} wins!&quot;&#10;                      : controller!.getWinner() == -1&#10;                          ? &quot;You lose!&quot;&#10;                          : &quot;Draw&quot;,&#10;                  style: const TextStyle(fontSize: 24),&#10;                ),&#10;              )&#10;            : Padding(&#10;                padding: const EdgeInsets.all(12.0),&#10;                child: SingleChildScrollView(&#10;                  child: Column(&#10;                    children: [&#10;                      Container(&#10;                        decoration: BoxDecoration(&#10;                          image: DecorationImage(&#10;                            image: AssetImage('assets/background/' + selectedArena + '-battle-background.jpg'),&#10;                            fit: BoxFit.cover,&#10;                          ),&#10;                          borderRadius: BorderRadius.circular(12),&#10;                        ),&#10;                        child: Column(&#10;                          children: [&#10;                            Container(&#10;                              child: Column(&#10;                                  children: [&#10;                                  Stack(&#10;                                    children:[&#10;                                      _buildPokemonCard(activeOpponent, isOpponent: true),&#10;                                      Row(&#10;                                        mainAxisAlignment: MainAxisAlignment.end,&#10;                                        children: [&#10;                                          IconButton(&#10;                                            icon: Icon(isMusicPlaying ? Icons.music_note : Icons.music_off),&#10;                                            tooltip: isMusicPlaying ? 'Pause Music' : 'Play Music',&#10;                                            onPressed: toggleMusic,&#10;                                          ),&#10;                                        ],&#10;                                      ),&#10;                                    ]&#10;                                  ),&#10;                                  // OPPONENT STATS&#10;&#10;                                  const SizedBox(height: 16),&#10;&#10;                                  // BATTLE ARENA&#10;                                  Stack(&#10;                                    children: [&#10;                                      SizedBox(&#10;                                        height: 140, // Set a fixed height for the battle arena&#10;                                        child: Center(&#10;                                          child: Column(&#10;                                            children: [&#10;                                              if (lastAiAction != null &amp;&amp; lastAiAction!.startsWith(&quot;switch_&quot;))&#10;                                                Text(&#10;                                                  &quot;AI switched to &quot;+activeOpponent.nickname+&quot;!&quot;,&#10;                                                  style: const TextStyle(&#10;                                                    color: Colors.deepOrange,&#10;                                                    fontWeight: FontWeight.bold,&#10;                                                  ),&#10;                                                ),&#10;                                              const SizedBox(height: 8),&#10;                                              Row( //  FIGHTING SCREEN&#10;                                                mainAxisAlignment: MainAxisAlignment.spaceAround,&#10;                                                children: [&#10;                                                  Flexible(&#10;                                                    fit: FlexFit.loose,&#10;                                                    child: FittedBox(&#10;                                                      fit: BoxFit.scaleDown,&#10;                                                      child: _buildAnimatedSprite(activePlayer, shake: opponentJustAttacked),&#10;                                                    ),&#10;                                                  ),&#10;                                                  Flexible(&#10;                                                    fit: FlexFit.loose,&#10;                                                    child: FittedBox(&#10;                                                      fit: BoxFit.scaleDown,&#10;                                                      child: _buildAnimatedSprite(activeOpponent, shake: playerJustAttacked),&#10;                                                    ),&#10;                                                  ),&#10;                                                ],&#10;                                              ),&#10;                                            ],&#10;                                          ),&#10;                                        ),&#10;                                      ),&#10;                                      if (isAnimating)&#10;                                        Padding(&#10;                                          padding: const EdgeInsets.symmetric(vertical: 8.0),&#10;                                          child: Container(&#10;                                            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),&#10;                                            decoration: BoxDecoration(&#10;                                              color: Colors.black.withOpacity(0.6),&#10;                                              borderRadius: BorderRadius.circular(10),&#10;                                            ),&#10;                                            child: Row(&#10;                                              mainAxisSize: MainAxisSize.min,&#10;                                              mainAxisAlignment: MainAxisAlignment.center,&#10;                                              children: const [&#10;                                                SizedBox(&#10;                                                  width: 20,&#10;                                                  height: 20,&#10;                                                  child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white),&#10;                                                ),&#10;                                                SizedBox(width: 12),&#10;                                                Text(&#10;                                                  &quot;AI is thinking...&quot;,&#10;                                                  style: TextStyle(color: Colors.white),&#10;                                                ),&#10;                                              ],&#10;                                            ),&#10;                                          ),&#10;                                        ),&#10;                                    ]&#10;                                  ),&#10;                                  // PLAYER STATS&#10;                                  _buildPokemonCard(activePlayer, isOpponent: false),&#10;&#10;                                ]&#10;                              )&#10;                            ), // battle space&#10;                          ],&#10;                        ),&#10;                      ),&#10;                      Container(&#10;                        color: Colors.redAccent,&#10;                        child: Column(&#10;                          children: [&#10;                            //MOVES AND OTHER STUFF&#10;                            const SizedBox(height: 8),&#10;&#10;                            const SizedBox(height: 8),&#10;                            Padding(&#10;                              padding: const EdgeInsets.symmetric(horizontal: 12.0),&#10;                              // NARRATION&#10;                              child: Container(&#10;                                width: double.infinity,&#10;                                padding: const EdgeInsets.all(12),&#10;                                decoration: BoxDecoration(&#10;                                  color: Colors.cyanAccent,&#10;                                  borderRadius: BorderRadius.circular(8),&#10;                                  border: Border.all(color: Colors.black54, width: 2),&#10;                                ),&#10;                                child: AnimatedTextKit(&#10;                                  key: ValueKey(narration), // ensures animation restarts on narration change&#10;                                  animatedTexts: [&#10;                                    TyperAnimatedText(&#10;                                      narration,&#10;                                      textStyle: const TextStyle(color: Colors.black54, fontSize: 16),&#10;                                      speed: const Duration(milliseconds: 35),&#10;                                    ),&#10;                                  ],&#10;                                  totalRepeatCount: 1,&#10;                                  pause: Duration.zero,&#10;                                  displayFullTextOnTap: true,&#10;                                  stopPauseOnTap: true,&#10;                                ),&#10;                              ),&#10;                            ),&#10;                            const SizedBox(height: 18),&#10;                            // ACTIONS&#10;                            Column(&#10;                              crossAxisAlignment: CrossAxisAlignment.stretch,&#10;                              children: [&#10;                                ExpansionTile(&#10;                                  title: const Text(&quot;Moves&quot;, style: TextStyle(fontWeight: FontWeight.bold)),&#10;                                  initiallyExpanded: movesExpanded,&#10;                                  children: [&#10;                                    Container(&#10;                                      margin: const EdgeInsets.only(bottom: 8),&#10;                                      padding: const EdgeInsets.all(8),&#10;                                      decoration: BoxDecoration(&#10;                                        border: Border.all(color: Colors.black26, width: 1),&#10;                                        borderRadius: BorderRadius.circular(8),&#10;                                      ),&#10;                                      child: Wrap(&#10;                                        spacing: 8,&#10;                                        runSpacing: 8,&#10;                                        children: controller!.getValidActions().where((action) =&gt; action.startsWith(&quot;move_&quot;)).map((action) {&#10;                                          final label = _getActionLabel(action);&#10;                                          String usesInfo = &quot;&quot;;&#10;                                          final player = controller!.state.getActive(true);&#10;                                          final index = int.tryParse(action.split(&quot;_&quot;)[1]) ?? 0;&#10;                                          if (index &gt;= 0 &amp;&amp; index &lt; player.abilities.length) {&#10;                                            final ability = player.abilities[index];&#10;                                            usesInfo = &quot; (${ability.remainingUses}/${ability.maxUses})&quot;;&#10;                                          }&#10;                                          return ElevatedButton(&#10;                                            onPressed: () =&gt; onPlayerAction(action),&#10;                                            child: Text(label + usesInfo),&#10;                                          );&#10;                                        }).toList(),&#10;                                      ),&#10;                                    ),&#10;                                  ],&#10;                                ),&#10;                                ExpansionTile(&#10;                                  title: const Text(&quot;Switch&quot;, style: TextStyle(fontWeight: FontWeight.bold)),&#10;                                  children: [&#10;                                    Container(&#10;                                      padding: const EdgeInsets.all(8),&#10;                                      decoration: BoxDecoration(&#10;                                        border: Border.all(color: Colors.black26, width: 1),&#10;                                        borderRadius: BorderRadius.circular(8),&#10;                                      ),&#10;                                      child: GridView.count(&#10;                                        crossAxisCount: 2,&#10;                                        shrinkWrap: true,&#10;                                        physics: const NeverScrollableScrollPhysics(),&#10;                                        childAspectRatio: 2.8,&#10;                                        mainAxisSpacing: 8,&#10;                                        crossAxisSpacing: 8,&#10;                                        children: controller!.getValidActions().where((action) =&gt; action.startsWith(&quot;switch_&quot;)).map((action) {&#10;                                          final label = _getActionLabel(action);&#10;                                          final team = controller!.state.playerTeam;&#10;                                          final index = int.tryParse(action.split(&quot;_&quot;)[1]) ?? 0;&#10;                                          String hpInfo = &quot;&quot;;&#10;                                          if (index &gt;= 0 &amp;&amp; index &lt; team.length) {&#10;                                            final poke = team[index];&#10;                                            hpInfo = &quot;  HP: ${poke.currentHealth}/${poke.maxHealth}&quot;;&#10;                                          }&#10;                                          return ElevatedButton(&#10;                                            onPressed: () =&gt; onPlayerAction(action),&#10;                                            child: Text(label + hpInfo),&#10;                                          );&#10;                                        }).toList(),&#10;                                      ),&#10;                                    ),&#10;                                  ],&#10;                                ),&#10;                              ],&#10;                            ),&#10;&#10;&#10;                            const SizedBox(height: 16),&#10;                          ]&#10;                        )&#10;                      ),&#10;                    ],&#10;                  ),&#10;                ),&#10;              ),&#10;            ),&#10;    );&#10;  }&#10;  String _getActionLabel(String action) {&#10;    final player = controller!.state.getActive(true);&#10;    final team = controller!.state.playerTeam;&#10;&#10;    if (action.startsWith(&quot;move_&quot;)) {&#10;      final index = int.tryParse(action.split(&quot;_&quot;)[1]) ?? 0;&#10;      if (index &gt;= 0 &amp;&amp; index &lt; player.abilities.length) {&#10;        return player.abilities[index].name;&#10;      } else {&#10;        return &quot;Unknown Move&quot;;&#10;      }&#10;    } else if (action.startsWith(&quot;switch_&quot;)) {&#10;      final index = int.tryParse(action.split(&quot;_&quot;)[1]) ?? 0;&#10;      if (index &gt;= 0 &amp;&amp; index &lt; team.length) {&#10;        return team[index].nickname;&#10;      } else {&#10;        return &quot;Unknown Switch&quot;;&#10;      }&#10;    }&#10;&#10;    return action;&#10;  }&#10;&#10;&#10;  Widget _buildPokemonCard(Pokemon_mcts p, {required bool isOpponent}) {&#10;    return Card(&#10;      elevation: 2,&#10;      color: p.isFainted ? Colors.grey[200] : (isOpponent ? Colors.red[100] : Colors.blue[100]),&#10;      child: Padding(&#10;        padding: const EdgeInsets.all(12.0),&#10;        child: Column(&#10;          crossAxisAlignment: CrossAxisAlignment.start,&#10;          children: [&#10;            Text(&quot;${p.nickname} (${p.pokemonName})&quot;,&#10;                style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),&#10;            const SizedBox(height: 4),&#10;            Row(&#10;              children: [&#10;                Text(&quot;HP: ${p.currentHealth}/${p.maxHealth}&quot;),&#10;                const SizedBox(width: 16),&#10;                Text(&quot;Type: ${p.type}&quot;),&#10;              ],&#10;            ),&#10;            const SizedBox(height: 4),&#10;            AnimatedHPBar(current: p.currentHealth, max: p.maxHealth),&#10;          ],&#10;        ),&#10;      ),&#10;      );&#10;  }&#10;&#10;  Widget _buildAnimatedSprite(Pokemon_mcts p, {bool shake = false}) {&#10;    final spritePath = 'assets/sprites/${p.pokemonName.toLowerCase()}.png';&#10;&#10;    return TweenAnimationBuilder&lt;Offset&gt;(&#10;      key: ValueKey(p.nickname + p.currentHealth.toString()),&#10;      tween: Tween&lt;Offset&gt;(&#10;        begin: Offset.zero,&#10;        end: shake ? const Offset(0.05, 0) : Offset.zero,&#10;      ),&#10;      duration: const Duration(milliseconds: 150),&#10;      curve: Curves.elasticIn,&#10;      builder: (context, value, _) {&#10;        return Transform.translate(&#10;          offset: Offset(value.dx * 10, 0),&#10;          child: Stack(&#10;            children: [&#10;              Image.asset(&#10;                spritePath,&#10;                width: 96,&#10;                height: 96,&#10;                errorBuilder: (context, error, stack) =&gt; const Icon(Icons.error),&#10;              ),&#10;              if (shake)&#10;                Positioned.fill(&#10;                  child: ColoredBox(&#10;                    color: Colors.white.withOpacity(0.5),&#10;                  ),&#10;                ),&#10;            ],&#10;          ),&#10;        );&#10;      },&#10;    );&#10;  }&#10;&#10;&#10;  String getAbilityName(String action, bool isPlayer) {&#10;    if (!action.startsWith(&quot;move_&quot;)) return &quot;&quot;;&#10;    final index = int.parse(action.split(&quot;_&quot;)[1]);&#10;    final p = controller!.state.getActive(isPlayer);&#10;    return p.abilities[index].name;&#10;  }&#10;&#10;&#10;  Future&lt;void&gt; playTurnAnimationSequence(String playerAction) async {&#10;    setState(() {&#10;      playerJustAttacked = playerAction.startsWith(&quot;move_&quot;);&#10;      opponentJustAttacked = false;&#10;      narration = &quot;You used ${getAbilityName(playerAction, true)}!&quot;;&#10;      isAnimating = true;&#10;    });&#10;&#10;    // Pause to show player attack + shake&#10;    await Future.delayed(const Duration(milliseconds: 500));&#10;&#10;    setState(() {&#10;      controller!.applyPlayerAction(playerAction);&#10;      // After controller.applyPlayerAction(playerAction);&#10;      final effectiveness = controller!.lastEffectiveness;&#10;      final feedback = getEffectivenessText(effectiveness);&#10;&#10;      setState(() {&#10;        narration += &quot;\n$feedback&quot;;&#10;      });&#10;&#10;    });&#10;&#10;    if (!controller!.isBattleOver) {&#10;      final aiAction = runMCTS(controller!.state, 100);&#10;      final isSwitch = aiAction.startsWith(&quot;switch_&quot;);&#10;      final aiUsed = isSwitch&#10;          ? &quot;AI switched to ${controller!.state.getActive(false).nickname}!&quot;&#10;          : &quot;Enemy used ${getAbilityName(aiAction, false)}!&quot;;&#10;&#10;      await Future.delayed(const Duration(milliseconds: 300));&#10;&#10;      setState(() {&#10;        narration = aiUsed;&#10;        opponentJustAttacked = !isSwitch;&#10;      });&#10;&#10;      await Future.delayed(const Duration(milliseconds: 500));&#10;&#10;      setState(() {&#10;        controller!.state.applyAction(aiAction);&#10;        isAnimating = false;&#10;      });&#10;    } else {&#10;      setState(() {&#10;        isAnimating = false;&#10;      });&#10;    }&#10;  }&#10;&#10;  void playBattleMusic() {&#10;    MusicService().playMusic('music/battle_music.mp3');&#10;  }&#10;&#10;  void toggleMusic() {&#10;    setState(() {&#10;      isMusicPlaying = !isMusicPlaying;&#10;      if (isMusicPlaying) {&#10;        MusicService().playMusic('music/battle_music.mp3');&#10;      } else {&#10;        MusicService().stopMusic();&#10;      }&#10;    });&#10;  }&#10;&#10;  void onPlayerAction(String action) {&#10;    playTurnAnimationSequence(action);&#10;  }&#10;&#10;&#10;  @override&#10;  void dispose() {&#10;    // Stop battle music and resume menu music when leaving the page&#10;    MusicService().stopMusic(); // Stop battle music&#10;    MusicService().playMusic('music/menu_music.mp3'); // Resume menu music&#10;    super.dispose();&#10;  }&#10;}&#10;class AnimatedHPBar extends StatelessWidget {&#10;  final int current;&#10;  final int max;&#10;&#10;  const AnimatedHPBar({super.key, required this.current, required this.max});&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    final ratio = current / max;&#10;    final color = ratio &gt; 0.5&#10;        ? Colors.green&#10;        : ratio &gt; 0.2&#10;        ? Colors.orange&#10;        : Colors.red;&#10;&#10;    return TweenAnimationBuilder&lt;double&gt;(&#10;      tween: Tween&lt;double&gt;(begin: 0, end: ratio),&#10;      duration: const Duration(milliseconds: 500),&#10;      builder: (context, value, _) {&#10;        return SizedBox(&#10;          width: 170, // or MediaQuery.of(context).size.width * 0.4 for responsive&#10;          child: ClipRRect(&#10;            borderRadius: BorderRadius.circular(6),&#10;            child: LinearProgressIndicator(&#10;              value: value,&#10;              backgroundColor: Colors.grey[300],&#10;              color: color,&#10;              minHeight: 12,&#10;            ),&#10;          ),&#10;        );&#10;      },&#10;    );&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import 'package:flutter/material.dart';&#10;import '../mcts/pokebattle_controller.dart';&#10;import '../models/battle_game_state.dart';&#10;import '../models/pokemon_mcts.dart';&#10;import '../models/ability_mcts.dart';&#10;import '../mcts/mcts_search.dart'; // For direct MCTS call&#10;import 'package:animated_text_kit/animated_text_kit.dart';&#10;import '../services/music_service.dart';&#10;import '../services/xp_utils.dart';&#10;import '../services/ability_utils.dart';&#10;import 'package:supabase_flutter/supabase_flutter.dart';&#10;import 'package:shared_preferences/shared_preferences.dart';&#10;&#10;&#10;class PokeBattlePage extends StatefulWidget {&#10;  final String trainerId;&#10;  const PokeBattlePage({super.key, required this.trainerId});&#10;&#10;  @override&#10;  State&lt;PokeBattlePage&gt; createState() =&gt; _PokeBattlePageState();&#10;}&#10;&#10;class _PokeBattlePageState extends State&lt;PokeBattlePage&gt; {&#10;  late PokeBattleController? controller;&#10;  String? lastAiAction;&#10;  bool playerJustAttacked = false;&#10;  bool opponentJustAttacked = false;&#10;&#10;  String narration = &quot;&quot;;&#10;  bool isAnimating = false;&#10;&#10;  bool isMusicPlaying = true;&#10;&#10;  String selectedArena = &quot;&quot;;&#10;  String selectedArenaText = &quot;&quot;;&#10;  final List&lt;String&gt; arenaTypes = [&#10;    'desert', 'water', 'snow', 'hills', 'cave', 'beach', 'grass'&#10;  ];&#10;&#10;  final bool movesExpanded = true;&#10;&#10;  bool isLoading = true;&#10;&#10;  String? winnerTrainerName;&#10;&#10;  bool hasHandledBattleEnd = false;&#10;&#10;  String? playerTrainerName;&#10;  String? opponentTrainerName;&#10;  String? playerName;&#10;  String? opponentName;&#10;&#10;  @override&#10;  void initState() {&#10;    super.initState();&#10;    _loadMusicPreference();&#10;    controller = null;&#10;    _initTeams();&#10;  }&#10;&#10;  Future&lt;void&gt; _loadMusicPreference() async {&#10;    final prefs = await SharedPreferences.getInstance();&#10;    final musicOn = prefs.getBool('music_on') ?? true;&#10;    setState(() {&#10;      isMusicPlaying = musicOn;&#10;    });&#10;    await MusicService().setMute(!musicOn);&#10;    if (musicOn) {&#10;      await MusicService().playMusic('music/battle_music.mp3');&#10;    } else {&#10;      await MusicService().stopMusic();&#10;    }&#10;  }&#10;&#10;  Future&lt;void&gt; _initTeams() async {&#10;    setState(() { isLoading = true; });&#10;    final supabase = Supabase.instance.client;&#10;    // Fetch player trainer row&#10;    final trainerRes = await supabase&#10;      .from('trainer_table')&#10;      .select()&#10;      .eq('trainer_id', widget.trainerId)&#10;      .maybeSingle(); // safer than .single()&#10;    if (trainerRes == null) {&#10;      setState(() { narration = &quot;Trainer not found.&quot;; isLoading = false; });&#10;      return;&#10;    }&#10;    playerTrainerName = trainerRes['username'] ?? 'You';&#10;    playerName = playerTrainerName;&#10;    // Get player team&#10;    final playerTeam = await _fetchTeamFromTrainerRow(trainerRes);&#10;    if (playerTeam.isEmpty) {&#10;      setState(() {&#10;        narration = &quot;You have no Pokémon in your team. Please add Pokémon before battling.&quot;;&#10;        isLoading = false;&#10;      });&#10;      return;&#10;    }&#10;    // Get random opponent trainer&#10;    final trainers = await supabase&#10;      .from('trainer_table')&#10;      .select('trainer_id,username');&#10;    final opponentIds = trainers.where((t) =&gt; t['trainer_id'] != widget.trainerId).toList();&#10;    opponentIds.shuffle();&#10;    final opponentId = opponentIds.isNotEmpty ? opponentIds.first['trainer_id'] : widget.trainerId;&#10;    final opponentRes = await supabase&#10;      .from('trainer_table')&#10;      .select()&#10;      .eq('trainer_id', opponentId)&#10;      .maybeSingle(); // safer than .single()&#10;    opponentTrainerName = opponentRes?['username'] ?? 'Opponent';&#10;    opponentName = opponentTrainerName;&#10;    final opponentTeam = await _fetchTeamFromTrainerRow(opponentRes ?? {});&#10;    if (opponentTeam.isEmpty) {&#10;      setState(() {&#10;        narration = &quot;Opponent has no Pokémon. Try again later.&quot;;&#10;        isLoading = false;&#10;      });&#10;      return;&#10;    }&#10;    // Setup battle state&#10;    final state = BattleGameState(&#10;      playerTeam: playerTeam,&#10;      opponentTeam: opponentTeam,&#10;    );&#10;    setState(() {&#10;      controller = PokeBattleController(gameState: state);&#10;      // Randomly select an arena type&#10;      final rand = arenaTypes..shuffle();&#10;      selectedArena = rand.first;&#10;      selectedArenaText = selectedArena[0].toUpperCase() + selectedArena.substring(1);&#10;      isLoading = false;&#10;    });&#10;  }&#10;&#10;  Future&lt;List&lt;Pokemon_mcts&gt;&gt; _fetchTeamFromTrainerRow(Map trainerRow) async {&#10;    final supabase = Supabase.instance.client;&#10;    List&lt;Pokemon_mcts&gt; team = [];&#10;    for (int i = 1; i &lt;= 6; i++) {&#10;      final slotKey = 'pokemon_slot_$i';&#10;      final pokeId = trainerRow[slotKey];&#10;      if (pokeId == null) continue;&#10;      final pokeRes = await supabase&#10;        .from('pokemon_table')&#10;        .select()&#10;        .eq('pokemon_id', pokeId)&#10;        .maybeSingle(); // safer than .single()&#10;      if (pokeRes == null) continue;&#10;      // Fetch abilities&#10;      List&lt;Ability_mcts&gt; abilities = [];&#10;      for (int j = 1; j &lt;= 4; j++) {&#10;        final abKey = 'ability$j';&#10;        final abId = pokeRes[abKey];&#10;        if (abId == null) continue;&#10;        final abRes = await supabase&#10;          .from('abilities_table')&#10;          .select()&#10;          .eq('ability_id', abId)&#10;          .maybeSingle(); // safer than .single()&#10;        if (abRes == null) continue;&#10;        abilities.add(Ability_mcts(&#10;          name: abRes['ability_name'],&#10;          type: abRes['type'],&#10;          maxUses: abRes['uses'],&#10;          hitRate: abRes['hitrate'],&#10;          value: abRes['value'],&#10;        ));&#10;      }&#10;      team.add(Pokemon_mcts(&#10;        pokemonName: pokeRes['pokemon_name'],&#10;        nickname: pokeRes['nickname'],&#10;        type: pokeRes['type'],&#10;        level: pokeRes['level'],&#10;        attack: pokeRes['attack'],&#10;        maxHealth: pokeRes['health'],&#10;        abilities: abilities,&#10;      ));&#10;    }&#10;    return team;&#10;  }&#10;&#10;  String getEffectivenessText(double multiplier) {&#10;    if (multiplier &gt;= 2.0) return &quot;It's super effective!&quot;;&#10;    if (multiplier &gt;= 1.1) return &quot;It's effective!&quot;;&#10;    if (multiplier &lt;= 0.5) return &quot;It's not very effective...&quot;;&#10;    return &quot;&quot;;&#10;  }&#10;&#10;&#10;&#10;  Future&lt;void&gt; _handleBattleEnd() async {&#10;    if (hasHandledBattleEnd) return;&#10;    hasHandledBattleEnd = true;&#10;    final supabase = Supabase.instance.client;&#10;    final isWin = controller!.getWinner() == 1;&#10;    final isLoss = controller!.getWinner() == -1;&#10;    if (!isWin &amp;&amp; !isLoss) return;&#10;    final trainerRes = await supabase&#10;      .from('trainer_table')&#10;      .select()&#10;      .eq('trainer_id', widget.trainerId)&#10;      .maybeSingle();&#10;    if (trainerRes == null) return;&#10;    // Always set username before using it&#10;    playerTrainerName = trainerRes['username'] ?? 'You';&#10;    playerName = playerTrainerName;&#10;    winnerTrainerName = isWin ? (playerName ?? 'You') : (opponentName ?? 'Opponent');&#10;    int wins = trainerRes['wins'] ?? 0;&#10;    int losses = trainerRes['losses'] ?? 0;&#10;    int xp = trainerRes['experience_points'] ?? 0;&#10;    int level = trainerRes['level'] ?? 1;&#10;    int gainedXp = isWin ? 250 : 100;&#10;    // Use battle context scaler (1.1) and base (100)&#10;    final trainerXpResult = calculateXpAndLevel(&#10;      currentXp: xp,&#10;      currentLevel: level,&#10;      xpChange: gainedXp,&#10;      scaler: 1.1,&#10;      base: 100,&#10;    );&#10;    xp = trainerXpResult.newXp;&#10;    level = trainerXpResult.newLevel;&#10;    bool trainerLeveledUp = trainerXpResult.levelsGained &gt; 0;&#10;    if (isWin) wins += 1;&#10;    if (isLoss) losses += 1;&#10;    await supabase&#10;      .from('trainer_table')&#10;      .update({&#10;        'wins': wins,&#10;        'losses': losses,&#10;        'experience_points': xp,&#10;        'level': level,&#10;      })&#10;      .eq('trainer_id', widget.trainerId);&#10;    List&lt;String&gt; pokemonLevelUps = [];&#10;    List&lt;Future&lt;void&gt;&gt; abilityDialogs = [];&#10;    Set&lt;String&gt; slotPokeIds = {};&#10;    for (int i = 1; i &lt;= 6; i++) {&#10;      final slotKey = 'pokemon_slot_$i';&#10;      final pokeId = trainerRes[slotKey];&#10;      if (pokeId == null) continue;&#10;      slotPokeIds.add(pokeId.toString());&#10;      final pokeRes = await supabase&#10;        .from('pokemon_table')&#10;        .select()&#10;        .eq('pokemon_id', pokeId)&#10;        .maybeSingle();&#10;      if (pokeRes == null) continue;&#10;      int pokeXp = pokeRes['experience_points'] ?? 0;&#10;      int pokeLevel = pokeRes['level'] ?? 1;&#10;      final pokeXpResult = calculateXpAndLevel(&#10;        currentXp: pokeXp,&#10;        currentLevel: pokeLevel,&#10;        xpChange: gainedXp,&#10;        scaler: 1.1,&#10;        base: 100,&#10;      );&#10;      if (pokeXpResult.levelsGained &gt; 0) {&#10;        var tempPoke = Pokemon_mcts(&#10;          pokemonName: pokeRes['pokemon_name'],&#10;          nickname: pokeRes['nickname'],&#10;          type: pokeRes['type'],&#10;          level: pokeLevel,&#10;          attack: pokeRes['attack'],&#10;          maxHealth: pokeRes['health'],&#10;          abilities: [],&#10;        );&#10;        for (int lvl = 0; lvl &lt; pokeXpResult.levelsGained; lvl++) {&#10;          tempPoke = tempPoke.levelUp();&#10;        }&#10;        String pokeName = pokeRes['nickname'] ?? pokeRes['pokemon_name'] ?? 'Pokémon';&#10;        pokemonLevelUps.add('$pokeName (Lv${pokeLevel} → ${pokeXpResult.newLevel})');&#10;        await supabase&#10;          .from('pokemon_table')&#10;          .update({&#10;            'experience_points': pokeXpResult.newXp,&#10;            'level': pokeXpResult.newLevel,&#10;            'health': tempPoke.maxHealth,&#10;            'attack': tempPoke.attack,&#10;          })&#10;          .eq('pokemon_id', pokeId);&#10;      } else {&#10;        await supabase&#10;          .from('pokemon_table')&#10;          .update({&#10;            'experience_points': pokeXpResult.newXp,&#10;            'level': pokeXpResult.newLevel,&#10;          })&#10;          .eq('pokemon_id', pokeId);&#10;      }&#10;      // Always fetch the latest ability IDs after level up&#10;      if (pokeXpResult.levelsGained &gt; 0 &amp;&amp; pokeXpResult.newLevel % 5 == 0) {&#10;        final updatedPokeRes = await supabase&#10;          .from('pokemon_table')&#10;          .select()&#10;          .eq('pokemon_id', pokeId)&#10;          .maybeSingle();&#10;        List&lt;String&gt; currentAbilityIds = [];&#10;        if (updatedPokeRes != null) {&#10;          for (int j = 1; j &lt;= 4; j++) {&#10;            final abId = updatedPokeRes['ability$j'];&#10;            if (abId != null) {&#10;              currentAbilityIds.add(abId.toString());&#10;            }&#10;          }&#10;        }&#10;        final newAbility = await fetchRandomAbilityExcluding(currentAbilityIds);&#10;        if (newAbility != null &amp;&amp; mounted) {&#10;          // Show ability dialog and wait for user action before continuing&#10;          await offerAbilityDialog(&#10;            context: context,&#10;            ability: newAbility,&#10;            pokeId: pokeId,&#10;            currentAbilityIds: currentAbilityIds,&#10;          );&#10;        }&#10;      }&#10;    }&#10;    // --- Favorite Pokémon XP logic ---&#10;    final favoritePokeId = trainerRes['favorite_pokemon'];&#10;    if (favoritePokeId != null) {&#10;      int totalXpChange = slotPokeIds.contains(favoritePokeId.toString()) ? gainedXp * 2 : gainedXp;&#10;      final pokeRes = await supabase&#10;        .from('pokemon_table')&#10;        .select()&#10;        .eq('pokemon_id', favoritePokeId)&#10;        .maybeSingle();&#10;      if (pokeRes != null) {&#10;        int pokeXp = pokeRes['experience_points'] ?? 0;&#10;        int pokeLevel = pokeRes['level'] ?? 1;&#10;        final pokeXpResult = calculateXpAndLevel(&#10;          currentXp: pokeXp,&#10;          currentLevel: pokeLevel,&#10;          xpChange: totalXpChange,&#10;          scaler: 1.1,&#10;          base: 100,&#10;        );&#10;        await supabase&#10;          .from('pokemon_table')&#10;          .update({&#10;            'experience_points': pokeXpResult.newXp,&#10;            'level': pokeXpResult.newLevel,&#10;          })&#10;          .eq('pokemon_id', favoritePokeId);&#10;        // --- Offer ability if favorite leveled up to a multiple of 5 ---&#10;        if (pokeXpResult.levelsGained &gt; 0 &amp;&amp; pokeXpResult.newLevel % 5 == 0) {&#10;          List&lt;String&gt; currentAbilityIds = [];&#10;          for (int j = 1; j &lt;= 4; j++) {&#10;            final abId = pokeRes['ability$j'];&#10;            if (abId != null) currentAbilityIds.add(abId.toString());&#10;          }&#10;          final newAbility = await fetchRandomAbilityExcluding(currentAbilityIds);&#10;          if (newAbility != null &amp;&amp; mounted) {&#10;            await Future.delayed(const Duration(seconds: 2));&#10;            await offerAbilityDialog(&#10;              context: context,&#10;              ability: newAbility,&#10;              pokeId: favoritePokeId.toString(),&#10;              currentAbilityIds: currentAbilityIds,&#10;            );&#10;          }&#10;        }&#10;      }&#10;    }&#10;    String msg = '';&#10;    if (trainerLeveledUp) {&#10;      msg += 'Trainer ${playerName ?? 'You'} leveled up!\n';&#10;      // Add a random Pokémon to the trainer's team and show dialog&#10;      final newPokeId = await addRandomPokemonToTrainer(widget.trainerId);&#10;      if (newPokeId != null) {&#10;        final pokeRes = await supabase&#10;          .from('pokemon_table')&#10;          .select()&#10;          .eq('pokemon_id', newPokeId)&#10;          .maybeSingle();&#10;        if (pokeRes != null &amp;&amp; mounted) {&#10;          await showNewPokemonDialog(context, pokeRes['pokemon_name'], pokeRes['type']);&#10;        }&#10;      }&#10;    }&#10;    if (pokemonLevelUps.isNotEmpty) {&#10;      msg += 'Pokémon leveled up: ${pokemonLevelUps.join(&quot;, &quot;)}!';&#10;    }&#10;    if (!mounted) return;&#10;    setState(() {&#10;      narration = &quot;${winnerTrainerName ?? 'Trainer'} wins!\n&quot; + msg;&#10;    });&#10;    if (pokemonLevelUps.isNotEmpty &amp;&amp; mounted) {&#10;      await showDialog(&#10;        context: context,&#10;        builder: (context) =&gt; AlertDialog(&#10;          title: const Text('Pokémon Leveled Up!'),&#10;          content: Text(pokemonLevelUps.join('\n')),&#10;          actions: [&#10;            TextButton(&#10;              onPressed: () =&gt; Navigator.of(context).pop(),&#10;              child: const Text('OK'),&#10;            ),&#10;          ],&#10;        ),&#10;      );&#10;    }&#10;    await Future.delayed(const Duration(seconds: 2));&#10;    if (!mounted) return;&#10;    if (Navigator.canPop(context)) {&#10;      Navigator.of(context).pop('refresh');&#10;    }&#10;  }&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    if (isLoading || controller == null) {&#10;      return Scaffold(&#10;        appBar: AppBar(title: const Text(&quot;Pokémon Battle&quot;)),&#10;        body: Center(child: narration.isNotEmpty ? Text(narration, style: TextStyle(fontSize: 18, color: Colors.red)) : const CircularProgressIndicator()),&#10;      );&#10;    }&#10;    final activePlayer = controller!.state.getActive(true);&#10;    final activeOpponent = controller!.state.getActive(false);&#10;    if (controller!.isBattleOver) {&#10;      _handleBattleEnd();&#10;    }&#10;    return Scaffold(&#10;      appBar: AppBar(title: const Text(&quot;Pokémon Battle&quot;)),&#10;      backgroundColor: Colors.redAccent,&#10;      body: Container(&#10;        decoration: const BoxDecoration(&#10;          color: Colors.redAccent,&#10;        ),&#10;        child: controller!.isBattleOver&#10;            ? Center(&#10;                child: Text(&#10;                  // Show winnerTrainerName instead of &quot;You win!&quot;&#10;                  controller!.getWinner() == 1&#10;                      ? &quot;${winnerTrainerName ?? 'Trainer'} wins!&quot;&#10;                      : controller!.getWinner() == -1&#10;                          ? &quot;You lose!&quot;&#10;                          : &quot;Draw&quot;,&#10;                  style: const TextStyle(fontSize: 24),&#10;                ),&#10;              )&#10;            : Padding(&#10;                padding: const EdgeInsets.all(12.0),&#10;                child: SingleChildScrollView(&#10;                  child: Column(&#10;                    children: [&#10;                      Container(&#10;                        decoration: BoxDecoration(&#10;                          image: DecorationImage(&#10;                            image: AssetImage('assets/background/' + selectedArena + '-battle-background.jpg'),&#10;                            fit: BoxFit.cover,&#10;                          ),&#10;                          borderRadius: BorderRadius.circular(12),&#10;                        ),&#10;                        child: Column(&#10;                          children: [&#10;                            Container(&#10;                              child: Column(&#10;                                  children: [&#10;                                  Stack(&#10;                                    children:[&#10;                                      _buildPokemonCard(activeOpponent, isOpponent: true),&#10;                                      Row(&#10;                                        mainAxisAlignment: MainAxisAlignment.end,&#10;                                        children: [&#10;                                          IconButton(&#10;                                            icon: Icon(isMusicPlaying ? Icons.music_note : Icons.music_off),&#10;                                            tooltip: isMusicPlaying ? 'Pause Music' : 'Play Music',&#10;                                            onPressed: toggleMusic,&#10;                                          ),&#10;                                        ],&#10;                                      ),&#10;                                    ]&#10;                                  ),&#10;                                  // OPPONENT STATS&#10;&#10;                                  const SizedBox(height: 16),&#10;&#10;                                  // BATTLE ARENA&#10;                                  Stack(&#10;                                    children: [&#10;                                      SizedBox(&#10;                                        height: 140, // Set a fixed height for the battle arena&#10;                                        child: Center(&#10;                                          child: Column(&#10;                                            children: [&#10;                                              if (lastAiAction != null &amp;&amp; lastAiAction!.startsWith(&quot;switch_&quot;))&#10;                                                Text(&#10;                                                  &quot;AI switched to &quot;+activeOpponent.nickname+&quot;!&quot;,&#10;                                                  style: const TextStyle(&#10;                                                    color: Colors.deepOrange,&#10;                                                    fontWeight: FontWeight.bold,&#10;                                                  ),&#10;                                                ),&#10;                                              const SizedBox(height: 8),&#10;                                              Row( //  FIGHTING SCREEN&#10;                                                mainAxisAlignment: MainAxisAlignment.spaceAround,&#10;                                                children: [&#10;                                                  Flexible(&#10;                                                    fit: FlexFit.loose,&#10;                                                    child: FittedBox(&#10;                                                      fit: BoxFit.scaleDown,&#10;                                                      child: _buildAnimatedSprite(activePlayer, shake: opponentJustAttacked),&#10;                                                    ),&#10;                                                  ),&#10;                                                  Flexible(&#10;                                                    fit: FlexFit.loose,&#10;                                                    child: FittedBox(&#10;                                                      fit: BoxFit.scaleDown,&#10;                                                      child: _buildAnimatedSprite(activeOpponent, shake: playerJustAttacked),&#10;                                                    ),&#10;                                                  ),&#10;                                                ],&#10;                                              ),&#10;                                            ],&#10;                                          ),&#10;                                        ),&#10;                                      ),&#10;                                      if (isAnimating)&#10;                                        Padding(&#10;                                          padding: const EdgeInsets.symmetric(vertical: 8.0),&#10;                                          child: Container(&#10;                                            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),&#10;                                            decoration: BoxDecoration(&#10;                                              color: Colors.black.withOpacity(0.6),&#10;                                              borderRadius: BorderRadius.circular(10),&#10;                                            ),&#10;                                            child: Row(&#10;                                              mainAxisSize: MainAxisSize.min,&#10;                                              mainAxisAlignment: MainAxisAlignment.center,&#10;                                              children: const [&#10;                                                SizedBox(&#10;                                                  width: 20,&#10;                                                  height: 20,&#10;                                                  child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white),&#10;                                                ),&#10;                                                SizedBox(width: 12),&#10;                                                Text(&#10;                                                  &quot;AI is thinking...&quot;,&#10;                                                  style: TextStyle(color: Colors.white),&#10;                                                ),&#10;                                              ],&#10;                                            ),&#10;                                          ),&#10;                                        ),&#10;                                    ]&#10;                                  ),&#10;                                  // PLAYER STATS&#10;                                  _buildPokemonCard(activePlayer, isOpponent: false),&#10;&#10;                                ]&#10;                              )&#10;                            ), // battle space&#10;                          ],&#10;                        ),&#10;                      ),&#10;                      Container(&#10;                        color: Colors.redAccent,&#10;                        child: Column(&#10;                          children: [&#10;                            //MOVES AND OTHER STUFF&#10;                            const SizedBox(height: 8),&#10;&#10;                            const SizedBox(height: 8),&#10;                            Padding(&#10;                              padding: const EdgeInsets.symmetric(horizontal: 12.0),&#10;                              // NARRATION&#10;                              child: Container(&#10;                                width: double.infinity,&#10;                                padding: const EdgeInsets.all(12),&#10;                                decoration: BoxDecoration(&#10;                                  color: Colors.cyanAccent,&#10;                                  borderRadius: BorderRadius.circular(8),&#10;                                  border: Border.all(color: Colors.black54, width: 2),&#10;                                ),&#10;                                child: AnimatedTextKit(&#10;                                  key: ValueKey(narration), // ensures animation restarts on narration change&#10;                                  animatedTexts: [&#10;                                    TyperAnimatedText(&#10;                                      narration,&#10;                                      textStyle: const TextStyle(color: Colors.black54, fontSize: 16),&#10;                                      speed: const Duration(milliseconds: 35),&#10;                                    ),&#10;                                  ],&#10;                                  totalRepeatCount: 1,&#10;                                  pause: Duration.zero,&#10;                                  displayFullTextOnTap: true,&#10;                                  stopPauseOnTap: true,&#10;                                ),&#10;                              ),&#10;                            ),&#10;                            const SizedBox(height: 18),&#10;                            // ACTIONS&#10;                            Column(&#10;                              crossAxisAlignment: CrossAxisAlignment.stretch,&#10;                              children: [&#10;                                ExpansionTile(&#10;                                  title: const Text(&quot;Moves&quot;, style: TextStyle(fontWeight: FontWeight.bold)),&#10;                                  initiallyExpanded: movesExpanded,&#10;                                  children: [&#10;                                    Container(&#10;                                      margin: const EdgeInsets.only(bottom: 8),&#10;                                      padding: const EdgeInsets.all(8),&#10;                                      decoration: BoxDecoration(&#10;                                        border: Border.all(color: Colors.black26, width: 1),&#10;                                        borderRadius: BorderRadius.circular(8),&#10;                                      ),&#10;                                      child: Wrap(&#10;                                        spacing: 8,&#10;                                        runSpacing: 8,&#10;                                        children: controller!.getValidActions().where((action) =&gt; action.startsWith(&quot;move_&quot;)).map((action) {&#10;                                          final label = _getActionLabel(action);&#10;                                          String usesInfo = &quot;&quot;;&#10;                                          final player = controller!.state.getActive(true);&#10;                                          final index = int.tryParse(action.split(&quot;_&quot;)[1]) ?? 0;&#10;                                          if (index &gt;= 0 &amp;&amp; index &lt; player.abilities.length) {&#10;                                            final ability = player.abilities[index];&#10;                                            usesInfo = &quot; (${ability.remainingUses}/${ability.maxUses})&quot;;&#10;                                          }&#10;                                          return ElevatedButton(&#10;                                            onPressed: () =&gt; onPlayerAction(action),&#10;                                            child: Text(label + usesInfo),&#10;                                          );&#10;                                        }).toList(),&#10;                                      ),&#10;                                    ),&#10;                                  ],&#10;                                ),&#10;                                ExpansionTile(&#10;                                  title: const Text(&quot;Switch&quot;, style: TextStyle(fontWeight: FontWeight.bold)),&#10;                                  children: [&#10;                                    Container(&#10;                                      padding: const EdgeInsets.all(8),&#10;                                      decoration: BoxDecoration(&#10;                                        border: Border.all(color: Colors.black26, width: 1),&#10;                                        borderRadius: BorderRadius.circular(8),&#10;                                      ),&#10;                                      child: GridView.count(&#10;                                        crossAxisCount: 2,&#10;                                        shrinkWrap: true,&#10;                                        physics: const NeverScrollableScrollPhysics(),&#10;                                        childAspectRatio: 2.8,&#10;                                        mainAxisSpacing: 8,&#10;                                        crossAxisSpacing: 8,&#10;                                        children: controller!.getValidActions().where((action) =&gt; action.startsWith(&quot;switch_&quot;)).map((action) {&#10;                                          final label = _getActionLabel(action);&#10;                                          final team = controller!.state.playerTeam;&#10;                                          final index = int.tryParse(action.split(&quot;_&quot;)[1]) ?? 0;&#10;                                          String hpInfo = &quot;&quot;;&#10;                                          if (index &gt;= 0 &amp;&amp; index &lt; team.length) {&#10;                                            final poke = team[index];&#10;                                            hpInfo = &quot;  HP: ${poke.currentHealth}/${poke.maxHealth}&quot;;&#10;                                          }&#10;                                          return ElevatedButton(&#10;                                            onPressed: () =&gt; onPlayerAction(action),&#10;                                            child: Text(label + hpInfo),&#10;                                          );&#10;                                        }).toList(),&#10;                                      ),&#10;                                    ),&#10;                                  ],&#10;                                ),&#10;                              ],&#10;                            ),&#10;&#10;&#10;                            const SizedBox(height: 16),&#10;                          ]&#10;                        )&#10;                      ),&#10;                    ],&#10;                  ),&#10;                ),&#10;              ),&#10;            ),&#10;    );&#10;  }&#10;  String _getActionLabel(String action) {&#10;    final player = controller!.state.getActive(true);&#10;    final team = controller!.state.playerTeam;&#10;&#10;    if (action.startsWith(&quot;move_&quot;)) {&#10;      final index = int.tryParse(action.split(&quot;_&quot;)[1]) ?? 0;&#10;      if (index &gt;= 0 &amp;&amp; index &lt; player.abilities.length) {&#10;        return player.abilities[index].name;&#10;      } else {&#10;        return &quot;Unknown Move&quot;;&#10;      }&#10;    } else if (action.startsWith(&quot;switch_&quot;)) {&#10;      final index = int.tryParse(action.split(&quot;_&quot;)[1]) ?? 0;&#10;      if (index &gt;= 0 &amp;&amp; index &lt; team.length) {&#10;        return team[index].nickname;&#10;      } else {&#10;        return &quot;Unknown Switch&quot;;&#10;      }&#10;    }&#10;&#10;    return action;&#10;  }&#10;&#10;&#10;  Widget _buildPokemonCard(Pokemon_mcts p, {required bool isOpponent}) {&#10;    return Card(&#10;      elevation: 2,&#10;      color: p.isFainted ? Colors.grey[200] : (isOpponent ? Colors.red[100] : Colors.blue[100]),&#10;      child: Padding(&#10;        padding: const EdgeInsets.all(12.0),&#10;        child: Column(&#10;          crossAxisAlignment: CrossAxisAlignment.start,&#10;          children: [&#10;            Text(&quot;${p.nickname} (${p.pokemonName})&quot;,&#10;                style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),&#10;            const SizedBox(height: 4),&#10;            Row(&#10;              children: [&#10;                Text(&quot;HP: ${p.currentHealth}/${p.maxHealth}&quot;),&#10;                const SizedBox(width: 16),&#10;                Text(&quot;Type: ${p.type}&quot;),&#10;              ],&#10;            ),&#10;            const SizedBox(height: 4),&#10;            AnimatedHPBar(current: p.currentHealth, max: p.maxHealth),&#10;          ],&#10;        ),&#10;      ),&#10;      );&#10;  }&#10;&#10;  Widget _buildAnimatedSprite(Pokemon_mcts p, {bool shake = false}) {&#10;    final spritePath = 'assets/sprites/${p.pokemonName.toLowerCase()}.png';&#10;&#10;    return TweenAnimationBuilder&lt;Offset&gt;(&#10;      key: ValueKey(p.nickname + p.currentHealth.toString()),&#10;      tween: Tween&lt;Offset&gt;(&#10;        begin: Offset.zero,&#10;        end: shake ? const Offset(0.05, 0) : Offset.zero,&#10;      ),&#10;      duration: const Duration(milliseconds: 150),&#10;      curve: Curves.elasticIn,&#10;      builder: (context, value, _) {&#10;        return Transform.translate(&#10;          offset: Offset(value.dx * 10, 0),&#10;          child: Stack(&#10;            children: [&#10;              Image.asset(&#10;                spritePath,&#10;                width: 96,&#10;                height: 96,&#10;                errorBuilder: (context, error, stack) =&gt; const Icon(Icons.error),&#10;              ),&#10;              if (shake)&#10;                Positioned.fill(&#10;                  child: ColoredBox(&#10;                    color: Colors.white.withOpacity(0.5),&#10;                  ),&#10;                ),&#10;            ],&#10;          ),&#10;        );&#10;      },&#10;    );&#10;  }&#10;&#10;&#10;  String getAbilityName(String action, bool isPlayer) {&#10;    if (!action.startsWith(&quot;move_&quot;)) return &quot;&quot;;&#10;    final index = int.parse(action.split(&quot;_&quot;)[1]);&#10;    final p = controller!.state.getActive(isPlayer);&#10;    return p.abilities[index].name;&#10;  }&#10;&#10;&#10;  Future&lt;void&gt; playTurnAnimationSequence(String playerAction) async {&#10;    setState(() {&#10;      playerJustAttacked = playerAction.startsWith(&quot;move_&quot;);&#10;      opponentJustAttacked = false;&#10;      narration = &quot;You used ${getAbilityName(playerAction, true)}!&quot;;&#10;      isAnimating = true;&#10;    });&#10;&#10;    // Pause to show player attack + shake&#10;    await Future.delayed(const Duration(milliseconds: 500));&#10;&#10;    setState(() {&#10;      controller!.applyPlayerAction(playerAction);&#10;      // After controller.applyPlayerAction(playerAction);&#10;      final effectiveness = controller!.lastEffectiveness;&#10;      final feedback = getEffectivenessText(effectiveness);&#10;&#10;      setState(() {&#10;        narration += &quot;\n$feedback&quot;;&#10;      });&#10;&#10;    });&#10;&#10;    if (!controller!.isBattleOver) {&#10;      final aiAction = runMCTS(controller!.state, 100);&#10;      final isSwitch = aiAction.startsWith(&quot;switch_&quot;);&#10;      final aiUsed = isSwitch&#10;          ? &quot;AI switched to ${controller!.state.getActive(false).nickname}!&quot;&#10;          : &quot;Enemy used ${getAbilityName(aiAction, false)}!&quot;;&#10;&#10;      await Future.delayed(const Duration(milliseconds: 300));&#10;&#10;      setState(() {&#10;        narration = aiUsed;&#10;        opponentJustAttacked = !isSwitch;&#10;      });&#10;&#10;      await Future.delayed(const Duration(milliseconds: 500));&#10;&#10;      setState(() {&#10;        controller!.state.applyAction(aiAction);&#10;        isAnimating = false;&#10;      });&#10;    } else {&#10;      setState(() {&#10;        isAnimating = false;&#10;      });&#10;    }&#10;  }&#10;&#10;  void toggleMusic() async {&#10;    final prefs = await SharedPreferences.getInstance();&#10;    if (isMusicPlaying) {&#10;      await MusicService().stopMusic();&#10;      await MusicService().setMute(true);&#10;      await prefs.setBool('music_on', false);&#10;    } else {&#10;      await MusicService().setMute(false);&#10;      await MusicService().playMusic('music/battle_music.mp3');&#10;      await prefs.setBool('music_on', true);&#10;    }&#10;    setState(() {&#10;      isMusicPlaying = !isMusicPlaying;&#10;    });&#10;  }&#10;&#10;&#10;  void onPlayerAction(String action) {&#10;    playTurnAnimationSequence(action);&#10;  }&#10;&#10;&#10;  @override&#10;  void dispose() {&#10;    // Stop battle music and resume menu music when leaving the page&#10;    MusicService().stopMusic(); // Stop battle music&#10;    _resumeMenuMusic();&#10;    super.dispose();&#10;  }&#10;&#10;  Future&lt;void&gt; _resumeMenuMusic() async {&#10;    final prefs = await SharedPreferences.getInstance();&#10;    final musicOn = prefs.getBool('music_on') ?? true;&#10;    await MusicService().setMute(!musicOn);&#10;    if (musicOn) {&#10;      await MusicService().playMusic('music/menu_music.mp3');&#10;    } else {&#10;      await MusicService().stopMusic();&#10;    }&#10;  }&#10;}&#10;class AnimatedHPBar extends StatelessWidget {&#10;  final int current;&#10;  final int max;&#10;&#10;  const AnimatedHPBar({super.key, required this.current, required this.max});&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    final ratio = current / max;&#10;    final color = ratio &gt; 0.5&#10;        ? Colors.green&#10;        : ratio &gt; 0.2&#10;        ? Colors.orange&#10;        : Colors.red;&#10;&#10;    return TweenAnimationBuilder&lt;double&gt;(&#10;      tween: Tween&lt;double&gt;(begin: 0, end: ratio),&#10;      duration: const Duration(milliseconds: 500),&#10;      builder: (context, value, _) {&#10;        return SizedBox(&#10;          width: 170, // or MediaQuery.of(context).size.width * 0.4 for responsive&#10;          child: ClipRRect(&#10;            borderRadius: BorderRadius.circular(6),&#10;            child: LinearProgressIndicator(&#10;              value: value,&#10;              backgroundColor: Colors.grey[300],&#10;              color: color,&#10;              minHeight: 12,&#10;            ),&#10;          ),&#10;        );&#10;      },&#10;    );&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lib/services/music_service.dart">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lib/services/music_service.dart" />
              <option name="originalContent" value="import 'package:audioplayers/audioplayers.dart';&#10;&#10;class MusicService {&#10;  static final MusicService _instance = MusicService._internal();&#10;  factory MusicService() =&gt; _instance;&#10;  MusicService._internal();&#10;&#10;  final AudioPlayer _player = AudioPlayer();&#10;  bool _isPlaying = false;&#10;  String? _currentAsset;&#10;  bool _isMuted = false;&#10;&#10;  bool get isMuted =&gt; _isMuted;&#10;&#10;  Future&lt;void&gt; playMusic(String assetPath) async {&#10;    await _player.stop();&#10;    await _player.setReleaseMode(ReleaseMode.loop);&#10;    await _player.play(AssetSource(assetPath));&#10;    _isPlaying = true;&#10;    _currentAsset = assetPath;&#10;  }&#10;&#10;  Future&lt;void&gt; stopMusic() async {&#10;    await _player.stop();&#10;    _isPlaying = false;&#10;    _currentAsset = null;&#10;  }&#10;&#10;  Future&lt;void&gt; pauseMusic() async {&#10;    await _player.pause();&#10;    _isPlaying = false;&#10;  }&#10;&#10;  Future&lt;void&gt; resumeMusic() async {&#10;    await _player.resume();&#10;    _isPlaying = true;&#10;  }&#10;&#10;  Future&lt;void&gt; setMute(bool mute) async {&#10;    _isMuted = mute;&#10;    await _player.setVolume(mute ? 0.0 : 1.0);&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import 'package:audioplayers/audioplayers.dart';&#13;&#10;&#13;&#10;class MusicService {&#13;&#10;  static final MusicService _instance = MusicService._internal();&#13;&#10;  factory MusicService() =&gt; _instance;&#13;&#10;  MusicService._internal();&#13;&#10;&#13;&#10;  final AudioPlayer _player = AudioPlayer();&#13;&#10;  bool _isPlaying = false;&#13;&#10;  String? _currentAsset;&#13;&#10;  bool _isMuted = false;&#13;&#10;&#13;&#10;  bool get isMuted =&gt; _isMuted;&#13;&#10;&#13;&#10;  Future&lt;void&gt; playMusic(String assetPath) async {&#13;&#10;    if (_isMuted) return; // Don't play if muted&#13;&#10;    if (_isPlaying &amp;&amp; _currentAsset == assetPath) return;&#13;&#10;    await _player.stop();&#13;&#10;    await _player.setReleaseMode(ReleaseMode.loop);&#13;&#10;    await _player.play(AssetSource(assetPath));&#13;&#10;    _isPlaying = true;&#13;&#10;    _currentAsset = assetPath;&#13;&#10;  }&#13;&#10;&#13;&#10;  Future&lt;void&gt; stopMusic() async {&#13;&#10;    await _player.stop();&#13;&#10;    _isPlaying = false;&#13;&#10;    _currentAsset = null;&#13;&#10;  }&#13;&#10;&#13;&#10;  Future&lt;void&gt; pauseMusic() async {&#13;&#10;    await _player.pause();&#13;&#10;    _isPlaying = false;&#13;&#10;  }&#13;&#10;&#13;&#10;  Future&lt;void&gt; resumeMusic() async {&#13;&#10;    await _player.resume();&#13;&#10;    _isPlaying = true;&#13;&#10;  }&#13;&#10;&#13;&#10;  Future&lt;void&gt; setMute(bool mute) async {&#13;&#10;    _isMuted = mute;&#13;&#10;    await _player.setVolume(mute ? 0.0 : 1.0);&#13;&#10;  }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>