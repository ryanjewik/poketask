<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/android/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/android/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot;/&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.SCHEDULE_EXACT_ALARM&quot;/&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;/&gt;&#10;&#10;    &lt;application&#10;        android:label=&quot;poketask&quot;&#10;        android:name=&quot;${applicationName}&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:launchMode=&quot;singleTop&quot;&#10;            android:taskAffinity=&quot;&quot;&#10;            android:theme=&quot;@style/LaunchTheme&quot;&#10;            android:configChanges=&quot;orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode&quot;&#10;            android:hardwareAccelerated=&quot;true&quot;&#10;            android:windowSoftInputMode=&quot;adjustResize&quot;&gt;&#10;            &lt;!-- Specifies an Android theme to apply to this Activity as soon as&#10;                 the Android process has started. This theme is visible to the user&#10;                 while the Flutter UI initializes. After that, this theme continues&#10;                 to determine the Window background behind the Flutter UI. --&gt;&#10;            &lt;meta-data&#10;              android:name=&quot;io.flutter.embedding.android.NormalTheme&quot;&#10;              android:resource=&quot;@style/NormalTheme&quot;&#10;              /&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;        &lt;!-- Don't delete the meta-data below.&#10;             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java --&gt;&#10;        &lt;meta-data&#10;            android:name=&quot;flutterEmbedding&quot;&#10;            android:value=&quot;2&quot; /&gt;&#10;        &lt;receiver android:name=&quot;com.dexterous.flutterlocalnotifications.ScheduledNotificationBootReceiver&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot;/&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MY_PACKAGE_REPLACED&quot;/&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/receiver&gt;&#10;        &lt;receiver android:name=&quot;com.dexterous.flutterlocalnotifications.ScheduledNotificationReceiver&quot; /&gt;&#10;    &lt;/application&gt;&#10;    &lt;!-- Required to query activities that can process text, see:&#10;         https://developer.android.com/training/package-visibility and&#10;         https://developer.android.com/reference/android/content/Intent#ACTION_PROCESS_TEXT.&#10;&#10;         In particular, this is used by the Flutter engine in io.flutter.plugin.text.ProcessTextPlugin. --&gt;&#10;    &lt;queries&gt;&#10;        &lt;intent&gt;&#10;            &lt;action android:name=&quot;android.intent.action.PROCESS_TEXT&quot;/&gt;&#10;            &lt;data android:mimeType=&quot;text/plain&quot;/&gt;&#10;        &lt;/intent&gt;&#10;    &lt;/queries&gt;&#10;&lt;/manifest&gt;&#10;" />
              <option name="updatedContent" value="&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot;/&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.SCHEDULE_EXACT_ALARM&quot;/&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;/&gt;&#10;&#10;    &lt;application&#10;        android:label=&quot;poketask&quot;&#10;        android:name=&quot;${applicationName}&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:launchMode=&quot;singleTop&quot;&#10;            android:taskAffinity=&quot;&quot;&#10;            android:theme=&quot;@style/LaunchTheme&quot;&#10;            android:configChanges=&quot;orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode&quot;&#10;            android:hardwareAccelerated=&quot;true&quot;&#10;            android:windowSoftInputMode=&quot;adjustResize&quot;&gt;&#10;            &lt;!-- Specifies an Android theme to apply to this Activity as soon as&#10;                 the Android process has started. This theme is visible to the user&#10;                 while the Flutter UI initializes. After that, this theme continues&#10;                 to determine the Window background behind the Flutter UI. --&gt;&#10;            &lt;meta-data&#10;              android:name=&quot;io.flutter.embedding.android.NormalTheme&quot;&#10;              android:resource=&quot;@style/NormalTheme&quot;&#10;              /&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;        &lt;!-- Don't delete the meta-data below.&#10;             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java --&gt;&#10;        &lt;meta-data&#10;            android:name=&quot;flutterEmbedding&quot;&#10;            android:value=&quot;2&quot; /&gt;&#10;        &lt;receiver android:name=&quot;com.dexterous.flutterlocalnotifications.ScheduledNotificationBootReceiver&quot;&#10;                  android:exported=&quot;false&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot;/&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MY_PACKAGE_REPLACED&quot;/&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/receiver&gt;&#10;        &lt;receiver android:name=&quot;com.dexterous.flutterlocalnotifications.ScheduledNotificationReceiver&quot; /&gt;&#10;    &lt;/application&gt;&#10;    &lt;!-- Required to query activities that can process text, see:&#10;         https://developer.android.com/training/package-visibility and&#10;         https://developer.android.com/reference/android/content/Intent#ACTION_PROCESS_TEXT.&#10;&#10;         In particular, this is used by the Flutter engine in io.flutter.plugin.text.ProcessTextPlugin. --&gt;&#10;    &lt;queries&gt;&#10;        &lt;intent&gt;&#10;            &lt;action android:name=&quot;android.intent.action.PROCESS_TEXT&quot;/&gt;&#10;            &lt;data android:mimeType=&quot;text/plain&quot;/&gt;&#10;        &lt;/intent&gt;&#10;    &lt;/queries&gt;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lib/services/notification_service.dart">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lib/services/notification_service.dart" />
              <option name="originalContent" value="import 'dart:io';&#10;&#10;import 'package:android_intent_plus/android_intent.dart';&#10;import 'package:android_intent_plus/flag.dart';&#10;import 'package:flutter/foundation.dart';&#10;import 'package:flutter/services.dart';&#10;import 'package:flutter_local_notifications/flutter_local_notifications.dart';&#10;import 'package:timezone/timezone.dart' as tz;&#10;import 'package:timezone/data/latest.dart' as tz;&#10;import 'package:permission_handler/permission_handler.dart';&#10;&#10;class NotificationService {&#10;  // ✅ Define the plugin instance&#10;  static final FlutterLocalNotificationsPlugin _plugin =&#10;      FlutterLocalNotificationsPlugin();&#10;&#10;  // ✅ Initialization method&#10;  static Future&lt;void&gt; initialize() async {&#10;    tz.initializeTimeZones();&#10;    final String localTimeZone = await FlutterNativeTimezone.getLocalTimezone();&#10;    tz.setLocalLocation(tz.getLocation(localTimeZone));&#10;    debugPrint('[NotificationService] Using local timezone: $localTimeZone');&#10;&#10;    const androidSettings = AndroidInitializationSettings('@mipmap/ic_launcher');&#10;    const iosSettings = DarwinInitializationSettings();&#10;&#10;    const initSettings = InitializationSettings(&#10;      android: androidSettings,&#10;      iOS: iosSettings,&#10;    );&#10;&#10;    await _plugin.initialize(initSettings);&#10;&#10;    // Android notification channel setup&#10;    const AndroidNotificationChannel channel = AndroidNotificationChannel(&#10;      'reminders_channel',&#10;      'Reminders',&#10;      description: 'Notification channel for task reminders',&#10;      importance: Importance.max,&#10;    );&#10;    await _plugin&#10;        .resolvePlatformSpecificImplementation&lt;AndroidFlutterLocalNotificationsPlugin&gt;()&#10;        ?.createNotificationChannel(channel);&#10;&#10;    // Android 13+ notification permission check&#10;    bool? granted;&#10;    if (Platform.isAndroid) {&#10;      try {&#10;        final int sdkInt = int.parse(Platform.version.split(&quot;.&quot;).first);&#10;        if (sdkInt &gt;= 33) {&#10;          final status = await Permission.notification.request();&#10;          granted = status.isGranted;&#10;          debugPrint('[NotificationService] Notification permission status: $status');&#10;        } else {&#10;          granted = true;&#10;        }&#10;      } catch (e) {&#10;        debugPrint('[NotificationService] Error requesting Android notification permission: $e');&#10;        granted = null;&#10;      }&#10;    } else {&#10;      granted = true;&#10;    }&#10;    if (granted == false) {&#10;      debugPrint(' Notification permission denied');&#10;    }&#10;  }&#10;&#10;  // ✅ Request notification permissions&#10;  static Future&lt;void&gt; requestPermissions() async {&#10;    debugPrint('[NotificationService] Requesting notification permissions...');&#10;    // iOS permissions&#10;    await _plugin&#10;        .resolvePlatformSpecificImplementation&lt;&#10;            IOSFlutterLocalNotificationsPlugin&gt;()&#10;        ?.requestPermissions(&#10;      alert: true,&#10;      badge: true,&#10;      sound: true,&#10;    );&#10;    // Android 13+ POST_NOTIFICATIONS permission&#10;    if (Platform.isAndroid) {&#10;      try {&#10;        final int sdkInt = int.parse(Platform.version.split(&quot;.&quot;).first);&#10;        debugPrint('[NotificationService] Android SDK version: '&#10;            '[32m$sdkInt[0m');&#10;        if (sdkInt &gt;= 33) {&#10;          final status = await Permission.notification.request();&#10;          debugPrint('[NotificationService] Notification permission status: '&#10;              '[33m$status[0m');&#10;        }&#10;      } catch (e) {&#10;        debugPrint('[NotificationService] Error requesting Android notification permission: '&#10;            '[31m$e[0m');&#10;      }&#10;    }&#10;  }&#10;&#10;  // ✅ Schedule a notification&#10;  static Future&lt;void&gt; scheduleNotification({&#10;    required int id,&#10;    required String title,&#10;    required String body,&#10;    required DateTime scheduledTime,&#10;  }) async {&#10;    if (scheduledTime.isBefore(DateTime.now())) {&#10;      debugPrint('⚠️ Skipping notification: date is in the past ([33m$scheduledTime[0m)');&#10;      return;&#10;    }&#10;    final tz.TZDateTime tzTime = tz.TZDateTime.from(scheduledTime, tz.local);&#10;    debugPrint('[NotificationService] Scheduling notification: '&#10;        'id=$id, title=&quot;$title&quot;, body=&quot;$body&quot;, scheduledTime=$scheduledTime');&#10;    try {&#10;      await _plugin.zonedSchedule(&#10;        id,&#10;        title,&#10;        body,&#10;        tzTime,&#10;        const NotificationDetails(&#10;          android: AndroidNotificationDetails(&#10;            'reminders_channel',&#10;            'Reminders',&#10;            channelDescription: 'Notification channel for task reminders',&#10;            importance: Importance.max,&#10;            priority: Priority.high,&#10;            playSound: true,&#10;            enableVibration: true,&#10;            enableLights: true,&#10;          ),&#10;        ),&#10;        payload: 'default_payload',&#10;        androidScheduleMode: AndroidScheduleMode.exactAllowWhileIdle,&#10;        matchDateTimeComponents: DateTimeComponents.dateAndTime,&#10;      );&#10;      debugPrint('[NotificationService] Notification scheduled successfully.');&#10;    } on PlatformException catch (e) {&#10;      debugPrint('[NotificationService] PlatformException while scheduling notification: '&#10;          '\u001b[31m[31m${e.code}: ${e.message}\u001b[0m');&#10;      if (e.code == 'exact_alarms_not_permitted') {&#10;        await ensureExactAlarmPermission();&#10;      } else {&#10;        rethrow;&#10;      }&#10;    } catch (e) {&#10;      debugPrint('[NotificationService] Error while scheduling notification: '&#10;          '\u001b[31m$e\u001b[0m');&#10;      rethrow;&#10;    }&#10;  }&#10;&#10;  /// Opens the system settings for exact alarm permission (Android 12+)&#10;  static Future&lt;void&gt; ensureExactAlarmPermission() async {&#10;    if (Platform.isAndroid) {&#10;      final intent = const AndroidIntent(&#10;        action: 'android.settings.REQUEST_SCHEDULE_EXACT_ALARM',&#10;        flags: &lt;int&gt;[Flag.FLAG_ACTIVITY_NEW_TASK],&#10;      );&#10;      await intent.launch();&#10;    }&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import 'dart:io';&#10;&#10;import 'package:android_intent_plus/android_intent.dart';&#10;import 'package:android_intent_plus/flag.dart';&#10;import 'package:flutter/foundation.dart';&#10;import 'package:flutter/services.dart';&#10;import 'package:flutter_local_notifications/flutter_local_notifications.dart';&#10;import 'package:flutter_timezone/flutter_timezone.dart';&#10;import 'package:timezone/timezone.dart' as tz;&#10;import 'package:timezone/data/latest.dart' as tz;&#10;import 'package:permission_handler/permission_handler.dart';&#10;&#10;class NotificationService {&#10;  // ✅ Define the plugin instance&#10;  static final FlutterLocalNotificationsPlugin _plugin =&#10;      FlutterLocalNotificationsPlugin();&#10;&#10;  // ✅ Initialization method&#10;  static Future&lt;void&gt; initialize() async {&#10;    tz.initializeTimeZones();&#10;    final String localTimeZone = await FlutterTimezone.getLocalTimezone();&#10;    tz.setLocalLocation(tz.getLocation(localTimeZone));&#10;    debugPrint('[NotificationService] Using local timezone: $localTimeZone');&#10;&#10;    const androidSettings = AndroidInitializationSettings('@mipmap/ic_launcher');&#10;    const iosSettings = DarwinInitializationSettings();&#10;&#10;    const initSettings = InitializationSettings(&#10;      android: androidSettings,&#10;      iOS: iosSettings,&#10;    );&#10;&#10;    await _plugin.initialize(initSettings);&#10;&#10;    // Android notification channel setup&#10;    const AndroidNotificationChannel channel = AndroidNotificationChannel(&#10;      'reminders_channel',&#10;      'Reminders',&#10;      description: 'Notification channel for task reminders',&#10;      importance: Importance.max,&#10;    );&#10;    await _plugin&#10;        .resolvePlatformSpecificImplementation&lt;AndroidFlutterLocalNotificationsPlugin&gt;()&#10;        ?.createNotificationChannel(channel);&#10;&#10;    // Android 13+ notification permission check&#10;    bool? granted;&#10;    if (Platform.isAndroid) {&#10;      try {&#10;        final int sdkInt = int.parse(Platform.version.split(&quot;.&quot;).first);&#10;        if (sdkInt &gt;= 33) {&#10;          final status = await Permission.notification.request();&#10;          granted = status.isGranted;&#10;          debugPrint('[NotificationService] Notification permission status: $status');&#10;        } else {&#10;          granted = true;&#10;        }&#10;      } catch (e) {&#10;        debugPrint('[NotificationService] Error requesting Android notification permission: $e');&#10;        granted = null;&#10;      }&#10;    } else {&#10;      granted = true;&#10;    }&#10;    if (granted == false) {&#10;      debugPrint(' Notification permission denied');&#10;    }&#10;  }&#10;&#10;  // ✅ Request notification permissions&#10;  static Future&lt;void&gt; requestPermissions() async {&#10;    debugPrint('[NotificationService] Requesting notification permissions...');&#10;    // iOS permissions&#10;    await _plugin&#10;        .resolvePlatformSpecificImplementation&lt;&#10;            IOSFlutterLocalNotificationsPlugin&gt;()&#10;        ?.requestPermissions(&#10;      alert: true,&#10;      badge: true,&#10;      sound: true,&#10;    );&#10;    // Android 13+ POST_NOTIFICATIONS permission&#10;    if (Platform.isAndroid) {&#10;      try {&#10;        final int sdkInt = int.parse(Platform.version.split(&quot;.&quot;).first);&#10;        debugPrint('[NotificationService] Android SDK version: '&#10;            '[32m$sdkInt[0m');&#10;        if (sdkInt &gt;= 33) {&#10;          final status = await Permission.notification.request();&#10;          debugPrint('[NotificationService] Notification permission status: '&#10;              '[33m$status[0m');&#10;        }&#10;      } catch (e) {&#10;        debugPrint('[NotificationService] Error requesting Android notification permission: '&#10;            '[31m$e[0m');&#10;      }&#10;    }&#10;  }&#10;&#10;  // ✅ Schedule a notification&#10;  static Future&lt;void&gt; scheduleNotification({&#10;    required int id,&#10;    required String title,&#10;    required String body,&#10;    required DateTime scheduledTime,&#10;  }) async {&#10;    if (scheduledTime.isBefore(DateTime.now())) {&#10;      debugPrint('⚠️ Skipping notification: date is in the past ([33m$scheduledTime[0m)');&#10;      return;&#10;    }&#10;    final tz.TZDateTime tzTime = tz.TZDateTime.from(scheduledTime, tz.local);&#10;    debugPrint('[NotificationService] Scheduling notification: '&#10;        'id=$id, title=&quot;$title&quot;, body=&quot;$body&quot;, scheduledTime=$scheduledTime');&#10;    try {&#10;      await _plugin.zonedSchedule(&#10;        id,&#10;        title,&#10;        body,&#10;        tzTime,&#10;        const NotificationDetails(&#10;          android: AndroidNotificationDetails(&#10;            'reminders_channel',&#10;            'Reminders',&#10;            channelDescription: 'Notification channel for task reminders',&#10;            importance: Importance.max,&#10;            priority: Priority.high,&#10;            playSound: true,&#10;            enableVibration: true,&#10;            enableLights: true,&#10;          ),&#10;        ),&#10;        payload: 'default_payload',&#10;        androidScheduleMode: AndroidScheduleMode.exactAllowWhileIdle,&#10;        matchDateTimeComponents: DateTimeComponents.dateAndTime,&#10;      );&#10;      debugPrint('[NotificationService] Notification scheduled successfully.');&#10;    } on PlatformException catch (e) {&#10;      debugPrint('[NotificationService] PlatformException while scheduling notification: '&#10;          '\u001b[31m[31m${e.code}: ${e.message}\u001b[0m');&#10;      if (e.code == 'exact_alarms_not_permitted') {&#10;        await ensureExactAlarmPermission();&#10;      } else {&#10;        rethrow;&#10;      }&#10;    } catch (e) {&#10;      debugPrint('[NotificationService] Error while scheduling notification: '&#10;          '\u001b[31m$e\u001b[0m');&#10;      rethrow;&#10;    }&#10;  }&#10;&#10;  /// Opens the system settings for exact alarm permission (Android 12+)&#10;  static Future&lt;void&gt; ensureExactAlarmPermission() async {&#10;    if (Platform.isAndroid) {&#10;      final intent = const AndroidIntent(&#10;        action: 'android.settings.REQUEST_SCHEDULE_EXACT_ALARM',&#10;        flags: &lt;int&gt;[Flag.FLAG_ACTIVITY_NEW_TASK],&#10;      );&#10;      await intent.launch();&#10;    }&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pubspec.yaml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pubspec.yaml" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>